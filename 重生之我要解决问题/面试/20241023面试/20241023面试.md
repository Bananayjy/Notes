# 20241023面试

## 一、面试问题记录

1、讲讲自己的项目，讲到了业务状态和审批引擎状态一致性问题的解决，没有考虑到锁的使用，然后引出分布式锁，没用过分布式锁打脸。

2、分布式锁的看门狗机制（回答比较浅显，守护线程去监听）

3、mysql优化 -> 加索引，多个字段怎么加索引？

4、mysql 深分页如何优化（深分页具体的查找获取数据过程不是很熟悉）



## 二、复盘

### 1.1 关于业务问题

首先是业务上的，是因为审批引擎有个taskId，在审批通过的时候会就根据taskId，然后去调用审批引擎的同意接口。这个taskId是各个运行任务的id（ACT_RU_TASK表）。如果审批页面有多个组织人同时点进前端页面，并且A审批通过后，那么B再进行审核通过就会造成无法根据此时的taskId找到对应的运行任务，并且因为A已经通过，此时业务的状态已经变为下一个状态，所以会造成进入到下一个状态的业务逻辑中，从而导致的审批引擎和业务状态不一致的问题。   因此在调用之前需要进行当前审批引擎的状态和此时业务状态一致性的校验，并且需要加一个锁，保证获取状态的线程安全性。（这里要怎么处理线程安全还是要进一步分析。其实不用加锁，即如果我B再审批的过程中，A如果已经查询了状态，是上一个状态，此时可以通过事务去控制，因为A在更新的时候，携带的还是上一次任务id，所以会更新失败，然后直接回滚即可，将业务数据的状态也回滚掉）

### 1.2 分布式锁

分布式锁面试的时候说的用的是RLock去进行，然后就Lock和tryLock产生了争议。

在使用 Redisson 作为 Redis 的客户端时，`RLock` 是一种可重入的分布式锁，提供了方便的方法来管理并发访问。下面是对 `Lock` 和 `tryLock` 方法的详细说明。

RLock 的 Lock 方法

`RLock.lock()` 方法用于获取锁，如果锁没有被其他线程占用，当前线程将获取到锁并继续执行。如果锁已经被其他线程占用，调用此方法的线程将会被阻塞，直到锁被释放。

示例代码：

```
java复制代码import org.redisson.api.RedissonClient;
import org.redisson.api.RLock;
import org.redisson.Redisson;
import org.redisson.config.Config;

public class LockExample {

    public static void main(String[] args) {
        // 配置 Redisson
        Config config = new Config();
        config.useSingleServer().setAddress("redis://127.0.0.1:6379");
        RedissonClient redisson = Redisson.create(config);

        RLock lock = redisson.getLock("myLock");

        try {
            // 获取锁
            lock.lock();
            System.out.println("Lock acquired, executing critical section...");
            // 执行临界区代码
        } finally {
            // 确保锁会被释放
            lock.unlock();
            System.out.println("Lock released.");
        }

        redisson.shutdown();
    }
}
```

RLock 的 tryLock 方法

`RLock.tryLock(long waitTime, long leaseTime, TimeUnit timeUnit)` 方法用于尝试获取锁。此方法会在设定的 `waitTime` 内尝试获取锁，若成功获取锁，将会保持 `leaseTime` 的有效期。如果获取锁失败，方法会立即返回 `false`。

示例代码：

```
java复制代码import org.redisson.api.RedissonClient;
import org.redisson.api.RLock;
import org.redisson.Redisson;
import org.redisson.config.Config;

import java.util.concurrent.TimeUnit;

public class TryLockExample {

    public static void main(String[] args) {
        // 配置 Redisson
        Config config = new Config();
        config.useSingleServer().setAddress("redis://127.0.0.1:6379");
        RedissonClient redisson = Redisson.create(config);

        RLock lock = redisson.getLock("myLock");

        try {
            // 尝试获取锁，最多等待 5 秒，锁的有效期为 10 秒
            if (lock.tryLock(5, 10, TimeUnit.SECONDS)) {
                try {
                    System.out.println("Lock acquired, executing critical section...");
                    // 执行临界区代码
                } finally {
                    lock.unlock(); // 释放锁
                    System.out.println("Lock released.");
                }
            } else {
                System.out.println("Unable to acquire lock, it might be locked by another process.");
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        redisson.shutdown();
    }
}
```

总结

- **`lock()` 方法**：会持续等待获取锁，并且在获取到锁后，锁会一直保持直到显式调用 `unlock()` 释放。
- **`tryLock(long waitTime, long leaseTime, TimeUnit timeUnit)` 方法**：尝试在设定的时间内获取锁，若锁未在指定时间内成功获取，返回 `false`，不会阻塞当前线程。

注意事项

- 使用 `lock()` 方法时，一定要在 `finally` 块中释放锁，以避免死锁。
- `tryLock()` 方法的 `leaseTime` 参数可以设置锁的持有时间，防止因未释放锁而导致的锁占用。

### 1.3 看门狗机制

其实就是一个守护线程去维护，具体的等学习分布式锁的时候一起总结。。。



### 1.4 mysql优化 -> 加索引

#### 1.问到了关于索引优化的问题，问到了比如说一个很复杂的SQL查询，有10个条件（字段），如何去选择性地加索引，根据什么去加索引呢？(如果一个表有10个字段，需要给他们建立联合索引，根据什么去建立呢)

**(1)查询场景优先**

你需要分析表中常见的查询模式和业务需求，看看哪些字段经常出现在 `WHERE`、`ORDER BY`、`GROUP BY`、`JOIN`、`HAVING` 等子句中。只有这些字段被**频繁**用于条件过滤、排序或分组时，才需要考虑为它们创建索引。

- **常见查询条件**：优先为常常出现在 `WHERE` 子句中的列创建索引。确保索引与查询条件匹配，才能加速查找。
- **排序或分组字段**：如果某些字段经常出现在 `ORDER BY` 或 `GROUP BY` 中，那么考虑将它们也加入索引。
- **JOIN 查询字段**：如果某些字段经常在 `JOIN` 语句中用作连接条件，它们也应该纳入联合索引。



**(2) 最左前缀原则**

MySQL 的联合索引遵循**最左前缀原则**，即从索引的最左列开始逐步匹配查询条件。因此，索引中字段的排列顺序非常重要。

- **最常用的字段放在最左边**：把最频繁出现在查询条件中的列放在联合索引的最左边。这样可以确保索引被最广泛地利用。
- **等值条件优先**：如果查询中同时有等值条件（`=`）和范围条件（如 `>`, `<`, `BETWEEN`），将等值条件的列放在索引的左边，范围查询的列放在靠后的位置。
- **过滤效果好的字段优先**：将选择性较高、能有效过滤大量数据的字段放在索引前面。选择性高意味着这个字段有较多不同的值，索引可以更快缩小结果集范围。



**(3) 联合索引的覆盖能力**

联合索引不仅能加速 `WHERE` 子句的查询，还可以作为覆盖索引使用。如果查询的 `SELECT` 子句只包含索引中的字段，MySQL 可以直接从索引中返回结果，而不需要访问表中的数据行（避免访问数据页）。这样可以进一步提升查询性能。

例如：

```
sql


复制代码
SELECT A, B FROM table WHERE A = 10 AND B > 20;
```

如果 `A` 和 `B` 都是联合索引的一部分，MySQL 可以直接从索引中读取数据，无需访问表。



**(4) 字段的选择性**

字段的**选择性**（cardinality）是指字段中唯一值的数量占总记录数的比例。选择性越高，索引的效果越好。因此，优先考虑选择性高的字段作为索引的一部分，可以有效减少扫描的记录数。

- 如果某个字段的选择性非常低（例如一个布尔字段或性别字段，只有几个不同的值），将它作为索引的首列并没有太大意义，因为它无法很好地过滤数据。

如对于一个只有两个值（如“男”和“女”）的字段，通常情况下**不建议添加索引**，在只有两个值的情况下（如性别字段），选择性极低。这意味着在使用该字段进行查询时，结果集往往很大，索引的效果并不明显，并且添加索引会增加数据库的存储开销，尤其是当字段的选择性低时，索引可能会占用不必要的空间。如果查询出来的数据量级比较大的会，会优化为全表扫描（如果是联合索引,mysql 是否根据首次索引条件查询出的主键进行二次查找，也是要看查询出来的数据量级，如果数据量接近全表数据量的话，就会进行全表扫描，否则根据第一次查询出来的主键进行二次查询。）

具体示例：

假设我们有一个包含用户信息的表 `users`，其中有以下字段：

```
plaintext复制代码id | name  | gender | age
---|-------|--------|-----
1  | Alice | Female | 25
2  | Bob   | Male   | 30
3  | Carol | Female | 22
4  | David | Male   | 35
5  | Eve   | Female | 28
...
1000| Frank| Male   | 40
```

当再次执行相同的查询时，MySQL 会使用该索引来定位 `gender = 'Male'` 的记录。由于“Male”和“Female”各有 500 条记录，索引将返回 500 条记录的指针，但接下来需要访问 500 条记录以返回结果。全表扫描：对于 1000 条记录的表，全表扫描可能是一个简单的线性遍历，大约会涉及 1000 次读取。使用索引：使用索引后，MySQL 首先会查找索引中的“Male”值，并返回其对应的指针。由于指针指向的仍然是 500 条记录，MySQL 需要访问这些记录以返回结果，大约会涉及 500 次读取。在这个情况下，尽管使用了索引，但由于选择性低，仍然需要访问大量的记录，因此整体查询效率未必有明显提升。对于这种低选择性字段的索引，可能会导致额外的索引查找开销而不一定提升性能，尤其在小型或中型表上更为明显。



扩展：如果构建索引的字段有重复的内容，其查找过程是怎么样的

**从根节点开始**：MySQL 将从 B-Tree 索引的根节点开始查找。

**按顺序比较**：

- 如果根节点有多个子节点，它会与根节点的值进行比较（如 “Male”）。
- 根据比较结果，MySQL 会向相应的子节点移动。在这个示例中，它将继续查找 “Male”。

**到达叶子节点**：

- 一旦到达叶子节点，MySQL 会找到所有匹配的值（在这种情况下是 “Male”），并将指针返回给查询引擎。
- 叶子节点将包含指向所有记录的指针。例如，如果有两个记录的 `gender` 为 “Male”，叶子节点会保存指向这两条记录的指针。

**重复值的指针**：在叶子节点中，所有相同的值（如多个“Male”）都会有相应的指针，指向实际数据行的位置。MySQL 会访问这些指针并获取完整的记录。

**性能影响**：由于重复值的存在，查找的性能不会受到影响，因为 B-Tree 索引依然能够快速定位到重复值的叶子节点，尽管需要访问多个记录。

**结果集返回:**MySQL 会根据指针读取实际表中的记录，将结果集返回给客户端。例如，在这个查询中，返回的结果会包括所有 `gender` 为 “Male” 的记录。



(5) **避免过多字段的联合索引**

尽量避免创建包含过多字段的联合索引，尤其是 10 个字段的表。联合索引越大，维护成本就越高，插入、更新、删除操作都会变慢。实际场景中，一般联合索引包含 2-5 个字段是比较合适的。

如果一个查询需要涉及非常多的列，并且没有明确的高效过滤字段，可以考虑分开创建多个单列索引，或者根据查询类型创建多个联合索引，而不是将所有列都加入一个联合索引。



(6)**多重查询类型的平衡**

有时，一个表需要处理多种不同类型的查询，而这些查询可能涉及不同的列。在这种情况下，可能需要设计多个联合索引，分别针对不同的查询场景。

例如，假设你有以下两类查询：

- 查询1：`SELECT * FROM table WHERE A = 10 AND B = 20;`
- 查询2：`SELECT * FROM table WHERE C = 5 AND D = 6;`

针对这两类查询，创建联合索引 `(A, B)` 和 `(C, D)` 会比创建一个包含所有四个字段的联合索引 `(A, B, C, D)` 更有效，因为每个索引都是为特定查询优化的。

(7). **索引覆盖和冗余的考虑**

MySQL 允许你创建多个联合索引，但你需要注意避免索引冗余。如果一个索引已经可以覆盖其他查询，没必要再创建冗余的索引。例如，如果已经有联合索引 `(A, B, C)`，那么再创建一个 `(A, B)` 的索引通常是冗余的，因为前者已经包含了 `(A, B)` 的功能。

(8). **考虑联合索引的维护成本**

索引并不是越多越好。每个索引都会增加写操作的开销，尤其是在数据插入、更新和删除时，索引会需要同步更新。因此，尽量根据实际查询的需求创建必要的联合索引，避免因为过多不必要的索引导致写性能的下降。

### 总结

在给 10 个字段的表创建联合索引时，需要根据实际查询模式来决定索引的列及其顺序。遵循以下原则：

1. 分析查询的使用场景和需求。
2. 根据最左前缀原则选择列的顺序。
3. 选择性高的字段放在索引前面。
4. 考虑覆盖索引的好处，避免冗余索引。
5. 注意索引带来的维护成本，避免过多的索引。

这样可以确保你设计的联合索引既能提升查询性能，又不会过多增加维护开销。



#### 2.关于联合索引的查找过程：

参考文章

- https://blog.csdn.net/zhizhengguan/article/details/122135471

- https://cloud.tencent.com/developer/article/2361274

> ## 原理
>
> 之所以要分析联合索引，是因为我们平时设计系统的时候一般都是设计联合索引，很少用单个字段做索引。
>
> 现在我们假设：
>
> - 当前有一个表是存储学生成绩的，这个表里有id，这个id是一个自增主键，默认会基于主键做一个聚簇索引。
> - 然后，这个表里还包含了学生班级、学生姓名、科目名称、成绩分数这四个字段。
>
> 平时查询，可能比较多的是查找某个班的某个学生的某个科目的成绩。所以，我们可以基于学生班级、学生姓名、科目名称建立一个联合索引。
>
> 如下图展示了这三个字段组成的联合索引的部分内容：
>
> - 下面有两个数据页，第一个数据页里有三条数据，每条数据都包含了联合索引的三个字段的值和主键值，数据页内部是按照顺序排序的。
> - 首先按照班级字段的值来排序，如果一样则按照学生姓名字段来排序，如果一样则按照科目名称来排序。所以数据页内部都是按照三个字段的值来排序的，而且还组成了单向链表
> - 然后数据页之间也是有顺序的，第二个数据页里的三个字段的值一定都是按照上一个数据页里的三个字段的值，比较丰富也是按照班级名称、学生姓名、科目名称依次来比较的，数据页之间组成双向链表。
> - 索引页里就是两条数据，分别指向两个索引页，索引存放的是每个数据页里最小的那个数据的值。可以看到，索引页里指向两个数据页的索引项里存放了最小数据页里最小的值。
> - 索引页内部的数据页是组成单向链表有序的，如果你有多个索引页，那么索引页之间也是有序的，组成了双向链表。
>
> ![在这里插入图片描述](20241023%E9%9D%A2%E8%AF%95.assets/f9938ad6e3989f1eaa37cd6e7c410698.png)
>
> ### 全值匹配规则
>
> 好了，那么现在假设我们想要搜索：1班+张小强+数学的成绩，此时你可能会写一个类似下面的SQL语句，`select * from student_score where class_name='1班' and student_name='张小强' and subject_name='数学'`。
>
> 此时就涉及到了一个索引使用的规则，那就是你发起的SQL语句里，where条件里的几个字段都是基于等值来查询，都是用的**等于**号。而且**where条件里的几个字段的名称和顺序也跟你的联合索引一模一样**！此时就是等值匹配规则，上面的SQL语句百分比是用联合索引来查询的。
>
> 查询的过程也很简单：
>
> - 首先到索引页里去找，索引页里有多个数据页的最小值记录，此时直接在索引页里基于二分查找法就可以了：先是根据班级名称来找1班这个值对应的数据页，直接可以定位到它所在的数据页。如下图：
>
> ![在这里插入图片描述](20241023%E9%9D%A2%E8%AF%95.assets/ef96c6b5d93c0b988f2bfa4a27ff6bc7.png)
>
> - 然后直接找到这个索引指向的那个数据页就可以了，在数据页内部本身也是一个单向链表，也是直接做二分查找就可以了。先按照1班这个值来找，你会发现几条数据集都是1班，此时就可以按照张小强这个姓名来二分查找，此时会发现多条数据都是张小强，接着就按照科目名称数学来二分查找。
> - 很快就可以定位到下图中的一条数据，1班的张小强的数学科目，它对应的数据的id是127。如下图：
>
> ![在这里插入图片描述](20241023%E9%9D%A2%E8%AF%95.assets/cc9e784c4cb653174464670d1f8468c4.png)
>
> - 然后根据主键id=127到聚簇索引里按照一样的思路，从索引根节点开始二分查找快速定位到下个层级的页，再不停的找，很快就可以找到id=127的那条数据，然后从里面提取所有的字段，包括分数，就可以了。
>
> 上面整个过程就是联合索引的查找过程，以及全值匹配规则。
>
> - **如果你的SQL语句的where条件里用的几个字段的名称和顺序，都跟你的索引里的字段一样，同时都是基于等号的等值匹配，那么直接就会按照上述过程来找**。
> - **即使where语句里写的顺序，与联合索引里的字段顺序不一致，也没有关系，MySQL会自动优化为联合索引的字段顺序去找**
> - **对于联合索引来说，就是依次按照各个字段来进行二分查找，先定位到第一个字段对应的值在哪个页里，然后如果一条字段里有多条数据值都一样，就根据第二个字段来找，依次类推，一定可以定位到某条或者某几条数据！**
>
> ### 最左侧列匹配
>
> 这个意思就是假设我们联合索引是`KEY(class_name，student_name，subject_name)`，那么**不一定必须要在where语句里根据三个字段来查，其实只要根据最左侧的部分字段来查，也是可以的。**
>
> - 比如你可以写select * from student_score where class_name=‘’ and student_name=‘’，就查某个学生所有科目的成绩，这都是没有问题的。
> - 但是假设你写一个select * from student_score where subject_name=‘’，那就不行了，因为联合索引的B+树里，是必须先按照class_name查，再按照student查，不能跳过前两个字段，直接按照最后一个subject_name来查的。
> - 另外，假设你写一个select * from student_score where class_name=‘’ and subject_name=‘’，那么只有class_name的值可以在索引里搜索，剩下的subject_name是没法在索引里找的，道理同上。
>
> 所以在建立索引的过程中，你必须考虑好联合索引字段的顺序，以及你平时写SQL的时候要按照哪几个字段来查
>
> ### 最左前缀匹配原则
>
> - 即如果你要用like语法来查，比如select * from student_score where class_name like ‘1%’，查找所有1打头的班级的分数，那么也是可以用到索引的。
> - 确定的最左前缀是1，然后后面的给一个模糊匹配符号，那也是可以基于索引来查找的，这是没问题的。
> - 但是你如果写class_name like ‘%班’，在左侧用一个模糊匹配符，那他就没法用索引了，因为不知道你最左前缀是什么，怎么去索引里找啊？
>
> ### 范围查找规则
>
> - 这个意思就是说，我们可以用select * from student_score where class_name > ‘1班’ and class_name < '5班’这样的语句来范围查找某几个班级的分数。
> - 这个时候也是会用到索引的，因为我们的索引的最下层的数据页都是按照顺序组成的双向链表的，所以完全可以先找到‘1班’对应的数据，再找到‘5班’对应的数据页，两个数据页中间的那些数据页，就全都是在你范围内的数据了。
> - 但是如果你要是写select * from student_score where class_name > ‘1班’ and class_name < ‘5班’ and student_name > ‘xx’，这里只有class_name是可以基于索引来找的，student_name的范围查询是没法用到索引的。
>
> 这也是一条规则，就是你的**where语句里如果有范围查询，那只有对联合索引里最左侧的列进行范围查询才能用到索引**。
>
> ### 等值匹配+范围匹配的规则
>
> 如果你要是用select * from student_score where class_name=‘1班’ and student_name>‘xx’ and subject_name<‘yy’，那么此时你首先可以用class_name在索引里精准定位到一波数据，接着这波数据里的student_name都是按照顺序排列的，所以student_name > 'xx’这会基于索引来查找，但是接下来的subject_name < 'yy’是不能用索引的。
>
> ## 小结
>
> 综上，一般如果我们写SQL语句，都是用联合索引的最左侧的多个字段来进行等值匹配+范围，或者是基于最左侧的部分字段来进行最左前缀模糊匹配，或者基于最左侧字段来进行范围搜索，这就要写符合规则的SQL语句，才能用上我们建立好的联合索引。
>
> ## 问题
>
> ### 什么是联合索引？为什么需要注意联合索引中的顺序？
>
> MySQL中可以使用多个字段同时建立一个索引，叫做联合索引。
>
> 在联合索引中，如果想要索引，需要按照建立索引的字段顺序挨个使用，否则无法命中索引。
>
> 所以，我们**在建立联合索引的时候，一定要把最常用的列放在最左边**。
>
> ### 如何创建联合索引
>
> 按照我们的想法，一个查询创建一个索引，所以我们针对这两条 SQL 创建了两个索 引，这种做法觉得正确吗？
>
> ```cpp
> CREATE INDEX idx_name on user_innodb(name);
> CREATE INDEX idx_name_phone on user_innodb(name,phone);
> 12
> ```
>
> 当我们创建一个联合索引的时候，按照最左匹配原则，用左边的字段 name 去查询 的时候，也能用到索引，所以第一个索引完全没必要。
>
> 如果我们创建三个字段的索引 index(a,b,c)，相当于创建三个索引：
>
> - index(a)
> - index(a,b)
> - index(a,b,c)
>
> **用 where b=? 和 where b=? and c=? 和 where a=? and c=?是不能使用到索引的。不能不用第一个字段，不能中断。 这里就是 MySQL 联合索引的最左匹配原则**。
>
> ------
>
> ------
>
> ------
>
> ------
>
> ------
>
> ![在这里插入图片描述](20241023%E9%9D%A2%E8%AF%95.assets/b76d018763233daed6a1e0d14ab394eb.png)
>
> - 联合索引在B+Tree中是复合的数据结构，它是按照从左到右的顺序来建立索引树的(name在左边、phone在右边)
> - 从上图可以看出来，name是有序的，phone是无序的。当name相等的时候，pthone才是有序的
> - 这时候我们使用 `where name= '青山' and phone = '136xx '`去查询数据的时候，B+Tree会优先比较name来确定下一步应该搜索的方向，往左还是向右。如果name相同的时候再比较pthone。但是如果查询条件没有name，就不知道应该查哪个节点，因为建立搜索树的时候name是第一个比较因子，所以用不到索引。



#### 3.全表扫描通常发生在以下几种情况：

1. **低选择性字段**：如只有两个可能值的字段（例如“男”和“女”），如果查询条件在这类字段上，数据库可能会选择全表扫描，因为索引无法有效过滤数据。
2. **没有适合的索引**：如果查询的条件没有合适的索引支持，数据库会选择扫描整个表来找到匹配的行。
3. **查询条件涉及多个字段**：当查询条件涉及多个字段时，如果没有建立合适的复合索引，数据库可能会选择全表扫描来满足查询。
4. **数据分布不均**：如果某些值在表中非常普遍，数据库可能认为使用索引不划算，从而选择全表扫描。
5. **复杂的查询**：某些复杂的查询，尤其是包含多个 `JOIN` 或 `UNION` 的查询，可能导致数据库优化器决定进行全表扫描，以获取所有必要的数据。
6. **临时表或小表**：在处理小表或临时表时，数据库可能会选择全表扫描，因为扫描整个表的成本低于使用索引。
7. **索引失效**：如果查询条件中的某些条件使得索引失效（如使用不支持索引的函数或运算），数据库会退而求其次，进行全表扫描。

在设计索引时，理解这些情况可以帮助你更有效地优化查询性能。



联合索引相关：

https://www.51cto.com/article/786397.html

https://www.cnblogs.com/yqh0128/articles/14681034.html

https://juejin.cn/post/6844904073955639304

范围查询过程：

https://juejin.cn/post/7168452332219924494

如果a>1 and a<3 先定位a = 1和 a =3的数据，然后取中间的内容，如果a>1,则定位a=1的数据，然后去后面的数据。因为叶子节点各个节点有双向指针维护，并且节点中的数据也有双向指针维护，因此支持范围查找。





### 1.4 mysql 深分页如何优化

- https://juejin.cn/post/7012016858379321358
- https://javaguide.cn/high-performance/deep-pagination-optimization.html#%E5%AD%90%E6%9F%A5%E8%AF%A2
- https://juejin.cn/post/6985478936683610149





SELECT id FROM t_order LIMIT 1000000, 1 利用主键索引和全表扫描有什么区别吗

`SELECT id FROM t_order LIMIT 1000000, 1` 查询在利用主键索引与全表扫描时的区别主要体现在执行效率和处理方式上。以下是具体的对比：

1. **执行方式**

利用主键索引

- **索引查找**：当 `id` 是主键并且有索引时，MySQL 会首先遍历主键索引（通常是 B-Tree 结构）。由于主键索引是有序的，MySQL 能够快速找到需要的记录（跳过索引条目的方式）
- **跳过记录**：MySQL 在索引中会逐一计数，跳过前 1,000,000 个索引指针，直到找到第 1,000,001 个指针。
- **数据访问**：找到指针后，MySQL 根据指针直接访问相应的记录，以获取所需的 `id`。

全表扫描

- **逐行读取**：全表扫描意味着 MySQL 会从表的第一条记录开始，逐行读取所有记录，直到跳过 1,000,000 条。
- **性能消耗**：对于大表，逐行读取将消耗大量的 I/O 资源，查询时间会显著增加。
- **没有索引支持**：在全表扫描的情况下，MySQL 不利用任何索引结构，所有数据都需要从头到尾检查。

2. **性能比较**

- **效率差异**：使用主键索引时，查询效率会高得多，因为索引提供了有序访问和快速查找的能力。全表扫描则需要更多的时间和资源，尤其是在数据量较大的情况下。
- **响应时间**：在大数据集上，利用索引的查询响应时间可能是全表扫描的几倍甚至更高，因为跳过记录的成本大幅降低。

3. **资源消耗**

- **I/O 操作**：主键索引查询通过索引跳过记录，减少了需要访问的行数，降低了 I/O 操作。全表扫描需要读取每一行数据，I/O 操作显著增加。
- **内存使用**：在主键索引查询中，内存使用通常较低，因为只需存储索引结构，而全表扫描可能需要在内存中加载整个表。

4. **适用场景**

- **主键索引适合**：对于需要频繁查找的操作，特别是涉及排序和过滤的查询，使用主键索引能够极大地提高效率。
- **全表扫描适合**：当表很小，或是查询需要检索几乎所有记录时，全表扫描可能是合适的选择。

小结

`SELECT id FROM t_order LIMIT 1000000, 1` 查询在利用主键索引时，MySQL 可以快速找到所需记录，跳过大量数据行，效率高且资源消耗少。而在全表扫描的情况下，MySQL 则需要逐行读取数据，效率低下且资源消耗大。因此，索引的使用对查询性能有显著的正面影响。
