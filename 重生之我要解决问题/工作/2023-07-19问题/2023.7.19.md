# 2023.7.19

## 1. @KeySequence





## 2.consume等lambda表达式（）->的应用







## 3.添加语句的分析（Optional类） 【待解决】

```java
purchase.setApplyDeptId(Optional.ofNullable(gc2Dto.getApplyDept()).map(b -> Convert.toStr(b.getId())).orElse(""));
```

setApplyDeptId：设置purchase对象中的AppluDeptId的值为括号中的内容

**Optional类：ull**

Optional类是java8引入的一个类，目的是解决空指针异常（NullPointerException）的问题，它是一个容器类，可以用来包装一个可能为空的值。

传统上，如果一个方法返回值可能为 null，那么调用该方法时就需要进行空值检查，以防止空指针异常。而使用 `Optional` 类可以提供一种更优雅和安全的方式来处理可能为空的值

Optional 是个容器：它可以保存类型T的值，或者仅仅保存null。Optional提供很多有用的方法，这样我们就不用显式进行空值检测。



**报错举例：**

在java8之前，对于集合或者对象取值的时候往往直接get的时候经常会报空指针异常

```java
//Optional类的测试
@Test
public void testOptional(){
    Map<String, Integer> mp = new HashMap<>();
    mp.put("a", 1);
    mp.put("b", 2);

    //将从map集合中获取到的对象值转化为string数值
    //相当于 null.toString()
    //结果：java.lang.NullPointerException报错
    System.out.println(mp.get("c").toString());
}
```

通过添加Optional类去进行解决

```java
//Optional类的测试
@Test
public void testOptional(){
    Map<String, Integer> mp = new HashMap<>();
    mp.put("a", 1);
    mp.put("b", 2);

    //将从map集合中获取到的对象值转化为string数值
    //结果：java.lang.NullPointerException报错
    //System.out.println(mp.get("c").toString());

    //我们可以使用Optional类的ofNullable方法
    //将map获取到的值放在Optional类中，再去使用.toString()方法
    //这样就不会报错了
    //结果： Optional.empty
   System.out.println(Optional.ofNullable(mp.get('c')).toString());
}
```

那么为什么这样子就可以不保存，我们可以取查看一下对应ofNullable方法的源码

```java
public static <T> Optional<T> ofNullable(T value) {
    return value == null ? empty() : of(value);
}
```

当我们通过mp.get('c')获取到的就是null值，然后将null传进去的时候，value的值等于null，因此返回empty()

empty()的具体内容如下所示：

```java
private static final Optional<?> EMPTY = new Optional<>();

private Optional() {
    this.value = null;
}

public static<T> Optional<T> empty() {
    @SuppressWarnings("unchecked")
    Optional<T> t = (Optional<T>) EMPTY;
    return t;
}
```



Optional涉及到的一些其他相关方法：

static <T> Optional<T> empty()
返回空的 Optional 实例。

2	boolean equals(Object obj)
判断其他对象是否等于 Optional。

3	Optional<T> filter(Predicate<? super <T> predicate)
如果值存在，并且这个值匹配给定的 predicate，返回一个Optional用以描述这个值，否则返回一个空的Optional。

4	<U> Optional<U> flatMap(Function<? super T,Optional<U>> mapper)
如果值存在，返回基于Optional包含的映射方法的值，否则返回一个空的Optional

5	T get()
如果在这个Optional中包含这个值，返回值，否则抛出异常：NoSuchElementException

6	int hashCode()
返回存在值的哈希码，如果值不存在 返回 0。

7	void ifPresent(Consumer<? super T> consumer)
如果值存在则使用该值调用 consumer , 否则不做任何事情。

8	boolean isPresent()
如果值存在则方法会返回true，否则返回 false。

9	<U>Optional<U> map(Function<? super T,? extends U> mapper)
如果有值，则对其执行调用映射函数得到返回值。如果返回值不为 null，则创建包含映射返回值的Optional作为map方法返回值，否则返回空Optional。

10	static <T> Optional<T> of(T value)
返回一个指定非null值的Optional。

11	static <T> Optional<T> ofNullable(T value)
如果为非空，返回 Optional 描述的指定值，否则返回空的 Optional。

12	T orElse(T other)
如果存在该值，返回值， 否则返回 other。

*如果 optional 为空，则返回提供的默认值*



13	T orElseGet(Supplier<? extends T> other)
如果存在该值，返回值， 否则触发 other，并返回 other 调用的结果。

14	<X extends Throwable> T orElseThrow(Supplier<? extends X> exceptionSupplier)


如果存在该值，返回包含的值，否则抛出由 Supplier 继承的异常

15	String toString()
返回一个Optional的非空字符串，用来调试



## 4、Convert工具类





## 5、指定类的静态方法 理解

```java
package com.nbnfsoft.contract.domain.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import io.swagger.annotations.ApiModelProperty;
import org.springframework.util.CollectionUtils;

import java.util.List;
import java.util.stream.Collectors;

/**
 * @author liangjie
 * @Date 2021/6/23 9:27
 * @Description
 */
public class IdNameDto {

    @ApiModelProperty(value = "id")
    @JsonProperty("id")
    private Long id;

    @ApiModelProperty(value = "名称")
    @JsonProperty("name")
    private String name;

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public static String getIdsByList(List<IdNameDto> list){
        if(!CollectionUtils.isEmpty(list)){
            return list.stream().map(s->String.valueOf(s.getId())).collect(Collectors.joining(","));
        }
        return "";
    }

    public static String getNamesByList(List<IdNameDto> list){
        if(!CollectionUtils.isEmpty(list)){
            return list.stream().map(s->String.valueOf(s.getName())).collect(Collectors.joining(","));
        }
        return "";
    }
}

```



## 5、 KeySequence 注解





## 6.@ApiResponses

`@ApiResponses` 是 Swagger 注解之一，用于在 API 文档中定义不同响应情况的注解。它允许您为每个 API 操作定义多个可能的响应，并提供对每个响应的详细描述。

使用 `@ApiResponses` 注解可以提供更全面、清晰和易于理解的 API 文档。以下是 `@ApiResponses` 注解的基本用法示例：

```
java复制代码@ApiResponses(value = {
    @ApiResponse(code = 200, message = "Success", response = User.class),
    @ApiResponse(code = 400, message = "Bad Request"),
    @ApiResponse(code = 401, message = "Unauthorized"),
    @ApiResponse(code = 403, message = "Forbidden"),
    @ApiResponse(code = 404, message = "Not Found"),
    @ApiResponse(code = 500, message = "Internal Server Error")
})
```

上述示例中，`@ApiResponses` 注解用于对一组可能的响应进行定义。每个响应通过 `@ApiResponse` 注解来表示，其中包含响应的状态码（code）、描述信息（message）以及可选的响应模型（response）。

这样，当使用 Swagger 或其他工具生成 API 文档时，响应情况将会被清晰地呈现出来，帮助用户了解每个 API 操作所可能返回的不同响应情况。

请注意，`@ApiResponses` 注解通常与 API 操作的 `@ApiOperation` 注解一起使用，后者用于描述单个操作的详细信息。

希望以上解释对您有所帮助。如果您需要更多信息或有其他相关问题，请随时提问。



## 7.实现将附件上传到钉盘







## 8、Ngnix的配置

公司服务器上的NIGIX配置

```conf
server {
    listen       14084;
	server_name  192.168.120.201;
	client_max_body_size 2048m;
	#proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    #charset utf-8;
	
    location / {
	
		# 非钉钉客户端重定向
		# if ($http_user_agent !~* DingTalk ) { 
		#     rewrite ^/(.*) https://www.baidu.com/$1 permanent;
		# }
		
	    add_header Cache-Control no-cache;
    	root   D:/开发环境/WebSite;
    	index  index.html index.htm;
		try_files $uri $uri/ /qk/index.html;
    }
	
	location /storage/ {
			add_header Cache-Control no-cache;
			alias   D:/storage/;
			index  index.html index.htm;
	}
	
	# 运维产品配置开始
    location /qk-yw/ {
	    add_header Cache-Control no-cache;
    	root   D:/开发环境/WebSite;
    	index  index.html;
		try_files $uri $uri/ /qk-yw/index.html;
    }
	
	location /nbsdeyy/ {
    	proxy_pass       https://nbey.nbnfsoft.com:9643/;
    	#allow all;
    	autoindex on;
    }
    
    #用于新OA产品 http://106.14.126.176:8092/workapi
	location /workapi3 {
    	proxy_pass       http://localhost:8295/workapi;
    	#allow all;
    	autoindex on;
    }
    
    error_page   500 502 503 504  /50x.html;
    location = /50x.html {
    	root   html;
    }    
}
```

#### 问题的解决：

以前在公司测试环境中，发现对于不同的项目，前端访问的一直都是http://192.168.9.201:14084/**这个地址。

那么今天登上ip为192.168.9.201的本地机看了一下，14084端口占用的是NIGIX，然后在NIGIX中配置的前端访问的时候对应的跳转到后端的地址

比如一条前端在访问路径为/workapi3的时候，我们就可以看到其在NIGIX中配置的跳转后端的地址是http://localhost:8295/workapi;

然后在命令行中通过命令 netstat -ano | findstr "8295"可以当前占用端口8295的进程PID

然后在任务管理器中，可以通过进程PID找到其对应的TOMCAT服务器。

#### 对Ngnix中的配置进行一个学习

**1.为什么前端访问后端的时候需要通过Ngnix进行跳转**

在前端访问后端时，使用 Nginx 进行跳转有几个常见的原因和优势：

1. 反向代理：Nginx 可以作为反向代理服务器，将客户端的请求转发到后端的多个服务器上。这样可以实现负载均衡，将请求分发到多个后端服务器，提高系统的性能和可扩展性。
2. 缓存：Nginx 可以缓存静态资源或动态内容，减轻后端服务器的负载。通过缓存响应，Nginx 可以加快用户的访问速度，并减少对后端服务器的请求压力。
3. 安全性：Nginx 提供了丰富的安全功能，如 SSL/TLS 支持和防止恶意攻击的能力。通过将 Nginx 部署在前端，可以终止 SSL/TLS 连接并处理身份验证、访问控制等安全相关任务，保护后端服务器免受直接暴露于公网的风险。
4. URL 重写和路由：Nginx 提供灵活的 URL 重写和路由功能，可以根据请求的 URL 进行映射和转发。这使得在前端进行一些 URL 重定向、路由和代理等操作变得更加方便。
5. 日志和监控：Nginx 提供详细的访问日志和统计信息，有助于分析和监控请求流量，以及了解系统的运行状况。通过 Nginx，您可以更方便地记录和监控前端与后端之间的通信。

总体来说，使用 Nginx 进行前端到后端的跳转可以提供更好的性能、可伸缩性、安全性和管理能力。它充当了前端和后端之间的中间层，并提供了许多额外的功能和优势。

当然，并非所有的应用程序都需要 Nginx 的跳转，这取决于您的具体需求和架构。如果您的应用程序比较简单或者没有特殊需求，直接访问后端服务器也是可行的。

希望这些信息对您有所帮助！如果您有任何其他问题，请随时提问。



**2.前端内容在Ngnix中的部署（了解）**

是的，您可以使用 Nginx 来部署前端内容。Nginx 不仅仅是一个反向代理服务器，它也可以用作静态文件服务器，适用于部署和提供前端应用程序所需的静态资源。

以下是一个简单的示例配置，用于将前端内容部署在 Nginx 上：

1. 首先，将前端应用程序的静态资源（HTML、CSS、JavaScript 文件等）放置在 Nginx 的指定目录下。例如，可以将静态资源放在 `/var/www/html` 目录中。

2. 打开 Nginx 的配置文件，一般位于 `/etc/nginx/nginx.conf` 或 `/etc/nginx/conf.d/default.conf`。

3. 在配置文件中找到 `server` 块，并添加以下配置指令：

   ```
   复制代码server {
       listen 80;
       server_name example.com;  # 将 example.com 替换为您的域名或 IP 地址
   
       root /var/www/html;  # 将 /var/www/html 替换为您存放前端静态资源的实际目录
   
       location / {
           try_files $uri $uri/ =404;
       }
   }
   ```

   - `listen 80;` 指定 Nginx 监听的端口号，这里使用默认的 HTTP 端口 80。
   - `server_name example.com;` 指定您的域名或者 IP 地址，用于与客户端进行通信。
   - `root /var/www/html;` 指定前端静态资源的根目录。
   - `location /` 配置了默认路由，用于处理对根路径的请求。

4. 保存并关闭配置文件。

5. 重新加载 Nginx 配置，使其生效。可以使用以下命令：

   ```
   复制代码sudo service nginx reload
   ```

现在，您的前端内容应该已经成功部署在 Nginx 上了。通过访问您的域名或 IP 地址，加上 Nginx 监听的端口号（默认为 80），即可在浏览器中访问您的前端应用程序。

需要注意的是，这只是一个简单的示例配置，具体的配置可能会因您的实际需求和应用程序而有所不同。您可以根据您的情况进行适当的配置和调整。

希望这些信息对您有所帮助！如果您有任何其他问题，请随时提问。





**3.Nginx配置文件中**