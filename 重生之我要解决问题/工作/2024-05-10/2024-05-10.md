# 2024-05-10

## 一、关于使用依赖注入（DI）的方式实现对冗余代码的解耦

### 1.1、优化前代码

```java
@GetMapping("/test")
public void test(@RequestParam("params") String params){
    if("1".equals(params)){
        // 逻辑代码
    }

    if("2".equals(params)){
        // 逻辑代码
    }

    if("3".equals(params)){
        // 逻辑代码
    }
}
```

### 1.2、优化后代码

接口

```java
public interface CAL {
    public void solve(String params);
}
```

实现类1

```java
@Service
public class CAL1 implements CAL {
    public void solve(String params){
        if("1".equals(params)){
            System.out.println("1的处理逻辑");
        }
    }

}
```

实现类2

```java
@Service
public class CAL2 implements CAL{
    public void solve(String params){
        if("2".equals(params)){
            System.out.println("2的处理逻辑");
        }
    }
}

```

实现类3

```java
@Service
public class CAL3 implements CAL {
void solve(String params){
        if("3".equals(params)){
            System.out.println("3的处理逻辑");
        }
    }
}

```

控制层

```java
@Autowired
// 或 @Resource 也可，这里是根据类型注入，
List<CAL> calList;

@GetMapping("/test")
public void test(@RequestParam("params") String params){
    for (CAL cal : calList) {
        cal.solve(params);
    }
}
```





### 二、关于@Autowired和@Resource

### 2.1、参考文章

- https://blog.csdn.net/Weixiaohuai/article/details/120853683
- https://juejin.cn/post/7022507865701089317



## 三、stream语句执行过程分析

### 3.1、代码语句

```java
ret= userWard.stream().filter(r -> r.getWardName().contains(name))
                .sorted(Comparator.comparing(WardInfoVo::getWardName))
                .map(r -> new WardInfoVo(r)).collect(Collectors.toList());
```

### 3.2、分析

在Java 8中，Stream是惰性求值的，即只有在终止操作（如forEach、count、sum等）被调用时才会执行中间操作（如filter、map、reduce等）来产生结果。

当运行到collect，开始执行中间操作filter、sorted、map这些中间操作，虽然 `filter`、`sorted` 和 `map` 是作为中间操作被定义在 Stream 管道中的，但它们并不会导致 Stream 遍历数组（或集合）三次。相反，这些操作是组合成一个高效的流水线的，并且在 `.collect()` 这个终端操作被调用时，整个流水线会一次性地遍历数据源（例如 `userWard` 集合），首先遍历 `userWard` 集合中的每个元素，对每个元素应用 `filter` 操作进行过滤，然后保留通过过滤的元素，接着对这些元素应用 `sorted` 操作进行排序，最后应用 `map` 操作进行转换。

执行顺序如下所示：

- `userWard.stream()` 创建一个 Stream 对象，它表示 `userWard` 集合的元素序列。
- `filter(r -> r.getWardName().contains(name))` 定义一个过滤操作，但此时并不会执行
- `orted(Comparator.comparing(WardInfoVo::getWardName))` 定义一个排序操作，同样此时不会执行
- `.map(r -> new WardInfoVo(r))`定义一个映射操作，将userWard中的内容转化为WardInfoVo
- `.collect(Collectors.toList())` 是一个终端操作，它触发 Stream 管道的执行。此时，Stream 开始从 `userWard` 集合中拉取数据，依次执行 `filter`、`sorted` 和 `map` 操作。
- 最后，`collect` 操作将处理后的元素收集到一个新的列表中，并赋值给 `ret` 变量



## 四、stream流异常问题

### 4.1、代码

```java
@Override
public List<WardInfoVo> getScreenWard(String name) {
    // 声明出参
    List<WardInfoVo> ret = new ArrayList<>();

    // 获取当前登录用户授权病区信息
    List<WardInfo> userWard = getUserWard();

    // 根据条件筛选 & 排序
    Stream<WardInfo> stream = userWard.stream();
    if (StrUtil.isNotBlank(name)) {
        stream.filter(r -> r.getWardName().contains(name));
    }
    ret = stream.map(r -> new WardInfoVo(r))
                .sorted(Comparator.comparing(WardInfoVo::getWardName))
                .collect(Collectors.toList());
    return ret;
}
```

报错信息提示了 `java.lang.IllegalStateException: stream has already been operated upon or closed`，这意味着在流（Stream）上已经进行了操作或关闭，导致无法再次操作。

这是因为在代码中，在应用筛选条件后，没有将结果重新赋值给原始的 `stream` 变量，而是直接在原始的 `stream` 上进行了 `map` 和 `sorted` 操作，这样会导致流被多次操作，从而产生异常。

要解决这个问题，你可以在应用筛选条件后将结果重新赋值给 `stream` 变量，如下所示：

通过这种方式，保证了流（Stream）只被操作一次，避免了异常的发生。



详细分析：

当您调用 `stream.filter(r -> r.getWardName().contains(name));` 时，您实际上是在定义一个过滤操作，但并没有立即执行它。这个过滤操作被添加到了 Stream 的操作链中，等待终端操作触发时才真正开始处理元素。

但是，这里有一个关键的概念：一旦您开始定义 Stream 操作（无论是 `filter`、`map`、`sorted` 还是其他任何中间操作），您就不能再“重复使用”原始的 Stream。这是因为 Stream 是不允许被多次消费的。当您调用一个中间操作（如 `filter`）时，您其实是在创建一个新的 Stream，它包含了前一个 Stream 的元素以及新定义的操作。但是，原始的 Stream 对象本身并没有被改变或“消费”。

然而，重要的是要记住，您需要将这个新创建的 Stream（即包含过滤操作的那个 Stream）引用保存起来，以便后续可以调用终端操作。在您提供的原始代码片段中，您没有保存这个新创建的 Stream，而是继续使用了原始的 `stream` 变量，而这个变量所引用的 Stream 并没有包含过滤操作。因此，当您调用 `stream.map(...)` 时，您实际上是在尝试在一个不包含过滤操作的 Stream 上执行操作，这并不会导致错误，但也不会按您期望的方式工作（即先过滤再映射）。

通过将过滤后的 Stream 赋值回给 `stream` 变量，您确保了后续的操作（如 `map` 和 `sorted`）是在一个已经包含过滤操作的 Stream 上执行的。这是为什么在修复后的代码中，您需要将过滤后的 Stream 重新赋值给 `stream` 变量的原因。