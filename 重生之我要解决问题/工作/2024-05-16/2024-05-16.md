# 2024-05-16

## 一、java.util.concurrent.RejectedExecutionException异常

### 1.1、实际开发中异常抛出

```
2024-05-16 09:04:07.768 ERROR 14368 --- [  XNIO-1 task-1] c.p.p.c.s.h.GlobalBizExceptionHandler    : 全局异常信息 ex=Task java.util.concurrent.FutureTask@5deddac9 rejected from java.util.concurrent.ThreadPoolExecutor@30119ed6[Terminated, pool size = 0, active threads = 0, queued tasks = 0, completed tasks = 0]

java.util.concurrent.RejectedExecutionException: Task java.util.concurrent.FutureTask@5deddac9 rejected from java.util.concurrent.ThreadPoolExecutor@30119ed6[Terminated, pool size = 0, active threads = 0, queued tasks = 0, completed tasks = 0]
	at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2047) ~[na:1.8.0_91]
	at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:823) ~[na:1.8.0_91]
	at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1369) ~[na:1.8.0_91]
	at java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:112) ~[na:1.8.0_91]
	at com.hscloud.wardPatient.service.impl.BedWardServiceImpl.getBedList(BedWardServiceImpl.java:106) ~[classes/:na]
	at com.hscloud.wardPatient.controller.BedWardController.getBedList(BedWardController.java:38) ~[classes/:na]
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_91]
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_91]
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_91]
	at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_91]
	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:205) ~[spring-web-5.3.26.jar:5.3.26]
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:150) ~[spring-web-5.3.26.jar:5.3.26]
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:117) ~[spring-webmvc-5.3.26.jar:5.3.26]
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:895) ~[spring-webmvc-5.3.26.jar:5.3.26]
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:808) ~[spring-webmvc-5.3.26.jar:5.3.26]
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87) ~[spring-webmvc-5.3.26.jar:5.3.26]
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1072) ~[spring-webmvc-5.3.26.jar:5.3.26]
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:965) ~[spring-webmvc-5.3.26.jar:5.3.26]
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) [spring-webmvc-5.3.26.jar:5.3.26]
	at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:909) [spring-webmvc-5.3.26.jar:5.3.26]
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:517) [jakarta.servlet-api-4.0.4.jar:4.0.4]
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) [spring-webmvc-5.3.26.jar:5.3.26]
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:584) [jakarta.servlet-api-4.0.4.jar:4.0.4]
	at io.undertow.servlet.handlers.ServletHandler.handleRequest(ServletHandler.java:74) [undertow-servlet-2.2.23.Final.jar:2.2.23.Final]
	at io.undertow.servlet.handlers.FilterHandler$FilterChainImpl.doFilter(FilterHandler.java:129) [undertow-servlet-2.2.23.Final.jar:2.2.23.Final]
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:337) [spring-security-web-5.7.7.jar:5.7.7]
	at org.springframework.security.web.access.intercept.AuthorizationFilter.doFilter(AuthorizationFilter.java:96) [spring-security-web-5.7.7.jar:5.7.7]
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:346) [spring-security-web-5.7.7.jar:5.7.7]
	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:122) [spring-security-web-5.7.7.jar:5.7.7]
	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:116) [spring-security-web-5.7.7.jar:5.7.7]
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:346) [spring-security-web-5.7.7.jar:5.7.7]
	at org.springframework.security.web.session.SessionManagementFilter.doFilter(SessionManagementFilter.java:126) [spring-security-web-5.7.7.jar:5.7.7]
	at org.springframework.security.web.session.SessionManagementFilter.doFilter(SessionManagementFilter.java:81) [spring-security-web-5.7.7.jar:5.7.7]
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:346) [spring-security-web-5.7.7.jar:5.7.7]
	at org.springframework.security.web.authentication.AnonymousAuthenticationFil
```

相关代码：

```
@Override
    public BedListVo getBedList(BedListDto bedListDto) {

        // 声明出参
        BedListVo bedListVo = new BedListVo();

        // 获取当前登录用户的信息
        PigxUser user = SecurityUtils.getUser();
        log.info("当前登录用户信息:{}", user);

        // 断言判断各个必须值是否存在
        CustomAssert.notNull(user, "当前登录用户信息不存在");
        CustomAssert.notNull(user.getId(), "当前登录用户的id信息不存在");
        Long userId = user.getId();
        CustomAssert.notNull(user.getJobNumber(), "当前登录用户的工号信息不存在");
        String jobNumber = user.getJobNumber();

        // 获取当前登录用户关联的病区信息
        UserWardPageVo userWardRel = userWardService.getUserWardRel(userId, jobNumber);
        // TODO 默认根据入参来获取需要查询的病区即可

        // 这里去查当前用户的所有科室
        // 去重 -> 统一放入WardInfo类中
        /*List<HisUserWardVo> hisUserWardList = userWardRel.getHisUserWardList();
        List<UserWardVo> userWardList = userWardRel.getUserWardList();

        // 合并当前用户的所有病区信息
        List<WardInfo> wardInfos = Stream.concat(
                userWardList.stream().map(r -> {
                    WardInfo wardInfo = new WardInfo();
                    BeanUtils.copyProperties(r, wardInfo);
                    return wardInfo;
                }),
                hisUserWardList.stream().map(r -> {
                    WardInfo wardInfo = new WardInfo();
                    BeanUtils.copyProperties(r, wardInfo);
                    return wardInfo;
                })
        ).distinct().collect(Collectors.toList());*/

        // todo 获取各个病区以及各个科室的床位信息（异步并发调用，一次性调用可能会超中台获取数量xainzhi ）
        // 异步执行结果集
        List<Future> futures = new ArrayList<>();
        ChuangWeiInfoResp chuangWeiInfoResp = new ChuangWeiInfoResp();

        for (String wardInfoId : bedListDto.getWardInfos()) {
            futures.add(threadPoolExecutor.submit(() -> {
                chuangWeiInfoResp.getList().addAll(getBedInfoByWardId(wardInfoId).getList());
            }));
        }

        threadPoolExecutor.shutdown();

        try{
            threadPoolExecutor.awaitTermination(5, TimeUnit.MINUTES);
            // 查看运行结果（过程中有异常 直接抛出）
            for(Future future : futures){
                future.get();
            }
        }catch (Exception ex) {
            log.error("异步调用根据病区id获取his床位信息发生异常");
            throw new BizException("异步调用根据病区id获取his床位信息发生异常");
        }

        // 统计各个病区/可数的床位数

        // 预处理各个病区的病床数
        // key: 病区id  value: 病区床位数量
        Map<String, BedListVo.BedInfo> wardBedInfoMap = new HashMap<>();
        this.initWardBedRel(chuangWeiInfoResp, wardBedInfoMap);





        // todo test打印查询his库获取的病床信息
        System.out.println(chuangWeiInfoResp);



        // todo 计算总览数量


        // todo 各个病区 今日明日待出院的数量 以及 总 今日待入院、今日出院、明日出院数量的统计



        return bedListVo;
    }
```

### 1.2、问题

https://blog.csdn.net/FMC_WBL/article/details/135760816



### 1.3、处理

`CompletionService` 和 `CompletableFuture` 是 Java 并发编程中用于异步任务处理的两种不同的机制。

1. **功能不同：**
   - `CompletionService` 是一个接口，它提供了一种方式来异步执行多个任务，并获取它们的结果。它允许你将任务提交给 `Executor` 执行，并使用 `take()` 方法以阻塞的方式获取已完成的任务的结果。
   - `CompletableFuture` 是一个类，它实现了 `Future` 接口和 `CompletionStage` 接口。它提供了更加灵活和强大的异步编程功能，可以通过各种方法链式地组合和处理异步任务的结果。
2. **使用方式不同：**
   - `CompletionService` 需要手动将任务提交给 `Executor`，并使用 `take()` 方法获取已完成的任务的结果。它适用于需要并发执行多个任务，但不需要复杂的异步操作。
   - `CompletableFuture` 可以通过 `supplyAsync()` 或 `runAsync()` 方法直接提交异步任务，并使用一系列方法链来处理任务的结果。它支持更复杂的异步操作，例如任务组合、异常处理、任务超时等。
3. **灵活性不同：**
   - `CompletionService` 提供了一种较低级别的抽象，它主要关注在异步任务执行完成后如何获取结果。它的功能相对较简单，适用于简单的并发任务处理场景。
   - `CompletableFuture` 提供了更高级别的抽象，它内置了丰富的方法和操作符，用于处理异步任务的结果。它具有更大的灵活性和扩展性，可以实现更复杂的异步编程需求。

综上所述，如果只是需要简单地并发执行多个任务并获取它们的结果，可以选择使用 `CompletionService`。而如果需要更强大、灵活和复杂的异步编程功能，可以选择使用 `CompletableFuture`。



方式一：

```java
 CompletionService completionService = new ExecutorCompletionService(threadPoolExecutor);

ChuangWeiInfoResp chuangWeiInfoResp = new ChuangWeiInfoResp();
for (String wardInfoId : bedListDto.getWardInfos()) {
    completionService.submit(() -> {
        chuangWeiInfoResp.getList().addAll(getBedInfoByWardId(wardInfoId).getList());
        return null;
    });
}

int tasks = bedListDto.getWardInfos().size();
try {
    for (int i = 0; i < tasks; i++) {
        completionService.take().get(); // 取出一个完成的任务并获取结果 阻塞没一个未完成的任务
    }
} catch (InterruptedException | ExecutionException e) {
    Thread.currentThread().interrupt(); // 重新设置中断状态
    log.error("等待任务执行完成时发生异常", e);
    throw new RuntimeException("等待任务执行完成时发生异常", e);
}
```



方式二：

```java
 List<CompletableFuture> futures = new ArrayList<>();
        ChuangWeiInfoResp chuangWeiInfoResp = new ChuangWeiInfoResp();

        for (String wardInfoId : bedListDto.getWardInfos()) {
            CompletableFuture future = CompletableFuture.supplyAsync(() -> {
                chuangWeiInfoResp.getList().addAll(getBedInfoByWardId(wardInfoId).getList());
                int i = 1 / 0;
                return null;
            }, threadPoolExecutor).thenAccept( res -> {
                // 异步完成后的结果
            }).exceptionally( ex -> {
                // 异步异常的处理
                log.error("异步调用根据病区id获取his床位信息发生异常", ex);
                throw new BizException("异步调用根据病区id获取his床位信息发生异常");
            });
            futures.add(future);
        }

        // 等待所有异步任务执行完成
        try{
            CompletableFuture[] completableFutures = futures.toArray(new CompletableFuture[0]);
            CompletableFuture.allOf(completableFutures).join();
        } catch (Exception ex) {
            log.error("异步调用根据病区id获取his床位信息发生异常", ex);
            throw new BizException("异步调用根据病区id获取his床位信息发生异常");
        }
```



方法二扩展信息：

1、是的，`exceptionally` 方法可以用于捕获异步任务线程执行时抛出的异常，进行异常处理。

在示例代码中，`CompletableFuture.supplyAsync(...)` 方法会创建一个新的 `CompletableFuture` 对象，并在另一个线程中执行异步任务。该方法返回的 `CompletableFuture` 对象可以通过调用 `thenAccept` 方法或者 `exceptionally` 方法来注册回调函数，分别用于处理异步任务正常完成时的结果和异步任务发生异常时的情况。

在这个示例中，`supplyAsync` 方法内部的异步任务执行了两个操作。第一行代码通过 `getBedInfoByWardId(wardInfoId).getList()` 方法获取某个病区的床位信息，并将其添加到 `chuangWeiInfoResp` 对象中。第二行代码故意抛出一个除以 0 的异常，用于演示异常处理的过程。

在 `supplyAsync` 方法外部，我们使用 `exceptionally` 方法来处理异步任务抛出的异常。在这个方法中，我们记录了日志，然后抛出了一个自定义的业务异常。如果任何一个异步任务抛出了异常，主线程都会在 `join` 方法处等待所有异步任务执行完成后继续执行后续代码。在这个示例中，如果任何一个异步任务抛出了异常，主线程会抛出一个 `BizException` 异常，以提示调用者发生了错误。

需要注意的是，`exceptionally` 方法返回的是一个新的 `CompletableFuture` 对象，该对象的结果是异步任务的异常处理结果。因此，如果你希望在主线程中感知到异步任务的异常情况，应该将所有 `CompletableFuture` 对象添加到一个集合中，并在主线程中使用 `CompletableFuture.allOf(...)` 方法等待所有异步任务执行完成。这样，如果任何一个异步任务出现异常，`allOf` 方法也会抛出一个 `CompletionException` 异常，其中包含了所有异步任务的异常信息。



2、`futures.toArray(new CompletableFuture[0])` 是将一个 `List` 转换为一个 `CompletableFuture` 数组的常用写法。

具体来说，它的作用是将一个 `List<CompletableFuture<Void>>` 转换为一个 `CompletableFuture<Void>[]` 数组。这个数组可以作为参数传递给 `CompletableFuture.allOf(...)` 方法，用于等待所有异步任务执行完成。

在 Java 中，数组是一个固定长度的数据结构，一旦创建，其长度就不可变。因此我们需要事先知道数组的长度才能创建一个数组。但是在实际使用中，我们经常需要将一个不定长度的集合转换为一个数组，而集合的长度是不确定的。为了解决这个问题，Java 提供了一个简便的写法：

```
javaCopy CodeCompletableFuture[] array = list.toArray(new CompletableFuture[0]);
```

这个写法的原理是，`new CompletableFuture[0]` 创建了一个长度为 0 的 `CompletableFuture` 数组，然后将其强制转换为 `CompletableFuture[]` 类型。由于 Java 中的数组是协变的，即如果 T 是 S 的子类型，则 T[] 是 S[] 的子类型，因此这个空数组也可以被看作是一个 `CompletableFuture[]` 类型的数组。

然后我们将这个空数组作为参数传递给 `List.toArray(T[] a)` 方法，这个方法会根据集合的长度动态创建一个新的 `CompletableFuture` 数组，并将集合中的元素复制到这个数组中。由于数组的长度与集合的长度相同，因此我们得到了一个正确大小的 `CompletableFuture` 数组。

这种写法的优点是代码简洁，且不需要事先知道集合的长度。缺点是可能会创建一个额外的空数组，但这个代价通常是可以接受的





## 二、关于BigDecimla的计算调用

```java
BigDecimal useRate = BigDecimal.valueOf(wardBedInfo.getTotalBedNum());
useRate = useRate.subtract(BigDecimal.valueOf(wardBedInfo.getEmptyBedNum()));
useRate = useRate.divide(BigDecimal.valueOf(wardBedInfo.getTotalBedNum()));
wardBedInfo.setUseRate(useRate);
```

上述的计算可以进行链式调用，如下所示

```java
 BigDecimal useRateSum = BigDecimal.valueOf(bedInfoSum.getTotalBedNum())
                    .subtract(BigDecimal.valueOf(bedInfoSum.getEmptyBedNum()))
                    .divide(BigDecimal.valueOf(bedInfoSum.getTotalBedNum()));
```

在进行除法的时候，抛出异常

```
Non-terminating decimal expansion; no exact representable decimal result.
```

可以使用如下文章：

https://blog.csdn.net/weixin_45692705/article/details/124091531

最终：

```
 BigDecimal useRateSum = BigDecimal.valueOf(bedInfoSum.getTotalBedNum())
                    .subtract(BigDecimal.valueOf(bedInfoSum.getEmptyBedNum()))
                    .divide(BigDecimal.valueOf(bedInfoSum.getTotalBedNum()), 3, RoundingMode.HALF_UP);
```



## 三、大表数量X，小标的数量M，不管左连 还是 右连 不都要是比较X*M吗

你提出了一个很好的观点。确实，在连接操作中，无论是左连接还是右连接，都需要对大表中的每一行记录与小表中的每一行记录进行比较，因此总的比较次数确实是大表记录数乘以小表记录数，即 X * M。

但是，虽然比较次数是相同的，但在实际执行过程中，小表连接会更高效，原因如下：

1. **内存占用**：小表的数据量相对较少，因此可以更轻松地将小表的数据加载到内存中进行处理，而大表可能需要更多的内存或者磁盘空间进行处理。
2. **索引使用**：如果在连接条件字段上存在索引，数据库管理系统可能会更有效地利用索引来加速小表的连接操作，从而减少比较的次数和时间。
3. **缓存效果**：在一些情况下，小表的数据可能已经被缓存到内存中，而大表则可能不太可能完全被缓存。这意味着对小表的查询可能更快，因为它们可以从内存中直接访问，而不必经过磁盘 IO 操作。

综上所述，虽然在理论上比较次数是相同的，但在实际情况下，小表连接通常更高效，因为它们更容易被加载到内存中，并且更有可能利用索引和缓存。