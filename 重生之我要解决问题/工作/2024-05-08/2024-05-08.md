# 2024-05-08

## 一、多线程下子线程的异常无法被主线程捕捉

### 1.1、示例代码：

这里通过Executors工具类创建了一个线程池，通过submit方法提交线程任务，并且在子线程中添加try-catch，对异常进行一个处理，并且抛出一个自定义异常。但是在实际运行中，子线程中出现异常，并抛出一个自定义异常后，主线程是无法感知的，在通过` executorService.awaitTermination(5, TimeUnit.MINUTES);`等待线程结束后，会继续往下运行。

```java
@Override
public List<UserWardPageVo> getHisUserWard(String jobNumbers) {
    // 声明相应参数
    List<UserWardPageVo> ret = new ArrayList<>();

    // todo 抽取出来，设置为动态可配置
    // 创建一个固定大小的线程池
    ExecutorService executorService = Executors.newFixedThreadPool(10);

    // jobNumbers为空直接返回ret
    if(StrUtil.isBlank(jobNumbers)){
        return ret;
    }

    // 将jobNumbers转化为以逗号分隔的
    List<String> jobNumberList = Arrays.asList(jobNumbers.split(","));

    redisTemplate.opsForValue().set("test1232", "123", 2L, TimeUnit.HOURS);

    // 异步调用获取his职工授权的病区
    for (String jobNumber : jobNumberList) {
        executorService.submit(() -> {
            log.info("== 开始异步调用获取his职工授权的病区 ==");
            log.info("当前获取职工工号:{}", jobNumber);
            UserWardPageVo userWardPageVo = new UserWardPageVo();
            userWardPageVo.setJobNumber(jobNumber);
            Map<String, Object> paramMap = new HashMap<>();
            paramMap.put("EMP_ID", jobNumber);
            BaseResponse<HisUserWardVo> apiData = dataCenterService
                    .getApiData(HIS_USER_WARD_REL, paramMap,
                            ydcfProperties.getUrl(),
                            ydcfProperties.getAppkey(),
                            ydcfProperties.getAppsecret(),
                            HisUserWardVo.class, true);
            log.info("获取his职工授权病区信息:{}", apiData);
            List<HisUserWardVo> data = apiData.getData();
            userWardPageVo.setHisUserWardList(data);
            ret.add(userWardPageVo);

            // 将实时同步的数据更新缓存
            //redisUtils.setCacheObject("test", data, 2L, TimeUnit.HOURS);
            redisTemplate.opsForValue().set("test", data, 2L, TimeUnit.HOURS);
            log.info("== 异步调用获取his职工授权的病区结束 ==");
        });
    }

    // 关闭线程池，不再添加新的任务
    executorService.shutdown();

    try {
        // 等待所有任务完成，最多等待5分钟
        executorService.awaitTermination(5, TimeUnit.MINUTES);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }

    System .out.println(ret);

    return ret;
}
```







## 二、redis序列化失败

```
024-05-08 09:41:30.639 ERROR 26060 --- [  XNIO-1 task-1] c.p.p.c.s.h.GlobalBizExceptionHandler    : 全局异常信息 ex=Cannot serialize; nested exception is org.springframework.core.serializer.support.SerializationFailedException: Failed to serialize object using DefaultSerializer; nested exception is java.io.NotSerializableException: com.hscloud.wardPatient.api.model.vo.HisUserWardVo

org.springframework.data.redis.serializer.SerializationException: Cannot serialize; nested exception is org.springframework.core.serializer.support.SerializationFailedException: Failed to serialize object using DefaultSerializer; nested exception is java.io.NotSerializableException: com.hscloud.wardPatient.api.model.vo.HisUserWardVo
	at org.springframework.data.redis.serializer.JdkSerializationRedisSerializer.serialize(JdkSerializationRedisSerializer.java:96) ~[spring-data-redis-2.7.10.jar:2.7.10]
	at org.springframework.data.redis.core.AbstractOperations.rawValue(AbstractOperations.java:128) ~[spring-data-redis-2.7.10.jar:2.7.10]
	at org.springframework.data.redis.core.DefaultValueOperations.set(DefaultValueOperations.java:323) ~[spring-data-redis-2.7.10.jar:2.7.10]
	at com.hscloud.wardPatient.service.impl.UserWardService.getHisUserWard(UserWardService.java:221) ~[classes/:na]
	at com.hscloud.wardPatient.service.impl.UserWardService$$FastClassBySpringCGLIB$$ba6cee8f.invoke(<generated>) ~[classes/:na]
	at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218) ~[spring-core-5.3.26.jar:5.3.26]
	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:793) ~[spring-aop-5.3.26.jar:5.3.26]
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163) ~[spring-aop-5.3.26.jar:5.3.26]
	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:763) ~[spring-aop-5.3.26.jar:5.3.26]
	at org.springframework.transaction.interceptor.TransactionInterceptor$1.proceedWithInvocation(TransactionInterceptor.java:123) ~[spring-tx-5.3.26.jar:5.3.26]
	at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:388) ~[spring-tx-5.3.26.jar:5.3.26]
	at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:119) ~[spring-tx-5.3.26.jar:5.3.26]
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) ~[spring-aop-5.3.26.jar:5.3.26]
	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:763) ~[spring-aop-5.3.26.jar:5.3.26]
	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:708) ~[spring-aop-5.3.26.jar:5.3.26]
	at com.hscloud.wardPatient.service.impl.UserWardService$$EnhancerBySpringCGLIB$$8891c912.getHisUserWard(<generated>) ~[classes/:na]
	at com.hscloud.wardPatient.controller.UserWardController.getHisUserWard(UserWardController.java:80) ~[classes/:na]
	at com.hscloud.wardPatient.controller.UserWardController$$FastClassBySpringCGLIB$$a199093f.invoke(<generated>) ~[classes/:na]
	at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218) ~[spring-core-5.3.26.jar:5.3.26]
	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:793) ~[spring-aop-5.3.26.jar:5.3.26]
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163) ~[spring-aop-5.3.26.jar:5.3.26]
	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:763) ~[spring-aop-5.3.26.jar:5.3.26]
	at org.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint.proceed(MethodInvocationProceedingJoinPoint.java:89) ~[spring-aop-5.3.26.jar:5.3.26]
	at com.pig4cloud.pigx.common.log.aspect.SysLogAspect.around(SysLogAspect.java:82) ~[pigx-common-log-5.2.0.jar:na]
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_91]
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_91]
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_91]
	at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_91]
	at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethodWithGivenArgs(AbstractAspectJAdvice.java:634) ~[spring-aop-5.3.26.jar:5.3.26]
	at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethod(AbstractAspectJAdvice.java:624) ~[spring-aop-5.3.26.jar:5.3.26]
	at org.springframework.aop.aspectj.AspectJAroundAdvice.invoke(AspectJAroundAdvice.java:72) ~[spring-aop-5.3.26.jar:5.3.26]
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:175) ~[spring-aop-5.3.26.jar:5.3.26]
	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:763) ~[spring-aop-5.3.26.jar:5.3.26]
	at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:97) ~[spring-aop-5.3.26.jar:5.3.26]
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) ~[spring-aop-5.3.26.jar:5.3.26]
	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:763) ~[spring-aop-5.3.26.jar:5.3.26]
	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:708) ~[spring-aop-5.3.26.jar:5.3.26]
	at com.hscloud.wardPatient.controller.UserWardController$$EnhancerBySpringCGLIB$$16960ce9.getHisUserWard(<generated>) ~[classes/:na]
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_91]
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_91]
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_91]
	at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_91]
	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:205) ~[spring-web-5.3.26.jar:5.3.26]
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:150) ~[spring-web-5.3.26.jar:5.3.26]
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:117) ~[spring-webmvc-5.3.26.jar:5.3.26]
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:895) ~[spring-webmvc-5.3.26.jar:5.3.26]
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:808) ~[spring-webmvc-5.3.26.jar:5.3.26]
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87) ~[spring-webmvc-5.3.26.jar:5.3.26]
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1072) ~[spring-webmvc-5.3.26.jar:5.3.26]
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:965) ~[spring-webmvc-5.3.26.jar:5.3.26]
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) [spring-webmvc-5.3.26.jar:5.3.26]
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898) [spring-webmvc-5.3.26.jar:5.3.26]
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:497) [jakarta.servlet-api-4.0.4.jar:4.0.4]
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) [spring-webmvc-5.3.26.jar:5.3.26]
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:584) [jakarta.servlet-api-4.0.4.jar:4.0.4]
	at io.undertow.servlet.handlers.ServletHandler.handleRequest(ServletHandler.java:74) [undertow-servlet-2.2.23.Final.jar:2.2.23.Final]
	at io.undertow.servlet.handlers.FilterHandler$FilterChainImpl.doFilter(FilterHandler.java:129) [undertow-servlet-2.2.23.Final.jar:2.2.23.Final]
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:337) [spring-security-web-5.7.7.jar:5.7.7]
	at org.springframework.security.web.access.intercept.AuthorizationFilter.doFilter(AuthorizationFilter.java:96) [spring-security-web-5.7.7.jar:5.7.7]
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:346) [spring-security-web-5.7.7.jar:5.7.7]
	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:122) [spring-security-web-5.7.7.jar:5.7.7]
	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:116) [spring-security-web-5.7.7.jar:5.7.7]
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:346) [spring-security-web-5.7.7.jar:5.7.7]
	at org.springframework.security.web.session.SessionManagementFilter.doFilter(SessionManagementFilter.java:126) [spring-security-web-5.7.7.jar:5.7.7]
	at org.springframework.security.web.session.SessionManagementFilter.doFilter(SessionManagementFilter.java:81) [spring-security-web-5.7.7.jar:5.7.7]
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:346) [spring-security-web-5.7.7.jar:5.7.7]
	at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:109) [spring-security-web-5.7.7.jar:5.7.7]
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:346) [spring-security-web-5.7.7.jar:5.7.7]
	at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:149) [spring-security-web-5.7.7.jar:5.7.7]
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:346) [spring-security-web-5.7.7.jar:5.7.7]
	at org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:63) [spring-security-web-5.7.7.jar:5.7.7]
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:346) [spring-security-web-5.7.7.jar:5.7.7]
	at org.springframework.security.oauth2.server.resource.web.BearerTokenAuthenticationFilter.doFilterInternal(BearerTokenAuthenticationFilter.java:142) [spring-security-oauth2-resource-server-5.7.7.jar:5.7.7]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117) [spring-web-5.3.26.jar:5.3.26]
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:346) [spring-security-web-5.7.7.jar:5.7.7]
	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:103) [spring-security-web-5.7.7.jar:5.7.7]
	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:89) [spring-security-web-5.7.7.jar:5.7.7]
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:346) [spring-security-web-5.7.7.jar:5.7.7]
	at org.springframework.security.web.header.HeaderWriterFilter.doHeadersAfter(HeaderWriterFilter.java:90) [spring-security-web-5.7.7.jar:5.7.7]
	at org.springframework.security.web.header.HeaderWriterFilter.doFilterInternal(HeaderWriterFilter.java:75) [spring-security-web-5.7.7.jar:5.7.7]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117) [spring-web-5.3.26.jar:5.3.26]
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:346) [spring-security-web-5.7.7.jar:5.7.7]
	at org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:112) [spring-security-web-5.7.7.jar:5.7.7]
	at org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:82) [spring-security-web-5.7.7.jar:5.7.7]
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:346) [spring-security-web-5.7.7.jar:5.7.7]
	at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:55) [spring-security-web-5.7.7.jar:5.7.7]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117) [spring-web-5.3.26.jar:5.3.26]
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:346) [spring-security-web-5.7.7.jar:5.7.7]
	at org.springframework.security.web.session.DisableEncodeUrlFilter.doFilterInternal(DisableEncodeUrlFilter.java:42) [spring-security-web-5.7.7.jar:5.7.7]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117) [spring-web-5.3.26.jar:5.3.26]
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:346) [spring-security-web-5.7.7.jar:5.7.7]
	at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:221) [spring-security-web-5.7.7.jar:5.7.7]
```

解决

这个异常表明在尝试将对象序列化以存储到Redis中时出现了问题。具体来说，`HisUserWardVo` 类没有实现 `Serializable` 接口，因此无法通过默认的序列化器进行序列化。

解决这个问题的方法已经在之前的回答中提到了两种：

1. **让对象实现Serializable接口：** 最简单的解决方案是让 `HisUserWardVo` 类实现 `Serializable` 接口。你可以在类声明中添加 `implements Serializable`，并确保类中的所有成员变量也是可序列化的。

```
javaCopy Codepublic class HisUserWardVo implements Serializable {
    // 类定义
}
```

1. **配置RedisTemplate使用其他序列化方式：** 如果你无法修改 `HisUserWardVo` 类，或者希望使用其他的序列化方式，可以自定义配置`RedisTemplate`来指定其他的序列化器，如使用JSON序列化器。详细的配置方法已在之前的回答中提供了。





## 三、子线程异常如何让主线程捕捉到

在你的代码中，你已经使用了 try-catch 块来捕获异步调用过程中的异常，并记录了错误日志。但是要注意的是，由于异步调用是在子线程中执行的，异常是在子线程中被捕获的，所以你在子线程中捕获的异常不会传递到主线程。因此，你可以在子线程中捕获异常后，通过自定义的异常处理机制将异常信息传递到主线程中。





## 四、`CountDownLatch` 是 Java 中 `java.util.concurrent` 包

CountDownLatch

`CountDownLatch` 是 Java 中一个并发工具类，用于控制一个或多个线程等待其他线程完成操作。它通过一个计数器来实现，计数器的初始值由用户指定，每当一个线程完成了自己的任务后，计数器的值就会减一，当计数器的值变为零时，所有等待的线程就会被释放。

通常情况下，`CountDownLatch` 用于一组线程等待另一组线程执行完毕再继续执行，或者主线程等待多个子线程执行完毕后再继续执行。

`CountDownLatch` 的核心方法包括：

- `countDown()`：将计数器减一。每次一个线程完成了任务，都应该调用这个方法来减少计数器的值。
- `await()`：使当前线程等待，直到计数器的值变为零。如果计数器的值已经为零，那么该方法会立即返回，否则当前线程会一直等待，直到其他线程调用 `countDown()` 方法使计数器的值变为零。

下面是一个简单的示例，演示了 `CountDownLatch` 的基本用法：

```
javaCopy Codeimport java.util.concurrent.CountDownLatch;

public class Main {
    public static void main(String[] args) throws InterruptedException {
        int workerCount = 5;
        CountDownLatch latch = new CountDownLatch(workerCount);

        for (int i = 0; i < workerCount; i++) {
            Thread worker = new Thread(new Worker(latch));
            worker.start();
        }

        // 主线程等待所有工作线程执行完成
        latch.await();
        
        System.out.println("All workers have finished their tasks.");
    }
}

class Worker implements Runnable {
    private final CountDownLatch latch;

    public Worker(CountDownLatch latch) {
        this.latch = latch;
    }

    @Override
    public void run() {
        try {
            // 模拟工作
            Thread.sleep(1000);
            System.out.println("Worker has finished its task.");
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            // 任务完成，计数器减一
            latch.countDown();
        }
    }
}
```

在这个示例中，创建了一个 `CountDownLatch` 对象，并初始化计数器为5。然后创建了5个工作线程，每个线程执行完任务后调用 `countDown()` 方法减少计数器的值。主线程调用 `await()` 方法等待计数器的值变为零，即等待所有工作线程执行完毕后再继续执行。



`ExecutorService` 中的 `execute` 和 `submit` 是用来提交任务的方法，但它们的行为和返回值有一些重要的区别。

1. **execute(Runnable task)**:
   - `execute` 只接受 `Runnable` 类型的任务，不返回任何结果。
   - 使用 `execute` 提交的任务执行后，不提供任何方式获取任务的执行结果或异常。如果任务抛出异常，它会直接在执行线程中传播，但无法由调用者捕获。
2. **submit(Runnable task)**:
   - `submit` 也可以接受 `Runnable` 类型的任务，但它返回一个 `Future` 对象，代表这个任务的完成状态。
   - `submit` 方法返回的 `Future` 对象可以用来检查任务是否完成，并可以通过调用 `Future.get()` 方法阻塞直到任务完成。
   - 对于 `Runnable` 类型的任务，`submit` 方法返回的 `Future` 对象的 `get()` 方法将返回 `null`。
   - 如果任务抛出异常，可以通过 `Future.get()` 方法捕获该异常。
3. **submit(Callable task)**:
   - `submit` 也可以接受 `Callable` 类型的任务，返回一个 `Future` 对象，表示这个任务的执行结果。
   - `Callable` 是一种可以返回结果的任务，因此 `Future.get()` 可以返回 `Callable` 执行的结果。
   - 如果任务抛出异常，异常将被包装在 `ExecutionException` 中，当你调用 `Future.get()` 时抛出。

下面是一个简单的例子，展示了两者的不同之处：

```
javaCopy Codeimport java.util.concurrent.*;

public class Example {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newSingleThreadExecutor();

        // 使用 execute 提交任务
        executor.execute(() -> {
            System.out.println("Task executed via execute");
        });

        // 使用 submit 提交 Runnable 任务
        Future<?> futureRunnable = executor.submit(() -> {
            System.out.println("Task executed via submit (Runnable)");
        });

        // 使用 submit 提交 Callable 任务
        Future<Integer> futureCallable = executor.submit(() -> {
            System.out.println("Task executed via submit (Callable)");
            return 42; // 返回一个结果
        });

        try {
            futureRunnable.get(); // 阻塞等待任务完成
            System.out.println("Runnable task completed");

            Integer result = futureCallable.get(); // 阻塞等待任务完成并获取结果
            System.out.println("Callable task completed with result: " + result);
        } catch (InterruptedException | ExecutionException e) {
            e.printStackTrace();
        }

        executor.shutdown();
    }
}
```

在这个示例中，展示了 `execute` 和 `submit` 两种提交任务的方式，以及如何使用 `Future` 来等待和获取结果。