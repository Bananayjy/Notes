# 2024-04-08问题整理

## 一、关于MYSQL死锁问题

### 1.1 源由

一次上线过程中，遇到了MySQL死锁的问题……

### 1.2 分析

#### 1.2.1 前置知识

​		首先要知道，MySQL是一个多线程的数据库管理系统，查询是通常并发执行的，可以同时处理多个查询请求，并且MySQL中的更新、删除等操作也可以并发执行，需要注意的是，并发执行更新和删除操作可能会引起数据不一致或意外的结果，特别是在涉及到相同数据的同时修改时。为了避免这种情况，MySQL提供了事务和锁机制来确保数据的一致性和完整性。

#### 1.2.2 解决死锁问题相关命令汇总

##### 1、show processlist; 

**参考文章**

十分感谢如下文章提供的帮助

> https://blog.csdn.net/WUFUSHANLI/article/details/124399079

**说明**

SHOW PROCESSLIST是 MySQL 中用于显示当前正在运行的线程（也称为进程）的命令。这些线程可能包括查询、事务、复制线程等。使用 SHOW PROCESSLIST 可以查看当前 MySQL 服务器上正在执行的活动，以及它们的状态、执行时间等信息。

**结果说明**

| 字段名称 |                             说明                             |
| :------: | :----------------------------------------------------------: |
|    Id    | 线程的唯一标识符(即系统分配的"connection_id"，可以使用函数connection_id()查看：select connection_id()) |
|   User   | 连接 MySQL 服务器的用户名，可通过select user()查看当前连接到 MySQL 服务器的用户名(补充：如果需要查看当前所有连接到 MySQL 服务器的用户信息，可以使用SELECT User FROM information_schema.processlist命令) |
|   Host   | 连接 MySQL 服务器的主机名（详细到ip和端口，可用于跟踪出对应的用户） |
|    db    | 线程正在操作/连接的数据库。如果是 NULL，则表示没有指定数据库 |
| Command  |                    线程正在执行的命令类型                    |
|   Time   |                  线程执行的时间，以秒为单位                  |
|  State   |           线程的当前状态，是参考sql状态的重要依据            |
|   Info   |               正在执行的 SQL 查询或操作的信息                |

相关参数详细说明（可在遇到时自行查阅相关资料，这里只是做一个搬运，如有错误，欢迎纠正）：

（1）Command中常见命令及其含义说明

- Query：正在执行一个 SQL 查询
- Sleep：现成正在等待客户端请求
- Connect：线程正在建立一个新的连接
- Killed：线程已被终止
- Quit：线程正在关闭连接
- Daemon：通常表示该线程是一个后台守护进程，负责处理一些后台任务，而不是响应客户端的请求

（2）State中常见命令及其含义说明

- Checking table

正在执行表的检查操作（自动执行）

一般在索引重建、事务回滚、数据恢复、内部维护任务、其他管理操作会执行表的检查工作，这些操作通常是为了确保数据的完整性、一致性和可用性。

- Closing tables

表示 MySQL 正在处理结束的操作，将表中修改的数据刷新到磁盘中，关闭已经打开的表，以便释放资源并维护数据库的一致性。

- Connect Out

表示服务器正在尝试与其他 MySQL 服务器建立连接

- Copying to tmp table on disk

由于临时结果集大于 tmp_table_size，正在将临时表从内存存储转为磁盘存储以此节省内存

- Creating tmp table

正在创建临时表以存放部分查询结果。

- deleting from main table
- deleting from reference tables

服务器正在执行多表删除中的第二部分，正在删除其他表的记录。

- Flushing tables

正在执行 FLUSH TABLES，等待其他线程关闭数据表。

- Killed

发送了一个kill请求给某线程，那么这个线程将会检查kill标志位，同时会放弃下一个kill请求。MySQL会在每次的主循环中检查kill标志位，不过有些情况下该线程可能会过一小段才能死掉。如果该线程程被其他线程锁住了，那么kill请求会在锁释放时马上生效。

- Locked

被其他查询锁住了

- Sending data

正在处理 SELECT 查询的记录，同时正在把结果发送给客户端。

- Sorting for group

正在为 GROUP BY 做排序

- Sorting for order

正在为 ORDER BY 做排序

- Opening tables

这个过程应该会很快，除非受到其他因素的干扰。例如，在执 ALTER TABLE 或 LOCK TABLE 语句行完以前，数据表无法被其他线程打开。 正尝试打开一个表。

- Removing duplicates

正在执行一个 SELECT DISTINCT 方式的查询，但是MySQL无法在前一个阶段优化掉那些重复的记录。因此，MySQL需要再次去掉重复的记录，然后再把结果发送给客户端。

- Reopen table

获得了对一个表的锁，但是必须在表结构修改之后才能获得这个锁。已经释放锁，关闭数据表，正尝试重新打开数据表。

- Repair by sorting

修复指令正在排序以创建索引

- Repair with keycache

修复指令正在利用索引缓存一个一个地创建新索引。它会比 Repair by sorting 慢些

- Searching rows for update

正在讲符合条件的记录找出来以备更新。它必须在 UPDATE 要修改相关的记录之前就完成了

- Sleeping

正在等待客户端发送新请求.

- System lock

正在等待取得一个外部的系统锁。如果当前没有运行多个 mysqld 服务器同时请求同一个表，那么可以通过增加 –skip-external-locking参数来禁止外部系统锁

- Upgrading lock

INSERT DELAYED 正在尝试取得一个锁表以插入新记录

- Updating

正在搜索匹配的记录，并且修改它们

- User Lock

正在等待 GET_LOCK()

- Waiting for tables

该线程得到通知，数据表结构已经被修改了，需要重新打开数据表以取得新的结构。然后，为了能的重新打开数据表，必须等到所有其他线程关闭这个表。以下几种情况下会产生这个通知：FLUSH TABLES tbl_name, ALTER TABLE, RENAME TABLE, REPAIR TABLE, ANALYZE TABLE, 或 OPTIMIZE TABLE

- waiting for handler insert

INSERT DELAYED 已经处理完了所有待处理的插入操作，正在等待新的请求

- Waiting for net, reading from net, writing to net

偶尔出现无妨

**具体示例**

![image-20240414131008569](2024-04-08%E9%97%AE%E9%A2%98.assets/image-20240414131008569.png)

通过show processlist执行可以看到此时MySQL中正有三个线程：

首先第一个线程是由事件调度器（event_scheduler）创建的，事件调度器是 MySQL 的一个功能，用于执行预定的任务或事件。当事件触发时，事件调度器会创建一个线程来执行该事件，例如定时清理数据库、备份数据等。

第二个线程是一个查询操作，其连接的数据库是tlias，命令正式此时我们在查询线程信息的show processlist。

第三个线程正处于一个睡眠状态，连接的数据库是ynw。



##### 2、查看锁的状态

```
SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCKS; 

SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS; 
```



##### 3、杀死对应的线程

```
kill 线程号
```

