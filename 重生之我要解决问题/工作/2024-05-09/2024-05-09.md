# 2024-05-09

## 一、集合修改异常

### 1.1、问题源码

```java
@Override
public UserWardPageVo getUserWardRel(Long userId, String jobNumber) {
    // 声明响应参数
    UserWardPageVo userWardPageVo = new UserWardPageVo();
    userWardPageVo.setUserId(userId);

    // his职工病区关联列表
    List<HisUserWardVo> hisUserWardList = userWardPageVo.getHisUserWardList();
    // 职工病区关联列表
    List<UserWardVo> userWardList = userWardPageVo.getUserWardList();

    // 条件构造器
    LambdaQueryWrapper<UserWard> wrapper = Wrappers.<UserWard>lambdaQuery();
    wrapper.eq(UserWard::getUserId, userId);

    // 设置职工病区关联列表
    List<UserWard> userWards = baseMapper.selectList(wrapper);
    userWards.stream().forEach(r -> {
        UserWardVo userWardVo = new UserWardVo();
        BeanUtils.copyProperties(r, userWardVo);
        userWardList.add(userWardVo);
    });

    // 设置his职工病区关联列表
    UserWardPageVo userWardByJobNumber = this.getHisUserWardByJobNumber(jobNumber);
    hisUserWardList = userWardByJobNumber.getHisUserWardList();
    for (HisUserWardVo hisUserWardVo : userWardByJobNumber.getHisUserWardList()) {
        hisUserWardList.add(hisUserWardVo);
    }

    return userWardPageVo;
}
```

日志：

```txt
java.util.ConcurrentModificationException: null
	at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:901) ~[na:1.8.0_91]
	at java.util.ArrayList$Itr.next(ArrayList.java:851) ~[na:1.8.0_91]
	at com.hscloud.wardPatient.service.impl.UserWardServiceImpl.getUserWardRel(UserWardServiceImpl.java:269) ~[classes/:na]
	at com.hscloud.wardPatient.service.impl.UserWardServiceImpl$$FastClassBySpringCGLIB$$c647e54f.invoke(<generated>) ~[classes/:na]
	at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218) ~[spring-core-5.3.26.jar:5.3.26]
	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:793) ~[spring-aop-5.3.26.jar:5.3.26]
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163) ~[spring-aop-5.3.26.
```

### 1.2、分析

在对集合进行遍历的同时，对集合进行修改，又将数添加到集合中。

```java
for (HisUserWardVo hisUserWardVo : userWardByJobNumber.getHisUserWardList()) {
    hisUserWardList.add(hisUserWardVo);
}
```

`ConcurrentModificationException` 是 Java 中的一种异常，通常在使用集合类（如 `ArrayList`、`HashMap` 等）进行迭代时发生。它表示在迭代集合的过程中，发生了并发修改集合的操作，导致迭代器抛出异常。



## 二、列表对象引用的修改

源码

```java
@Override
public UserWardPageVo getUserWardRel(Long userId, String jobNumber) {
    // 声明响应参数
    UserWardPageVo userWardPageVo = new UserWardPageVo();
    userWardPageVo.setUserId(userId);

    // his职工病区关联列表
    List<HisUserWardVo> hisUserWardList = userWardPageVo.getHisUserWardList();
    // 职工病区关联列表
    List<UserWardVo> userWardList = userWardPageVo.getUserWardList();

    // 条件构造器
    LambdaQueryWrapper<UserWard> wrapper = Wrappers.<UserWard>lambdaQuery();
    wrapper.eq(UserWard::getUserId, userId);

    // 设置职工病区关联列表
    List<UserWard> userWards = baseMapper.selectList(wrapper);
    userWards.stream().forEach(r -> {
        UserWardVo userWardVo = new UserWardVo();
        BeanUtils.copyProperties(r, userWardVo);
        userWardList.add(userWardVo);
    });

    // 设置his职工病区关联列表
    UserWardPageVo userWardByJobNumber = this.getHisUserWardByJobNumber(jobNumber);
    hisUserWardList = userWardByJobNumber.getHisUserWardList();


    return userWardPageVo;
}
```

查看

问题出在这行代码：

```
javaCopy CodehisUserWardList = userWardByJobNumber.getHisUserWardList();
```

在这里，你重新为 `hisUserWardList` 赋了值，这会使它指向新的列表对象，而不再指向原始的 `userWardPageVo` 中的列表对象。这样，即使你修改了 `userWardByJobNumber` 中的 `hisUserWardList`，但并不会影响到 `userWardPageVo` 中的 `hisUserWardList`。

解决方法是，不要重新赋值，而是修改原始列表对象的内容。可以使用 `addAll` 方法将 `userWardByJobNumber` 中的列表添加到 `userWardPageVo` 中的 `hisUserWardList` 中，而不是直接重新赋值。修改代码如下：

```
javaCopy Code// 设置his职工病区关联列表
UserWardPageVo userWardByJobNumber = this.getHisUserWardByJobNumber(jobNumber);
hisUserWardList.addAll(userWardByJobNumber.getHisUserWardList());
```

这样，`hisUserWardList` 就会引用 `userWardPageVo` 中的列表对象，而不是指向一个新的列表对象。



## 三、Stream合并两个集合

源代码：

```java
List<WardInfo> collect = userWardList.stream().map(r -> {
            WardInfo wardInfo = new WardInfo();
            BeanUtils.copyProperties(r, wardInfo);
            return wardInfo;
        }).collect(Collectors.toList());
        List<WardInfo> collect1 = hisUserWardList.stream().map(r -> {
            WardInfo wardInfo = new WardInfo();
            BeanUtils.copyProperties(r, wardInfo);
            return wardInfo;
        }).collect(Collectors.toList());
        collect.addAll(collect1);
        List<WardInfo> collect2 = collect.stream().distinct().collect(Collectors.toList());
```

使用stream的concat方法优化：

```java
List<WardInfo> collect = Stream.concat(
        userWardList.stream().map(r -> {
            WardInfo wardInfo = new WardInfo();
            BeanUtils.copyProperties(r, wardInfo);
            return wardInfo;
        }),
        hisUserWardList.stream().map(r -> {
            WardInfo wardInfo = new WardInfo();
            BeanUtils.copyProperties(r, wardInfo);
            return wardInfo;
        })
    ).distinct().collect(Collectors.toList());

```

对于distinct比较的说明：

在 Java 中，`Stream` 中的 `.distinct()` 方法使用的是对象的 `equals()` 方法来确定两个对象是否相同。默认情况下，它会调用对象的 `equals()` 方法来比较对象是否相等。如果你没有重写 `equals()` 方法，默认情况下会使用 `Object` 类中的 `equals()` 方法，该方法会比较对象的引用是否相同，即它们是否指向内存中的相同位置。

如果你想要自定义对象的相等性判断逻辑，你需要在对象类中重写 `equals()` 方法，并根据你的需求来定义相等性的条件。在重写 `equals()` 方法时，通常还需要同时重写 `hashCode()` 方法，以确保对象在放入基于哈希的集合（如 `HashMap`、`HashSet` 等）时能够正确地处理。