## 一、根据实体类自动生成数据表字段 （actable框架）

### 1.1、源由

一直很疑惑，xxx项目是怎么做到根据实体类生成/更新数据表字段的（猜测是根据xxx注解，然后使用mysql的DDL操作表的结构）

后来在同事的帮助下，发现整个过程是通过actable框架实现的。

### 1.2、具体实现

引入相应的依赖：

```xml
<dependency>
    <groupId>com.gitee.sunchenbin.mybatis.actable</groupId>
    <artifactId>mybatis-enhance-actable</artifactId>
    <version>${actable.version}</version>
    <exclusions>
        <exclusion>
            <groupId>com.baomidou</groupId>
            <artifactId>mybatis-plus-annotation</artifactId>
        </exclusion>
    </exclusions>
</dependency>

<!-- 如需使用tk.mybatis同时需要依赖该jar包，之前1.3.1和1.3.0版本默认依赖了，但是有的小伙伴使用mybatis-plus会有冲突，所以这一版本默认不依赖，如需使用自行依赖即可 -->
<dependency>
    <groupId>tk.mybatis</groupId>
    <artifactId>mapper-spring-boot-starter</artifactId>
    <version>2.1.5</version>
</dependency>
```

配置文件中配置对于actable支持的配置

```yml
    actable.table.auto=update
    actable.model.pack=com.xxx.store.model(ps:要扫描的用于建表做依据的model目录)
    actable.database.type=mysql
    
    本系统提供四种模式：
    
    2.1 当actable.table.auto=create时，系统启动后，会将所有的表删除掉，然后根据model中配置的结构重新建表，该操作会破坏原有数据。
    
    2.2 当actable.table.auto=update时，系统会自动判断哪些表是新建的，哪些字段要修改类型等，哪些字段要删除，哪些字段要新增，该操作不会破坏原有数据。
    
    2.3 当actable.table.auto=none时，系统不做任何处理。
    
    2.4 当actable.table.auto=add，新增表/新增字段/新增索引/新增唯一约束的功能，不做做修改和删除 (只在版本1.0.9.RELEASE及以上支持)。
    
    2.5 actable.model.pack这个配置是用来配置要扫描的用于创建表的对象的包名
        
    2.6 actable.database.type这个是用来区别数据库的，预计会支持这四种数据库mysql/oracle/sqlserver/postgresql，但目前仅支持mysql
```

### 1.3、详情使用可参考官方文档

> https://www.yuque.com/sunchenbin/actable/nfz097



## 二、jackson序列化问题

### 2.1、源由

今天创建了一个VO类，然后里面没有写任何东西，并且将该对象以json数据返回给前端，然后调接口测试，发现报错了。

报错内容：

```
全局异常信息 ex=Type definition error: [simple type, class com.hscloud.hs.ward.model.vo.MedRecordPageVo]; nested exception is com.fasterxml.jackson.databind.exc.InvalidDefinitionException: No serializer found for class com.hscloud.hs.ward.model.vo.MedRecordPageVo and no properties discovered to create BeanSerializer (to avoid exception, disable SerializationFeature.FAIL_ON_EMPTY_BEANS) (through reference chain: com.pig4cloud.pigx.common.core.util.R["data"]->com.baomidou.mybatisplus.extension.plugins.pagination.Page["records"]->java.util.ArrayList[0])
```

### 2.2、原因分析

首先我们看下控制器，其返回的对象是R<Page<MedRecordPageVo>>

```
public R<Page<MedRecordPageVo>> MedRecordpage(@Validated MedRecordPageDto input) {
    return R.ok(medRecordService.MedRecordpage(input));
}
```

并且由于加了@RestController注解，其中@ResponseBody，会将我们返回的数据以json的数据返回出去。

此时如果MedRecordPageVo对象中的内容是空的话，因为 Jackson 默认情况下只序列化具有 getter 方法的属性，由于 Jackson 序列化器无法找到适合序列化 `MedRecordPageVo` 类的方法而引起报错。

### 2.3、解决

- 可以通过添加 getter 方法或者在实体类中添加 `@Data` 注解（如果使用 Lombok 的话），来确保 Jackson 能够正确地序列化对象。

- 或者通过在 Spring Boot 应用程序的配置文件（例如 `application.properties` 或 `application.yml`）中添加以下配置来禁用 Jackson 的 `FAIL_ON_EMPTY_BEANS` 特性（`spring.jackson.serialization.FAIL_ON_EMPTY_BEANS=false` 是 Spring Boot 应用程序中的一个属性配置，用于配置 Jackson 序列化器的行为。具体来说，这个配置的作用是告诉 Jackson 在序列化对象时，如果遇到空对象（即对象中的所有属性都为 null），是否抛出异常，默认为true）

  ```
  propertiesCopy Codespring.jackson.serialization.FAIL_ON_EMPTY_BEANS=false
  ```

- 或者直接通过创建一个配置类，去控制

  ```
  javaCopy Codeimport org.springframework.http.converter.json.Jackson2ObjectMapperBuilder;
  
  @Configuration
  public class JacksonConfig {
      @Bean
      public Jackson2ObjectMapperBuilder jacksonBuilder() {
          Jackson2ObjectMapperBuilder builder = new Jackson2ObjectMapperBuilder();
          builder.failOnEmptyBeans(false);
          return builder;
      }
  }
  ```



## 三、people who change the files in the active changelist also change

### 3.1、源由

在使用IDEA内置的Git的时候，在提交记录管理界面中出现了people who change the files in the active changelist also change

### 3.2、解决

用于提示作用，相关的解释如下所示：

people who change the files in the active changelist also change
这个列表的意思是：default changelist中修改的内容(用A表示)，在提交历史（git history）中发现(A,B)是一起提交修改的，AS 认为B内容你也有可能需要修改，如是把B的内容放在了people who change the files in the active changelist also change中；这样可以提醒你可能存在的关联修改类。

### 3.3、相关文档

> https://blog.csdn.net/kingyc123456789/article/details/107247184



## 四、is not an enclosing class

### 4.1、在类中

类定义方式：

```
public class A {
	// xxx
	
	public class B {
		// yyy
	}
}

```

类创建方式：

```
A.B ab = new A.B()
```

### 4.2、原因

若要创建内部类的实例，需要有外部类的实例才行。

### 4.3、解决方法

方式一：先创建外部类，再创建内部类

```
A.B ab = new A().new B();
```

方式二：将内部类设置为静态的

类定义方式：

```
public class A {
	// xxx
	
	public static class B {
		// yyy
	}
}
```

类创建方式：

```
A.B ab = new A.B()
```

