## 一、计算机组成与结构

### 1、 计算机系统基础知识

#### 1.1、计算机硬件组成概述

计算机的基本硬件系统由**五大部件**组成：运算器、控制器、存储器、输入设备和输出设备（其中运算器和控制器被集成在CPU中，即中央处理器）

> - 运算器、控制器等部件被集成在一起统称为中央处理单元(Central Processing Unit CPU)。CPU是硬件系统的核心，用于数据的加工处理，能完成各种算术逻辑运算及控制功能。（电脑中最贵的，还有一个显卡，用于图像计算）
> - 存储器（这里包含了电脑中的所有储存器，包括内存和外存）是计算机系统中的记忆设备（用于存数据），分为内部存储器（内存）和外部存储器（磁盘）。前者速度高、容量小，一般用于临时存放程序、数据及中间结果（电脑突然断电重启，内存中未持久化到外存中的数据将会丢失）。而后者容量大、速度慢，可以长期保存程序和数据。
> - 输入设备和输出设备合称为外部设备(简称外设)，输入设备用于输入原始数据及各种命令，而输出设备则用于输出计算机运行的结果。

#### 1.2、中央处理器（CPU）

##### 1. CPU的功能（1、2、3为控制器功能 4为运算器功能，从如下可以看出控制机才是CPU的核心）：

1. 程序控制。CPU通过执行指令来控制程序的执行顺序，这是CPU的重要功能；
2. 操作控制。一条指令功能的实现需要若干操作信号配合来完成，CPU产生每条指令的操作信号并将操作信号送往对应的部件，控制相应的部件按指令的功能要求进行操作。
3. 时间控制。CPU对各种操作进行时间上的控制，即指令执行过程中操作信号的出现时间、持续时间及出现的时间顺序都需要进行严格控制。
4. 数据处理。CPU 通过对数据进行算术运算及逻辑运算等方式进行加工处理,数据加工处理的结果被人们所利用。所以，对数据的加工处理也是CPU最根本的任务。

此外，CPU还需要对系统内部和外部的中断（执行过程中，需要打断当前所做的事情，去干其他事情的时候即为中断，即被外部事物中断）、异常做出响应，进行相应的处理

##### 2.CPU的组成

CPU的组成：CPU主要由运算器、控制器、寄存器组（用于存数据，容量很小32位或64位，速度很快，比内存还要快）和内部总线（通过总线，将这些东西串起来）等部件组成。

- 运算器

由算术逻辑单元（ALU）、累加寄存器（AC）、数据缓冲寄存器（DR）和状态条件寄存器（PSW）组成，其执行所有的算术运算，如加减乘除；执行所有的逻辑运算并进行逻辑测试，如与、或、非、比较等。

1. 算术逻辑单元（ALU）：实现对数据的算术和逻辑运算。
2. 累加寄存器（AC）：运算结果或源操作数的存放区（如果是a+b=c，a操作数可以被存在算术逻辑区,ALU本身可以存一个源操作数，b操作数、c结果存储在累加寄存区中）
3. 数据缓冲寄存器（DR）：暂时存放内存的指令和数据（应该是运算时用到的）
4. 状态条件寄存器（PSW）：保存指令运行结果的条件码内容，如溢出标志、除数为0等。

- 控制器

由指令寄存器（IR）、程序计数器（PC）、地址寄存器（AR）、指令译码器（ID）组成，控制整个CPU的工作，最为重要。

指令寄存器（IR）：暂存CPU执行指令；根据PC通过指令的地址找到指令，将其进行存储。

程序计数器（PC）：存放下一个指令执行的地址；通过PC找到需要下一个执行操作的地址，来控制指令的操作顺序；（执行CPU指令时，在一个指令周期的过程中，首先需从内存读取要执行的指令，此时先要将指令的地址即PC的内容发送到地址总线上）

地址寄存器（AR）：保存当前CPU所访问的内存地址；

指令译码器（ID）：分析指令操作码（操作码用来分析这个指令是干什么的，是加法还是减法）；



CPU依据指令周期的不同阶段来区分二进制的指令和数据，因为在指令周期的不同阶段，指令会命令CPU分别去取指令或者数据。

> CPU的执行过程先是取指令（从PC中获取到指令的地址，再从主存中将指令取出来），然后通过ID分析这个指令是干什么的，是加法、减法还是移位，分析完成后，去进行执行，执行过程中，需要去取其中的数据，如a+b,需要从内存中将操作数a和b取出来。因此在取指令的时候会取出指令，执行的时候会取出数据。



#### 1.3 数据表示

##### 1. 进制转换

进制的表示: 二进制、十六进制，一般在题目中会给出中文说明，如果没给出，注意二进制符号为0b开头，一般表示为0b0011，十六进制符号为开头0x或结尾H，可表示为0x18F或18FH。(十六进制可表示0-15，其中10-15用A-F来表示，类似十进制每位上只能是0-10)。关于进制转换如下：

- R进制整数转十进制:位权展开（相加）法，用R进制数的每一位乘以R的n次方，n是变量，从R进制数的整数最低位开始，依次为0,1,2,3..累加。
  例如有6进制数5043，此时R=6，用6进制数的每一位乘以6的n次方，n是变量从6进制数的整数最低位开始(5043从低位到高位排列:3,4,0,5)，n依次为0,1,2,3，那么最终`5043=3*6^0+4*6^1+0*6^2+5*6^3=1107`.

- 十进制转R进制:十进制整数(除以R倒取余数)，用十进制整数除以R，记录每次所得余数，若商不为0，则继续除以R，直至商为0，而后将所有余数从下至上记录，排列成从左至右顺序，即为转换后的R进制数;
  例:有十进制数200，转换为6进制，此时R=6，将200/6，得商为33，余数为2;因为商不等于0，因此再将商33/6，得商为5，余数为3;再将5/6，得商为0，余数为5;此时商为0，将所有余数从下到上记录，得532。

- m进制转n进制:先将m进制转化为十进制数，再将十进制数转化为n进制数中间需要通过十进制中转，一般来说，两种进制都需要十进制来进行中转，但下面这种情况进制间可以直接转化:

  二进制转八进制:每三位二进制数转换为一位八进制数，二进制数位个数不是三的倍数，则在前面补0(原则是数值不变)，如二进制数01101有五位，前面补一个0就有六位，为001 101，每三位转换为一位八进制数，001=1,101=1+4=5，也即01101=15。
  二进制转十六进制:每四位二进制数转换为一位十六进制数，二进制数位个数不是四的倍数，则在前面补0，如二进制数101101有六位，前面补两个0就有八位，为0010 1101，每四位转换为一位十六进制数，0010=2,1101=13=D，也即101101=2D。

  类似此规律，二进制转2^5=32、2^6=64……都符合上面的规律。

##### 2.编码方式

**前置知识点：**

- 机器数:各种数值在计算机中表示的形式(最底层的存储方法)，其特点是使用二进制计数制，数的的符号用0和1表示，小数点则隐含，不占位置。机器数有无符号数和带符号数之分。无符号数表示正数，没有符号位。带符号数最高位为符号位，正数符号位为0，负数符号位为1。

- 定点表示法分为纯小数（定点小数）和纯整数两种，其中小数点不占存储位，而是按照以下约定:

  纯小数（定点小数）:约定小数点的位置在机器数的最高数值位之前。即1234就是0.1234。

  纯整数（定点整数）:约定小数点的位置在机器数的最低数值位之后。即1234就是1234。

- 真值:机器数对应的实际数值。



**关于原码、反码、补码、移码**

当真值为-45时，即机器对应的实际数值为-45时，带符号数右下列编码方式（注：正数的原码、反码、补码都是同一个）

**原码:**一个数的正常二进制表示，最高位表示符号，数值0的源码有两种形式+0(00000000)和-0(10000000)。-45对应原码为10101101。
**反码:**正数的反码即原码;负数的反码是在原码的基础上，除符号位外，其他各位按位取反。数值0的反码也有两种形式:+0(00000000)，-0(11111111)。-45对应反码为11010010
**补码:**正数的补码即原码;负数的补码是在原码的基础上，除符号位外，其他各位按位取反，而后末位+1，若有进位则产生进位。因此数值0的补码只有一种形式+0=-0=00000000（对于11111111在加1为产生进位，并且第9位上为1，因为是机器字长为8，所以第九位的1会被舍弃，不用管）。-45对应补码为11010011
**移码:**用作浮点运算的阶码，无论正数负数，都是将该原码的补码的首位(符号位)取反得到移码。-45对应移码为01010011



**关于各个码制的取值范围**

机器字长为n时各种码制表示的带符号数的取值范围(差别在于0的表示，原码和反码分+0和-0，补码只有一个0，即+0=-0=0，因此可以多表示一个）

![image-20250210223224346](%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84.assets/image-20250210223224346.png)

> 解释：若机器字长为n，即有n-1位表示数值，1位表示符号
>
> 对于原码，除符号位，数值为中可表示的数共有2^（n-1）个，包含0，最大数是2^(n-1) -1 ，最大值2^（n-1）是取不到，因为取到了最高的符号位就变了，可表示的数0也算在内，其最小也是同理，最大的数只能取到2^（n-1）-1，然后加上符号位。
>
> 对于补码，最小数比原码反码大1，是因为其+0=-0=0，而原码和反码的+0和-0是不一样的。
>
> 对于定点小数，在定点整数的基础上都除以2^（n-1）即可

例：若机器字长为8，45和-45的原码、反码、补码和移码如下所示

![image-20250210224642227](%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84.assets/image-20250210224642227.png)



**浮点数**

浮点数:表示方法为`N=F*2^E`，其中E称为阶码，F称为尾数。其类似于十进制的科学计数法，如`85.125=0.85125*10^2`，二进制如`101.011=0.101011*2^3`

在浮点数的表示中，阶码为带符号的纯整数，尾数为带符号的纯小数，要注意符号占最高位(正数0负数1)，其表示格式如下:

![image-20250211201845230](%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84.assets/image-20250211201845230.png)

很明显，与科学计数法类似，一个浮点数的表示方法不是唯一的，浮点数所能表示的数值范围由阶码确定，所表示的数值精度由尾数（到小数点后几位）确定。

尾数的表示采用规格化方法，也即带符号尾数的补码必须为1.0xxxx(负数)或者0.1xxxx(正数)，其中x可为0或1.

浮点数的运算:

- 对阶(使两个数的阶码相同，小阶向大阶看齐，较小阶码增加几位，尾数就右移几位)
- 尾数计算(相加，若是减运算，则加负数)
- 结果规格化(即尾数表示规格化，即带符号尾数要转换为1.0xxxx或0.1xxxx)

> 对阶过程不能让数值改变，为什么要小阶向大阶对齐呢
>
> 如：`0.10101*2^3` 和` 0.11101*2^5`两个数进行运算
>
> 因为大阶向小阶对齐的话，在保留5位小数的情况下，`0.11101*2^5`就会变成`0.11100*2^3`,高位两位丢失（出现首尾丢失），出现了精度丢失，并且丢的比较大。
>
> 但如果是小阶向大阶对齐的话，`0.10101*2^3`就变成`0.00101*2^5`，同样也出现了精度丢失（尾精度丢失），但是是低位精度丢失，影响不多
>
> 因此小阶向大阶，尾数右移，丢弃末尾，不影响大局。





**真题：**

![image-20250211224657067](%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84.assets/image-20250211224657067.png)

![image-20250211225400409](%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84.assets/image-20250211225400409.png)







#### 1.4 校验码

##### 概念

- 码距:就单个编码A:00而言，其码距为1，因为其只需要改变一位就变成另一个编码。在两个编码中，从A码到B码转换所需要改变的位数称为码距，如A:00要转换为B:11，码距为2。一般来说，码距越大，越利于纠错和检错



##### 三种校验码

1、奇偶校验码

在编码中增加1位校验位来使编码中1的个数为奇数(奇校验或者偶数(偶校验)，从而使码距变为2（出错的那一位加上校验位即码距为2）。

例如:发送给接收方，接收方收到后，会计算收到的奇校验:编码中，含有奇数个1，编码有多少个1，如果是奇数个，则无误，是偶数个，则有误。
偶校验同理，只是编码中有偶数个1，

由上述，奇偶校验只能检1位错（即1位变动了，可以检错出来，如果有2个变了，那原来是奇数的结果还是奇数，区分不出来），并且无法纠错。

2、CRC（Cyclic Redundancy Check，循环冗余校验码）

CRC只能检错，不能纠错。使用CRC编码，需要先约定一个生成多项式G(x)生成多项式的最高位和最低位必须是1。假设原始信息有m位，则对应多项式M(x)。生成校验码思想就是在原始信息位后追加若干校验位，使得追加的信息能被G(x)整除。接收方接收到带校验位的信息，然后用G(x)整除。余数为0，则没有错误;反之则发生错误。

> 例：假设原始信息串为10110，CRC的生成多项式为G(x)=x^4+x+1，求CRC校验码
>
> （1）在原始信息位后面添0，假设生成多项式的阶为r，则在原始信息位后添加r个0，本题中，G(x)阶为4（阶通常指的是多项式的最高次项的次数，x的4次），则在原始信息串后加4个0，得到的新串为10110 0000作为被除数。
>
> （2）由多项式得到除数，多项中x的幂指数存在的位置1，不存在的位置0。本题中，x的幂指数为0,1,4的变量都存在（x的0次，x的1次，x的4次），而幂指数为2,3的不存在，因此得到串10011.
>
> （3）生成CRC校验码，将前两步得出的被除数和除数进行模2除法运算(即异或运算，同0分1，不进位也不借位的除法运算)。除法过程如下图所示。
>
> ![image-20250212211015745](%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84.assets/image-20250212211015745.png)
>
> 得到余数1111.注意:余数不足r，则余数左边用若干个0补齐。如求得余数为11，r=4，则补两个0得到0011。
>
> （4）生成最终发送信息串，将余数添加到原始信息后。上例中，原始信息为10110，添加余数1111后，结果为10110 1111。发送方将此数据发送给接收方。（5）接收方进行校验。接收方的CRC校验过程与生成过程类似，接收方接收了带校验和的帧后，用多项式G(x)来除（模2除法）。余数为0，则表示信息无错;否则要求发送方进行重传。
>
> 注意:收发信息双方需使用相同的生成多项式

3、海明码

 海明码:本质也是利用奇偶性来检错和纠错的检验方法，构成方法是在数据位之间的确定位置上插入k个校验位，通过扩大码距实现检错和纠错。设数据位是n位，校验位是k位，则n和k必须满足以下关系:2^k-1>=n+k。

示例：

求信息1011的海明码

（1）校验位的位数和具体的数据位的位数之间的关系

所有位都编号，从最低位编号，从1开始递增，校验位处于2的n(n=0 1 2...)……次方中，即处于第1,2,4,8,16,32位上，其余位才能填充真正的数据位，若信息数据为1011，则可知，第1,2,4位为校验位，第3,5,6,7位为数据位，用来从低位开始存放1011，得出信息位和校验位分布如下:

![image-20250212224216822](%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84.assets/image-20250212224216822.png)

（2）计算校验码

将所有信息位的编号都拆分成二进制表示如下图所示:

![image-20250212230448349](%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84.assets/image-20250212230448349.png)

上图中，7=4+2+1，表示7由第4位校验位(r2)和第2位校验位(r1)和第1位校验位(r0)共同校验，同理，第6位数据位6=4+2，第5位数据位5=4+1，第3位数据位3=2+1，前面知道，这些2的n次方都是校验位，可知，第4位校验位校验第765三位数据位，因此，第4位校验位r2等于这三位数据位的值异或，第2位和第1位校验位计算原理同上:
计算出三个校验位后，可知最终要发送的海明校验码为1010101.

（3）检错和纠错原理

接收方收到海明码之后，会将每一位校验位与其校验的位数分别异或，即做如下三组运算:

![image-20250212230705932](%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84.assets/image-20250212230705932.png)

如果是偶校验，那么运算得到的结果应该全为0，如果是奇校验，应该全为1（前面是计算校验码的时候，要取反），才是正确，假设是偶校验，且接收到的数据为1011101(第四位出错)，此时运算的结果为:

![image-20250212230724547](%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84.assets/image-20250212230724547.png)

这里不全为0，表明传输过程有误，并且按照r2r1r0排列为二进制100，这里指出的就是错误的位数，表示第100，即第4位出错，找到了出错位，纠错方法就是将该位逆转（因为是二进制）。



### 2、计算机体系结构

#### 2.1 体系结构分类

- 按处理机（不光是指CPU，而是指一个成熟的PC）的数量进行分类:单处理系统(一个处理单元和其他设备集成)、并行处理系统(两个以上的处理机互联)、分布式（一台在上海，一台在北京，物理上隔离）处理系统(物理上远距离且松耦合的多计算机系统)

- Flynn分类法:分类有两个因素，即指令流和数据流，指令流由控制部分（类似于CPU中的控制器）处理，每一个控制部分处理一条指令流，多指令流就有多个控制部分;数据流由处理器来处理每一个处理器处理一条数据流，多数据流就有多个处理器;至于主存模块，是用来存储的，存储指令流或者数据流，因此，无论是多指令流还是多数据流，都需要多个主存模块来存储，对于主存模块，指令和数据都一样。

  ![image-20250217224624600](%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84.assets/image-20250217224624600.png)

  多指令流单数据流类似于多个上司一个打工人，多个上司都给这个打工人派活，忙不过来。但是反一下，是可以的，一个上司给多个打工人派活。

- 依据计算机特性，是由指令来控制数据的传输，因此，一条指令可以控制一条或多条数据流，但一条数据流不能被多条指令控制，否则会出错，就如同上级命令太多还互相冲突不知道该执行哪个，因此多指令单数据MISD不可能。

#### 2.2 指令系统

##### 1.**计算机指令的组成**

一条指令由操作码和操作数（可能有多个）两部分组成前一段存操作码后一段存操作数，操作码决定要完成的操作，操作数指参加运算的数据及其所在的单元地址。在计算机中，操作要求和操作数地址都由二进制数码表示，分别称作操作码和地址码，整条指令以二进制编码的形式存放在存储器中。

##### 2. **计算机指令执行过程**

取指令--分析指令--执行指令三个步骤，首先将程序计数器PC中的指令（一般都存储在主存中）地址取出，送入地址总线，CPU依据指令地址去内存中取出指令内容存入指令寄存器IR;而后由指令译码器进行分析，分析指令操作码;最后执行指令，取出指令执行所需的源操作数。

##### 3.指令寻址方式

- 顺序寻址方式

当执行一段程序时，是一条指令接着一条指令地顺序执行。(按照程序计数器PC中存储的指令地址来)

- 跳跃寻址方式

指下一条指令的地址码不是由程序计数器给出，而是由本条指令直接给出。程序跳跃后，按新的指令地址开始顺序执行。因此，程序计数器的内容也必须相应改变，以便及时跟踪新的指令地址。



##### 4.指令操作数寻址方法

- 立即寻址方式：指令的地址码字段指出的不是地址，而是操作数本身。
- 直接寻址方式：在指令的地址字段中直接指出操作数在主存中的地址。
- 间接寻址方式:指令地址码字段所指向的存储单元中存储的是操作数的地址。
- 寄存器寻址方式:指令中的地址码是寄存器的编号。
- 基址寻址方式:将基址寄存器的内容加上指令中的形式地址而形成操作数的有效地址，其优点是可以扩大寻址能力。
- 变址寻址方式:变址寻址方式计算有效地址的方法与基址寻址方式很相似，它是将变址寄存器的内容加上指令中的形式地址而形成操作数的有效地址。



##### 5.CISC和RISC

- CISC是复杂指令系统，兼容性强，指令繁多、长度可变，由微程序实现;
- RISC是精简指令系统，指令少，使用频率接近，主要依靠硬件实现(通用寄存器硬布线逻辑控制)

![image-20250218000642864](%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84.assets/image-20250218000642864.png)



##### 6.真题

![image-20250218000702205](%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84.assets/image-20250218000702205.png)



##### 7.指令流水

![image-20250218000748021](%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84.assets/image-20250218000748021.png)

指令流水线原理:将指令分成不同段，每段由不同的部分去处理，因此可以产生叠加的效果（即2在执行的时候，下一个任务的1可以开始了），所有的部件去处理指令的不同段。

> RISC中的流水线技术
>
> (1)超流水线(Super Pipe Line)技术。它通过细化流水、增加级数和提高主频，使得在每个机器周期内能完成一个甚至两个浮点操作。其实质是以时间换取空间
>
> (2)超标量(Super Scalar)技术。它通过内装多条流水线来同时执行多个处理，其时钟频率虽然与一般流水接近，却有更小的CPI。其实质是以空间换取时间
>
> (3)超长指令字(Very Long Instruction Word，VLlW)技术VLIW 和超标量都是20 世纪80年代出现的概念，其共同点是要同时执行多条指令，其不同在于超标量依靠硬件来实现并行处理的调度，VLIW 则充分发挥软件的作用，而使硬件简化性能提高。

![image-20250218000923516](%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84.assets/image-20250218000923516.png)

真题：

![image-20250218000934808](%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84.assets/image-20250218000934808.png)

![image-20250218000942188](%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84.assets/image-20250218000942188.png)

#### 2.3 存储系统

##### 1.计算机分级存储体系结构

计算机分级存储体系结构图如下所示

![image-20250224203946940](%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84.assets/image-20250224203946940.png)

（从上到下，越往下，价格越便宜、速度越慢、容量越大。CPU通用寄存器一般32bit，Cache一般MB级别，主存8GB、在下面的外存一般500GB-1TB）

计算机采用分级存储体系的主要目的是为了解决存储容量、成本和速度之前的矛盾问题。

两级存储：Cache-主存、主存-辅存（虚拟存储体系）。正常来说CPU是直接和主存进行通信的，但是主存速度相比较于CPU太慢（CPU速度比主存快几十倍），所以中间加了一层高速缓存即Cache（速度比内存快10倍，速度比寄存器慢，将主存中常用的数据存储在Cache中，这样CPU在访问主存前，就先访问Cache，从其中获取数据了，提高效率）

主存和Cache之间的容量也是相差了好几倍，那CPU怎么知道哪些是常用的数据，需要将主存中常用的数据放到Cache中呢，其依据根据局部性原理：

> 局部性原理：总的来说，在CPU运行时，所访问的数据会趋向于一个教小的局部空间地址内，包括下面两方面：
>
> - 时间局部性原理：如果一个数据项正在被访问，那么在近期它很可能会被再次访问，即在相邻的时间里会访问同一个数据项。
> - 空间局部性原理：在最近的将来会用到的数据的地址和现在正在访问的数据地址很可能是相近的，即响铃的控件地址会被连续访问。



##### 2.Cache

**说明：**

1. 高速缓存Cache用来存储当前最活跃的程序和数据，其直接与CPU交互，位于CPU和主存之间，容量小，速度Wie内存的5-10倍，由半导体材料构成。其内容是主存内存的副本拷贝（存储内存中最核心的内容），对于程序员来说是透明的
2. Cache由控制部分和存储器组成，存储器存储数据，控制部分判断CPU要访问的数据是否在Cache中，在则命中，不在则依据一定的算法从主存中进行替换。
3. 关于Cache中和内存的地址映射：在CPU工作时，送出的是主存单元的地址，而应从Cache存储器中读/写信息。这就需要将主存地址转换为Cache存储器地址，这种地址的转换成为地址映射，其由硬件自动完成映射（不是编程、系统去完成映射的），其分为如下三种方式：

- 直接映射:将Cache存储器等分成块，主存也等分成块并编号。主存中的块与Cache中的块的对应关系是固定的，也即二者块号相同才能命中。地址变换简单但不灵活，容易造成资源浪费。

  ![image-20250224211810671](%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84.assets/image-20250224211810671.png)

  假设Cache大小为1MB，主存大小为1GB，首先Cache中会分块，假设每个块的大小为1Bit，那么一共分成1024块，主存然后也会分块，分成1024*1024个块，然后分成1024个区，Cache中的块号和主存中的块号相等，才可以命中，第0块可以对应主存中第0区的第0块、也可以是第1区的第0块……不区分区。

- 全相联映像：同样都等分成块并编号。主存中任意一块都与Cache中任意一块对应。因此可以随意调入Cache任意位置，但地址变换复杂，速度较慢。因为主存可以随意调入Cache任意块，只有当Cache满了才会发生块冲突，是最不容易发生块冲突的映像方式。

  ![image-20250224213012014](%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84.assets/image-20250224213012014.png)

  主存没有分区，直接从0到最后一块（如nk），只要有空位就可以去调入Cache任意块。

- 组组相联映象：前面两种方式的结合将Cache存储器先分块再分组，主存也同样先分块再分组，组间采用直接映像，即主存中组号与Cache中组号相同的组才能命中，但是组内全相联映像，也即组号相同的两个组内的所有块可以任意调换。





**替换算法：**

将主存中的内容，替换cache中的块，cache没有满，主存可以往里面调，如果cache满了的话，主存就需要替换其中的一块。原则上是Cache替换掉不常用的哪一块。替换算法就是使Cache获得竟可能高的命中率，常用算法如下：

- 随机替换算法。就是用随机数发生器产生一个要替换的块号，将该块替换出去。
- 先进先出算法。就是将最先进入Cache的信息块替换出去
- 近期最少使用算法。这种方法是将近期最少使用的Cache中的信息块替换出去
- 优化替换算法。这种方法必须先执行一次程序，统计Cache 的替换情况。
  有了这样的先验信息，在第二次执行该程序时便可以用最有效的方式来替换。



**命中率即平均时间：**

Cache有一个命中率的概念，即当CPU访问的数据zai Cache中时，命中，直接从Cache中读取数据，设读取一次Cache时间为1ns，若CPU访问的数据不在Cache中，则需要从内存中读取，设读取一次内存的事件为1000ns，若在CPU多次读取数据过程中，有90%命中Cache，则CPU读取一次的平均时间为`(90%*1+10%*1000)ns`

![image-20250224214324813](%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84.assets/image-20250224214324813.png)





**真题：**

![image-20250224214758092](%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84.assets/image-20250224214758092.png)

第一题：块冲突，即主存中的数据要放大Cache中，是否会发生冲突，直接映射因为是Cache和主存中的Cache的块是对应的，所以容易发生冲突。全相联只有Cache满了才会发生块冲突，而组组相连映射介于两者之间。 (B)

第二题：（D）



![image-20250224221048259](%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84.assets/image-20250224221048259.png)





##### 3.磁盘

**磁盘结构和参数**

磁盘有正反两个盘面，每个盘面有多个同心圆，每个同心圆是一个磁道，每个同心圆又被划分为多个扇区，数据就被存放在一个个扇区中。
磁头首先要寻找到对应的磁道，然后等待磁盘进行周期旋转，旋转到指定的区，才能读取到对应的数据，因此，会产生寻道时间和等待时间。公式为:存取时间=寻道时间+等待时间(平均定位时间+转动延迟)
注意:寻道时间是指磁头移动到磁道所需的时间;等待时间为等待读写的扇区转到磁头下方所用的时间。

![image-20250224222131100](%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84.assets/image-20250224222131100.png)



**磁盘调度算法**

之前已经说过，不磁盘数据的读取时间分为寻道时间+旋转时间，也即先找到对应的磁道，而后再旋转到对应的扇区才能读取数据，其中寻道时间耗时最长，需要重点调度，有如下调度算法:

- 先来先服务FCFS:根据进程请求访问磁盘的先后顺序进行调度。
- 最短寻道时间优先SSTF:请求访问的磁道与当前磁道最近的进程优先调度，使得会产生“饥饿”现象，即远处进程可能永远无法访问。每次的寻道时间最短。
- 扫描算法SCAN:又称“电梯算法”，磁头在磁盘上双向移动，其会选择离磁头当前所在磁道最近的请求访问的磁道，并且与磁头移动方向一致，磁头永远都是从里向外或者从外向里一直移动完才掉头，与电梯类似。
- 单向扫描调度算法CSCAN:与SCAN不同的是，其只做单向移动，即只能从里向外或者从外向里。



**真题**

![image-20250225204651470](%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84.assets/image-20250225204651470.png)

答案：C  A

处理记录的过程：读+处理，读的时间就是扫过这一块物理块的时间（33/11 = 3ms），如在读取完R0后，此时磁头就位于R1了，然后完成R0的处理，磁头的位置就到达R3了，完成R0的时间就是3+3，因为系统使用单缓冲区顺序处理这些记录，所以下一次到R1进行读取的时候，就需要3*10，那么加上读取处理的时间总耗时就是3+3+3 * 10，那么后面也是一样，所以答案就是C。通过第一题可以知道，我们只需要交叉排序，就可以使得用时最短，即A。



![image-20250225205829923](%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84.assets/image-20250225205829923.png)

答案：D

找最近的，扇区号从小到大



#### 2.4 输入/输出技术 

**计算机系统中存在多种内存与接口地址的编址方法**

常见的是下面两种：

- 内存与接口地址独立编址方法，内存地址和接口地址是完全独立的两个地址空间。访问数据时所使用的指令也完全不同，用于接口的指令只用于接口的读/写，其余的指令全都是用于内存的。因此，在编程序或读程序时很易使用和辨认。这种编址方法的缺点是用于接口的指令太少、功能太弱。
- 内存与接口地址统一编址方法，内存地址和接口地址统一在一个公共的地址空间里，即内存单元和接口共用地址空间。优点是原则上用于内存的指令全都可以用于接口，这就大大地增强了对接口的操作功能，而且在指令上也不再区分内存或接口指令。该编址方法的缺点就在于整个地址空间被分成两部分，其中一部分分配给接口使用，剩余的为内存所用，这经常会导致内存地址不连续



**计算机和外设间的数据交互方式**

- 程序控制(查询)方式:CPU主动查询外设是否完成数据传输，效率极低

- 程序中断方式:外设完成数据传输后，向CPU发送中断，等待CPU处理数据效率相对较高。**中断响应时间**指的是从发出中断请求到开始进入中断处理程序；**中断处理时间**指的是从中断处理开始到中断处理结束；**中断向量**提供中断服务程序的入口地址。多级中断嵌套，使用堆栈来保护断点和现场。

- DMA方式(直接主存存取):CPU只需要完成必要的初始化等操作，后面就不需要管了，数据传输的整个过程都由DMA控制器来完成，在主存和外设之间建立直接的数据通路效率很高。

- 在一个总线周期结束后，CPU会响应DMA请求开始读取数据;CPU响应程序中断方式请求是在一条指令执行结束时。

  > 计算机有一个时钟频率，即CPU的工作频率，如3.5ghz，这个频率的倒数就是时钟周期，是CPU中最小的时间单位。一个时间周期包含多个时钟周期，一个指令周期也包含多个时钟周期，中断来的时候，CPU不会立即结束指令，只会在指令执行结束的时候去响应中断。
  >
  > DMA相当于建立一个总线，所以是总线周期。

中断流程

![image-20250225230710600](%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84.assets/image-20250225230710600.png)

- 中断响应时间:中断请求开始，一直到保存现场
- 中断处理时间：中断服务程序





#### 2.5 总线结构

##### 总线概念

总线(Bus)，是指计算机设备和设备之间传输信息的公共数据通道。总线是连接计算机硬件系统内多种设备的通信线路，它的一个重要特征是由总线上的所有设备共享，因此可以将计算机系统内的多种设备连接到总线上



##### 总线分类

从广义上讲，任何连接两个以上电子元器件的导线都可以称为总线，通常分为以下三类:

**内部总线**:内部芯片级别的总线，芯片与处理器之间通信的总线。

**系统总线**:是板级总线，用于计算机内各部分之间的连接，具体分为①数据总线(并行数据传输位数)、②地址总线(系统可管理的内存空间的大小)、③控制总线(传送控制命令)。代表的有ISA总线、EISA总线、PCI总线.

**外部总线**:设备一级的总线，微机和外部设备的总线。代表的有RS232(串行总线)、SCSI(并行总线)、USB(通用串行总线，即插即用，支持热插拔)





**真题：**

![image-20250225221738030](%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84.assets/image-20250225221738030.png)

答案1：D

答案2：C

> A是错误的，因为串行总线适合长距离低速数据传输（因为一次只能传输一位数据，所以低速）
>
> B是错误的，因为并行总线适合短距离高速传输（成本高，所以距离短，每一次可以传多位数据，所以高速）
>
> D是错误的，因为：
>
> - 单工：只能有一个方向传输信息，如A到B，或者B到A。
> - 半双工：同一时刻只能在一个方向上传输信息，不同时刻可以是A到B，也可以是B到A
> - 全双工：任意时刻向任意方向传输



**可靠性指标**

- 平均无故障时间MTTF=1/失效率
- 平均故障修复时间MTTR=1/修复率
- 平均故障间隔时间MTBF=MTTF+MTTR（一次故障机故障修复时间+平均无故障时间）
- 系统可用性=MTTF/(MTTF+MTTR)*100%



**串并联系统可靠性**

- 串行系统

无论什么系统，都是由多个设备组成的，协同工作，而这多个设备的组合方式可以是串联、并联，也可以是混合模式，假设每个设备的可靠性为R1，R2....Rn则不同的系统的可靠性公式如下:串联系统，一个设备不可靠，整个系统崩溃，整个系统可靠性`R=R1*R2*..*Rn`。

![image-20250225224455889](%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84.assets/image-20250225224455889.png)

- 并联系统

所有设备都不可靠，整个系统才崩溃整个系统可靠性`R=1-(1-R1)*（1-r2）*……*(1-Rn)`

![image-20250225224636137](%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84.assets/image-20250225224636137.png)

- N模冗余系统

N模冗余系统由N个(N=2n+1)相同的子系统和一个表决器组成，表决器把N 个子系统中占多数相同结果的输出作为输出系统的输出，如所示。在N个子系统中，只要有n+1个或n+1个以上子系统能正常工作，系统就能正常工作，输出正确的结果。

![image-20250225224720379](%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84.assets/image-20250225224720379.png)



**真题**

![image-20250225224745048](%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84.assets/image-20250225224745048.png)

答案：A
