## 一、计算机组成与结构

### 1、 计算机系统基础知识

#### 1.1、计算机硬件组成概述

计算机的基本硬件系统由**五大部件**组成：运算器、控制器、存储器、输入设备和输出设备（其中运算器和控制器被集成在CPU中，即中央处理器）

> - 运算器、控制器等部件被集成在一起统称为中央处理单元(Central Processing Unit CPU)。CPU是硬件系统的核心，用于数据的加工处理，能完成各种算术逻辑运算及控制功能。（电脑中最贵的，还有一个显卡，用于图像计算）
> - 存储器（这里包含了电脑中的所有储存器，包括内存和外存）是计算机系统中的记忆设备（用于存数据），分为内部存储器（内存）和外部存储器（磁盘）。前者速度高、容量小，一般用于临时存放程序、数据及中间结果（电脑突然断电重启，内存中未持久化到外存中的数据将会丢失）。而后者容量大、速度慢，可以长期保存程序和数据。
> - 输入设备和输出设备合称为外部设备(简称外设)，输入设备用于输入原始数据及各种命令，而输出设备则用于输出计算机运行的结果。

#### 1.2、中央处理器（CPU）

##### 1. CPU的功能（1、2、3为控制器功能 4为运算器功能，从如下可以看出控制机才是CPU的核心）：

1. 程序控制。CPU通过执行指令来控制程序的执行顺序，这是CPU的重要功能；
2. 操作控制。一条指令功能的实现需要若干操作信号配合来完成，CPU产生每条指令的操作信号并将操作信号送往对应的部件，控制相应的部件按指令的功能要求进行操作。
3. 时间控制。CPU对各种操作进行时间上的控制，即指令执行过程中操作信号的出现时间、持续时间及出现的时间顺序都需要进行严格控制。
4. 数据处理。CPU 通过对数据进行算术运算及逻辑运算等方式进行加工处理,数据加工处理的结果被人们所利用。所以，对数据的加工处理也是CPU最根本的任务。

此外，CPU还需要对系统内部和外部的中断（执行过程中，需要打断当前所做的事情，去干其他事情的时候即为中断，即被外部事物中断）、异常做出响应，进行相应的处理

##### 2.CPU的组成

CPU的组成：CPU主要由运算器、控制器、寄存器组（用于存数据，容量很小32位或64位，速度很快，比内存还要快）和内部总线（通过总线，将这些东西串起来）等部件组成。

- 运算器

由算术逻辑单元（ALU）、累加寄存器（AC）、数据缓冲寄存器（DR）和状态条件寄存器（PSW）组成，其执行所有的算术运算，如加减乘除；执行所有的逻辑运算并进行逻辑测试，如与、或、非、比较等。

1. 算术逻辑单元（ALU）：实现对数据的算术和逻辑运算。
2. 累加寄存器（AC）：运算结果或源操作数的存放区（如果是a+b=c，a操作数可以被存在算术逻辑区,ALU本身可以存一个源操作数，b操作数、c结果存储在累加寄存区中）
3. 数据缓冲寄存器（DR）：暂时存放内存的指令和数据（应该是运算时用到的）
4. 状态条件寄存器（PSW）：保存指令运行结果的条件码内容，如溢出标志、除数为0等。

- 控制器

由指令寄存器（IR）、程序计数器（PC）、地址寄存器（AR）、指令译码器（ID）组成，控制整个CPU的工作，最为重要。

指令寄存器（IR）：暂存CPU执行指令；根据PC通过指令的地址找到指令，将其进行存储。

程序计数器（PC）：存放下一个指令执行的地址；通过PC找到需要下一个执行操作的地址，来控制指令的操作顺序；（执行CPU指令时，在一个指令周期的过程中，首先需从内存读取要执行的指令，此时先要将指令的地址即PC的内容发送到地址总线上）

地址寄存器（AR）：保存当前CPU所访问的内存地址；

指令译码器（ID）：分析指令操作码（操作码用来分析这个指令是干什么的，是加法还是减法）；



CPU依据指令周期的不同阶段来区分二进制的指令和数据，因为在指令周期的不同阶段，指令会命令CPU分别去取指令或者数据。

> CPU的执行过程先是取指令（从PC中获取到指令的地址，再从主存中将指令取出来），然后通过ID分析这个指令是干什么的，是加法、减法还是移位，分析完成后，去进行执行，执行过程中，需要去取其中的数据，如a+b,需要从内存中将操作数a和b取出来。因此在取指令的时候会取出指令，执行的时候会取出数据。



#### 1.3 数据表示

##### 1. 进制转换

进制的表示: 二进制、十六进制，一般在题目中会给出中文说明，如果没给出，注意二进制符号为0b开头，一般表示为0b0011，十六进制符号为开头0x或结尾H，可表示为0x18F或18FH。(十六进制可表示0-15，其中10-15用A-F来表示，类似十进制每位上只能是0-10)。关于进制转换如下：

- R进制整数转十进制:位权展开（相加）法，用R进制数的每一位乘以R的n次方，n是变量，从R进制数的整数最低位开始，依次为0,1,2,3..累加。
  例如有6进制数5043，此时R=6，用6进制数的每一位乘以6的n次方，n是变量从6进制数的整数最低位开始(5043从低位到高位排列:3,4,0,5)，n依次为0,1,2,3，那么最终`5043=3*6^0+4*6^1+0*6^2+5*6^3=1107`.

- 十进制转R进制:十进制整数(除以R倒取余数)，用十进制整数除以R，记录每次所得余数，若商不为0，则继续除以R，直至商为0，而后将所有余数从下至上记录，排列成从左至右顺序，即为转换后的R进制数;
  例:有十进制数200，转换为6进制，此时R=6，将200/6，得商为33，余数为2;因为商不等于0，因此再将商33/6，得商为5，余数为3;再将5/6，得商为0，余数为5;此时商为0，将所有余数从下到上记录，得532。

- m进制转n进制:先将m进制转化为十进制数，再将十进制数转化为n进制数中间需要通过十进制中转，一般来说，两种进制都需要十进制来进行中转，但下面这种情况进制间可以直接转化:

  二进制转八进制:每三位二进制数转换为一位八进制数，二进制数位个数不是三的倍数，则在前面补0(原则是数值不变)，如二进制数01101有五位，前面补一个0就有六位，为001 101，每三位转换为一位八进制数，001=1,101=1+4=5，也即01101=15。
  二进制转十六进制:每四位二进制数转换为一位十六进制数，二进制数位个数不是四的倍数，则在前面补0，如二进制数101101有六位，前面补两个0就有八位，为0010 1101，每四位转换为一位十六进制数，0010=2,1101=13=D，也即101101=2D。

  类似此规律，二进制转2^5=32、2^6=64……都符合上面的规律。

##### 2.编码方式

**前置知识点：**

- 机器数:各种数值在计算机中表示的形式(最底层的存储方法)，其特点是使用二进制计数制，数的的符号用0和1表示，小数点则隐含，不占位置。机器数有无符号数和带符号数之分。无符号数表示正数，没有符号位。带符号数最高位为符号位，正数符号位为0，负数符号位为1。

- 定点表示法分为纯小数（定点小数）和纯整数两种，其中小数点不占存储位，而是按照以下约定:

  纯小数（定点小数）:约定小数点的位置在机器数的最高数值位之前。即1234就是0.1234。

  纯整数（定点整数）:约定小数点的位置在机器数的最低数值位之后。即1234就是1234。

- 真值:机器数对应的实际数值。



**关于原码、反码、补码、移码**

当真值为-45时，即机器对应的实际数值为-45时，带符号数右下列编码方式（注：正数的原码、反码、补码都是同一个）

**原码:**一个数的正常二进制表示，最高位表示符号，数值0的源码有两种形式+0(00000000)和-0(10000000)。-45对应原码为10101101。
**反码:**正数的反码即原码;负数的反码是在原码的基础上，除符号位外，其他各位按位取反。数值0的反码也有两种形式:+0(00000000)，-0(11111111)。-45对应反码为11010010
**补码:**正数的补码即原码;负数的补码是在原码的基础上，除符号位外，其他各位按位取反，而后末位+1，若有进位则产生进位。因此数值0的补码只有一种形式+0=-0=00000000（对于11111111在加1为产生进位，并且第9位上为1，因为是机器字长为8，所以第九位的1会被舍弃，不用管）。-45对应补码为11010011
**移码:**用作浮点运算的阶码，无论正数负数，都是将该原码的补码的首位(符号位)取反得到移码。-45对应移码为01010011



**关于各个码制的取值范围**

机器字长为n时各种码制表示的带符号数的取值范围(差别在于0的表示，原码和反码分+0和-0，补码只有一个0，即+0=-0=0，因此可以多表示一个）

![image-20250210223224346](%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84.assets/image-20250210223224346.png)

> 解释：若机器字长为n，即有n-1位表示数值，1位表示符号
>
> 对于原码，除符号位，数值为中可表示的数共有2^（n-1）个，包含0，最大数是2^(n-1) -1 ，最大值2^（n-1）是取不到，因为取到了最高的符号位就变了，可表示的数0也算在内，其最小也是同理，最大的数只能取到2^（n-1）-1，然后加上符号位。
>
> 对于补码，最小数比原码反码大1，是因为其+0=-0=0，而原码和反码的+0和-0是不一样的。
>
> 对于定点小数，在定点整数的基础上都除以2^（n-1）即可

例：若机器字长为8，45和-45的原码、反码、补码和移码如下所示

![image-20250210224642227](%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84.assets/image-20250210224642227.png)



**浮点数**

浮点数:表示方法为`N=F*2^E`，其中E称为阶码，F称为尾数。其类似于十进制的科学计数法，如`85.125=0.85125*10^2`，二进制如`101.011=0.101011*2^3`

在浮点数的表示中，阶码为带符号的纯整数，尾数为带符号的纯小数，要注意符号占最高位(正数0负数1)，其表示格式如下:

![image-20250211201845230](%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84.assets/image-20250211201845230.png)

很明显，与科学计数法类似，一个浮点数的表示方法不是唯一的，浮点数所能表示的数值范围由阶码确定，所表示的数值精度由尾数（到小数点后几位）确定。

尾数的表示采用规格化方法，也即带符号尾数的补码必须为1.0xxxx(负数)或者0.1xxxx(正数)，其中x可为0或1.

浮点数的运算:

- 对阶(使两个数的阶码相同，小阶向大阶看齐，较小阶码增加几位，尾数就右移几位)
- 尾数计算(相加，若是减运算，则加负数)
- 结果规格化(即尾数表示规格化，即带符号尾数要转换为1.0xxxx或0.1xxxx)

> 对阶过程不能让数值改变，为什么要小阶向大阶对齐呢
>
> 如：`0.10101*2^3` 和` 0.11101*2^5`两个数进行运算
>
> 因为大阶向小阶对齐的话，在保留5位小数的情况下，`0.11101*2^5`就会变成`0.11100*2^3`,高位两位丢失（出现首尾丢失），出现了精度丢失，并且丢的比较大。
>
> 但如果是小阶向大阶对齐的话，`0.10101*2^3`就变成`0.00101*2^5`，同样也出现了精度丢失（尾精度丢失），但是是低位精度丢失，影响不多
>
> 因此小阶向大阶，尾数右移，丢弃末尾，不影响大局。





**真题：**

![image-20250211224657067](%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84.assets/image-20250211224657067.png)

![image-20250211225400409](%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84.assets/image-20250211225400409.png)







#### 1.4 校验码

##### 概念

- 码距:就单个编码A:00而言，其码距为1，因为其只需要改变一位就变成另一个编码。在两个编码中，从A码到B码转换所需要改变的位数称为码距，如A:00要转换为B:11，码距为2。一般来说，码距越大，越利于纠错和检错



##### 三种校验码

1、奇偶校验码

在编码中增加1位校验位来使编码中1的个数为奇数(奇校验或者偶数(偶校验)，从而使码距变为2（出错的那一位加上校验位即码距为2）。

例如:发送给接收方，接收方收到后，会计算收到的奇校验:编码中，含有奇数个1，编码有多少个1，如果是奇数个，则无误，是偶数个，则有误。
偶校验同理，只是编码中有偶数个1，

由上述，奇偶校验只能检1位错（即1位变动了，可以检错出来，如果有2个变了，那原来是奇数的结果还是奇数，区分不出来），并且无法纠错。

2、CRC（Cyclic Redundancy Check，循环冗余校验码）

CRC只能检错，不能纠错。使用CRC编码，需要先约定一个生成多项式G(x)生成多项式的最高位和最低位必须是1。假设原始信息有m位，则对应多项式M(x)。生成校验码思想就是在原始信息位后追加若干校验位，使得追加的信息能被G(x)整除。接收方接收到带校验位的信息，然后用G(x)整除。余数为0，则没有错误;反之则发生错误。

> 例：假设原始信息串为10110，CRC的生成多项式为G(x)=x^4+x+1，求CRC校验码
>
> （1）在原始信息位后面添0，假设生成多项式的阶为r，则在原始信息位后添加r个0，本题中，G(x)阶为4（阶通常指的是多项式的最高次项的次数，x的4次），则在原始信息串后加4个0，得到的新串为10110 0000作为被除数。
>
> （2）由多项式得到除数，多项中x的幂指数存在的位置1，不存在的位置0。本题中，x的幂指数为0,1,4的变量都存在（x的0次，x的1次，x的4次），而幂指数为2,3的不存在，因此得到串10011.
>
> （3）生成CRC校验码，将前两步得出的被除数和除数进行模2除法运算(即异或运算，同0分1，不进位也不借位的除法运算)。除法过程如下图所示。
>
> ![image-20250212211015745](%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84.assets/image-20250212211015745.png)
>
> 得到余数1111.注意:余数不足r，则余数左边用若干个0补齐。如求得余数为11，r=4，则补两个0得到0011。
>
> （4）生成最终发送信息串，将余数添加到原始信息后。上例中，原始信息为10110，添加余数1111后，结果为10110 1111。发送方将此数据发送给接收方。（5）接收方进行校验。接收方的CRC校验过程与生成过程类似，接收方接收了带校验和的帧后，用多项式G(x)来除（模2除法）。余数为0，则表示信息无错;否则要求发送方进行重传。
>
> 注意:收发信息双方需使用相同的生成多项式

3、海明码

 海明码:本质也是利用奇偶性来检错和纠错的检验方法，构成方法是在数据位之间的确定位置上插入k个校验位，通过扩大码距实现检错和纠错。设数据位是n位，校验位是k位，则n和k必须满足以下关系:2^k-1>=n+k。

示例：

求信息1011的海明码

（1）校验位的位数和具体的数据位的位数之间的关系

所有位都编号，从最低位编号，从1开始递增，校验位处于2的n(n=0 1 2...)……次方中，即处于第1,2,4,8,16,32位上，其余位才能填充真正的数据位，若信息数据为1011，则可知，第1,2,4位为校验位，第3,5,6,7位为数据位，用来从低位开始存放1011，得出信息位和校验位分布如下:

![image-20250212224216822](%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84.assets/image-20250212224216822.png)

（2）计算校验码

将所有信息位的编号都拆分成二进制表示如下图所示:

![image-20250212230448349](%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84.assets/image-20250212230448349.png)

上图中，7=4+2+1，表示7由第4位校验位(r2)和第2位校验位(r1)和第1位校验位(r0)共同校验，同理，第6位数据位6=4+2，第5位数据位5=4+1，第3位数据位3=2+1，前面知道，这些2的n次方都是校验位，可知，第4位校验位校验第765三位数据位，因此，第4位校验位r2等于这三位数据位的值异或，第2位和第1位校验位计算原理同上:
计算出三个校验位后，可知最终要发送的海明校验码为1010101.

（3）检错和纠错原理

接收方收到海明码之后，会将每一位校验位与其校验的位数分别异或，即做如下三组运算:

![image-20250212230705932](%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84.assets/image-20250212230705932.png)

如果是偶校验，那么运算得到的结果应该全为0，如果是奇校验，应该全为1（前面是计算校验码的时候，要取反），才是正确，假设是偶校验，且接收到的数据为1011101(第四位出错)，此时运算的结果为:

![image-20250212230724547](%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84.assets/image-20250212230724547.png)

这里不全为0，表明传输过程有误，并且按照r2r1r0排列为二进制100，这里指出的就是错误的位数，表示第100，即第4位出错，找到了出错位，纠错方法就是将该位逆转（因为是二进制）。
