## 一、计算机组成与结构

### 1、 计算机系统基础知识

#### 1.1、计算机硬件组成概述

计算机的基本硬件系统由**五大部件**组成：运算器、控制器、存储器、输入设备和输出设备（其中运算器和控制器被集成在CPU中，即中央处理器）

> - 运算器、控制器等部件被集成在一起统称为中央处理单元(Central Processing Unit CPU)。CPU是硬件系统的核心，用于数据的加工处理，能完成各种算术逻辑运算及控制功能。（电脑中最贵的，还有一个显卡，用于图像计算）
> - 存储器（这里包含了电脑中的所有储存器，包括内存和外存）是计算机系统中的记忆设备（用于存数据），分为内部存储器（内存）和外部存储器（磁盘）。前者速度高、容量小，一般用于临时存放程序、数据及中间结果（电脑突然断电重启，内存中未持久化到外存中的数据将会丢失）。而后者容量大、速度慢，可以长期保存程序和数据。
> - 输入设备和输出设备合称为外部设备(简称外设)，输入设备用于输入原始数据及各种命令，而输出设备则用于输出计算机运行的结果。

#### 1.2、中央处理器（CPU）

##### 1. CPU的功能（1、2、3为控制器功能 4为运算器功能，从如下可以看出控制机才是CPU的核心）：

1. 程序控制。CPU通过执行指令来控制程序的执行顺序，这是CPU的重要功能；
2. 操作控制。一条指令功能的实现需要若干操作信号配合来完成，CPU产生每条指令的操作信号并将操作信号送往对应的部件，控制相应的部件按指令的功能要求进行操作。
3. 时间控制。CPU对各种操作进行时间上的控制，即指令执行过程中操作信号的出现时间、持续时间及出现的时间顺序都需要进行严格控制。
4. 数据处理。CPU 通过对数据进行算术运算及逻辑运算等方式进行加工处理,数据加工处理的结果被人们所利用。所以，对数据的加工处理也是CPU最根本的任务。

此外，CPU还需要对系统内部和外部的中断（执行过程中，需要打断当前所做的事情，去干其他事情的时候即为中断，即被外部事物中断）、异常做出响应，进行相应的处理

##### 2.CPU的组成

CPU的组成：CPU主要由运算器、控制器、寄存器组（用于存数据，容量很小32位或64位，速度很快，比内存还要快）和内部总线（通过总线，将这些东西串起来）等部件组成。

- 运算器

由算术逻辑单元（ALU）、累加寄存器（AC）、数据缓冲寄存器（DR）和状态条件寄存器（PSW）组成，其执行所有的算术运算，如加减乘除；执行所有的逻辑运算并进行逻辑测试，如与、或、非、比较等。

1. 算术逻辑单元（ALU）：实现对数据的算术和逻辑运算。
2. 累加寄存器（AC）：运算结果或源操作数的存放区（如果是a+b=c，a操作数可以被存在算术逻辑区,ALU本身可以存一个源操作数，b操作数、c结果存储在累加寄存区中）
3. 数据缓冲寄存器（DR）：暂时存放内存的指令和数据（应该是运算时用到的）
4. 状态条件寄存器（PSW）：保存指令运行结果的条件码内容，如溢出标志、除数为0等。

- 控制器

由指令寄存器（IR）、程序计数器（PC）、地址寄存器（AR）、指令译码器（ID）组成，控制整个CPU的工作，最为重要。

指令寄存器（IR）：暂存CPU执行指令；根据PC通过指令的地址找到指令，将其进行存储。

程序计数器（PC）：存放下一个指令执行的地址；通过PC找到需要下一个执行操作的地址，来控制指令的操作顺序；（执行CPU指令时，在一个指令周期的过程中，首先需从内存读取要执行的指令，此时先要将指令的地址即PC的内容发送到地址总线上）

地址寄存器（AR）：保存当前CPU所访问的内存地址；

指令译码器（ID）：分析指令操作码（操作码用来分析这个指令是干什么的，是加法还是减法）；



CPU依据指令周期的不同阶段来区分二进制的指令和数据，因为在指令周期的不同阶段，指令会命令CPU分别去取指令或者数据。

> CPU的执行过程先是取指令（从PC中获取到指令的地址，再从主存中将指令取出来），然后通过ID分析这个指令是干什么的，是加法、减法还是移位，分析完成后，去进行执行，执行过程中，需要去取其中的数据，如a+b,需要从内存中将操作数a和b取出来。因此在取指令的时候会取出指令，执行的时候会取出数据。



#### 1.3 数据表示

##### 1. 进制转换

进制的表示: 二进制、十六进制，一般在题目中会给出中文说明，如果没给出，注意二进制符号为0b开头，一般表示为0b0011，十六进制符号为开头0x或结尾H，可表示为0x18F或18FH。(十六进制可表示0-15，其中10-15用A-F来表示，类似十进制每位上只能是0-10)。关于进制转换如下：

- R进制整数转十进制:位权展开（相加）法，用R进制数的每一位乘以R的n次方，n是变量，从R进制数的整数最低位开始，依次为0,1,2,3..累加。
  例如有6进制数5043，此时R=6，用6进制数的每一位乘以6的n次方，n是变量从6进制数的整数最低位开始(5043从低位到高位排列:3,4,0,5)，n依次为0,1,2,3，那么最终`5043=3*6^0+4*6^1+0*6^2+5*6^3=1107`.

- 十进制转R进制:十进制整数(除以R倒取余数)，用十进制整数除以R，记录每次所得余数，若商不为0，则继续除以R，直至商为0，而后将所有余数从下至上记录，排列成从左至右顺序，即为转换后的R进制数;
  例:有十进制数200，转换为6进制，此时R=6，将200/6，得商为33，余数为2;因为商不等于0，因此再将商33/6，得商为5，余数为3;再将5/6，得商为0，余数为5;此时商为0，将所有余数从下到上记录，得532。

- m进制转n进制:先将m进制转化为十进制数，再将十进制数转化为n进制数中间需要通过十进制中转，一般来说，两种进制都需要十进制来进行中转，但下面这种情况进制间可以直接转化:

  二进制转八进制:每三位二进制数转换为一位八进制数，二进制数位个数不是三的倍数，则在前面补0(原则是数值不变)，如二进制数01101有五位，前面补一个0就有六位，为001 101，每三位转换为一位八进制数，001=1,101=1+4=5，也即01101=15。
  二进制转十六进制:每四位二进制数转换为一位十六进制数，二进制数位个数不是四的倍数，则在前面补0，如二进制数101101有六位，前面补两个0就有八位，为0010 1101，每四位转换为一位十六进制数，0010=2,1101=13=D，也即101101=2D。

  类似此规律，二进制转2^5=32、2^6=64……都符合上面的规律。

##### 2.编码方式

**前置知识点：**

- 机器数:各种数值在计算机中表示的形式(最底层的存储方法)，其特点是使用二进制计数制，数的的符号用0和1表示，小数点则隐含，不占位置。机器数有无符号数和带符号数之分。无符号数表示正数，没有符号位。带符号数最高位为符号位，正数符号位为0，负数符号位为1。

- 定点表示法分为纯小数（定点小数）和纯整数两种，其中小数点不占存储位，而是按照以下约定:

  纯小数（定点小数）:约定小数点的位置在机器数的最高数值位之前。即1234就是0.1234。

  纯整数（定点整数）:约定小数点的位置在机器数的最低数值位之后。即1234就是1234。

- 真值:机器数对应的实际数值。



**关于原码、反码、补码、移码**

当真值为-45时，即机器对应的实际数值为-45时，带符号数右下列编码方式（注：正数的原码、反码、补码都是同一个）

**原码:**一个数的正常二进制表示，最高位表示符号，数值0的源码有两种形式+0(00000000)和-0(10000000)。-45对应原码为10101101。
**反码:**正数的反码即原码;负数的反码是在原码的基础上，除符号位外，其他各位按位取反。数值0的反码也有两种形式:+0(00000000)，-0(11111111)。-45对应反码为11010010
**补码:**正数的补码即原码;负数的补码是在原码的基础上，除符号位外，其他各位按位取反，而后末位+1，若有进位则产生进位。因此数值0的补码只有一种形式+0=-0=00000000（对于11111111在加1为产生进位，并且第9位上为1，因为是机器字长为8，所以第九位的1会被舍弃，不用管）。-45对应补码为11010011
**移码:**用作浮点运算的阶码，无论正数负数，都是将该原码的补码的首位(符号位)取反得到移码。-45对应移码为01010011



**关于各个码制的取值范围**

机器字长为n时各种码制表示的带符号数的取值范围(差别在于0的表示，原码和反码分+0和-0，补码只有一个0，即+0=-0=0，因此可以多表示一个）

![image-20250210223224346](%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84.assets/image-20250210223224346.png)

> 解释：若机器字长为n，即有n-1位表示数值，1位表示符号
>
> 对于原码，除符号位，数值为中可表示的数共有2^（n-1）个，包含0，最大数是2^(n-1) -1 ，最大值2^（n-1）是取不到，因为取到了最高的符号位就变了，可表示的数0也算在内，其最小也是同理，最大的数只能取到2^（n-1）-1，然后加上符号位。
>
> 对于补码，最小数比原码反码大1，是因为其+0=-0=0，而原码和反码的+0和-0是不一样的。
>
> 对于定点小数，在定点整数的基础上都除以2^（n-1）即可

例：若机器字长为8，45和-45的原码、反码、补码和移码如下所示

![image-20250210224642227](%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84.assets/image-20250210224642227.png)



**浮点数**

浮点数:表示方法为`N=F*2^E`，其中E称为阶码，F称为尾数。其类似于十进制的科学计数法，如`85.125=0.85125*10^2`，二进制如`101.011=0.101011*2^3`

在浮点数的表示中，阶码为带符号的纯整数，尾数为带符号的纯小数，要注意符号占最高位(正数0负数1)，其表示格式如下:

![image-20250211201845230](%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84.assets/image-20250211201845230.png)

很明显，与科学计数法类似，一个浮点数的表示方法不是唯一的，浮点数所能表示的数值范围由阶码确定，所表示的数值精度由尾数（到小数点后几位）确定。

尾数的表示采用规格化方法，也即带符号尾数的补码必须为1.0xxxx(负数)或者0.1xxxx(正数)，其中x可为0或1.

浮点数的运算:

- 对阶(使两个数的阶码相同，小阶向大阶看齐，较小阶码增加几位，尾数就右移几位)
- 尾数计算(相加，若是减运算，则加负数)
- 结果规格化(即尾数表示规格化，即带符号尾数要转换为1.0xxxx或0.1xxxx)

> 对阶过程不能让数值改变，为什么要小阶向大阶对齐呢
>
> 如：`0.10101*2^3` 和` 0.11101*2^5`两个数进行运算
>
> 因为大阶向小阶对齐的话，在保留5位小数的情况下，`0.11101*2^5`就会变成`0.11100*2^3`,高位两位丢失（出现首尾丢失），出现了精度丢失，并且丢的比较大。
>
> 但如果是小阶向大阶对齐的话，`0.10101*2^3`就变成`0.00101*2^5`，同样也出现了精度丢失（尾精度丢失），但是是低位精度丢失，影响不多
>
> 因此小阶向大阶，尾数右移，丢弃末尾，不影响大局。





**真题：**

![image-20250211224657067](%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84.assets/image-20250211224657067.png)

![image-20250211225400409](%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84.assets/image-20250211225400409.png)
