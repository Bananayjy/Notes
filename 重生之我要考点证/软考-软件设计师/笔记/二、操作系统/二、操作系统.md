## 二、操作系统

### 1、进程管理

#### 1.1 操作系统概述

**操作系统定义：**

能有效地组织和管理系统中的各种软/硬件资源，合理地组织计算机系统工作流程，控制程序的执行，并且向用户提供一个良好的工作环境和友好的接口。（PC上：Windows、Linux等移动端上：安卓、IOS等）

**操作系统两个重要作用：**

- 通过资源管理（软硬件管理，不止管理软件，也管理软件，操作系统属于系统软件，与系统软件相区分的是应用软件：如淘宝等）提供计算机系统的效率
- 改善人机界面向用户提供友好的工作环境（Dos、Linux一般采用命令行的方式）

**操作系统特征（4个）：**

- 并发性：对用户来说感觉是并行的（微观交替进行，并行是同一时刻一起执行），在操作系统中CPU是交替执行应用
- 共享性：操作系统中的资源是共享的
- 虚拟性：和设备管理有关，独占设备转换为共享资源
- 不确定性：异步性，同一个程序执行两边结果可能不一样

**操作系统功能：**

- 进程管理：实质上是对处理机（CPU）的执行“时间”进行管理，采用多道程序等技术将CPU的时间合理地分配给每个任务，主要包括进程控制、进程同步、进程通信和进程调度。
- 文件管理：主要包括文件存储空间管理、目录管理、文件的读/写管理和存取控制。
- 存储管理：存储管理是对主存储器（辅存管理就是文件管理）“空间”进行管理，主要包括存储分配与回收、存储保护、地址映射(变换)和主存扩充。
- 设备管理：实质是对硬件设备的管理，包括对输入/输出设备的分配、启(4)动、完成和回收。
- 作业管理：包括任务、界面管理、人机交互、图形界面、语音控制和虚拟现实等。

**操作系统分类：**

- 批处理操作系统: 不用人为操作，即一次处理100个，只需要设定一下程序，程序就会一个一个去处理。单道批处理（一个处理完才会处理下一个）和多道批处理(同时处理多个任务，主机与外设可并行)
- 分时操作系统:一个计算机系统与多个终端设备连接。将CPU的工作时间划分为许多很短的时间片，轮流（不能让一个长时间占用执行，否则其他就不能运行了）为各个终端的用户服务，感觉上，各个终端同时在使用该操作系统，对交互能力要求高。
- 实时操作系统:实时是指计算机对于外来信息能够以足够快的速度进行处理并在被控对象允许的时间范围内做出快速反应。实时系统对交互能力要求不高，但要求可靠性有保障。
- 网络操作系统:是使联网计算机能方便而有效地共享网络资源，为网络用户提供各种服务的软件和有关协议的集合。三种模式:集中模式（有个集中的计算器来共享）、客户端/服务器模式（即C/S）、对等模式（PPP，整个网络中计算机都是平等的，既可以作为客户端，也可以作为服务器）。
- 分布式操作系统：（网络操作系统的升级，区别就是网络操作系统中的各个计算机都处于一个网络中），分布式计算机系统是由多个分散的计算机经连接而成的计算机系统，系统中的计算机无主、次之分，任意两台计算机可以通过通信交换信息。
- 微型计算机操作系统:（我们生活中常用的）简称微机操作系统，常用的有Windows、Mac OS、Linux.

**嵌入式操作系统特点**

嵌入式操作系统：嵌入到智能设备中的系统。（通俗）

- 微型化。从性能和成本角度考虑，希望占用的资源和系统代码量少，如内存少、字长短、运行速度有限、能源少(用微小型电池)。（像PC端中Windows系统的话，就需要4GB左右大小，很大）
- 可定制。从减少成本和缩短研发周期考虑，要求嵌入式操作系统能运行在不同的微处理器平台上，能针对硬件变化（不同设备硬件不同，不像PC那么固定，只有CPU、内存……构成，如空调的话就需要制冷机等）进行结构与功能上的配置，以满足不同应用需要。
- 实时性。嵌入式操作系统主要应用于过程控制、数据采集、传输通信、多媒体信息及关键要害领域需要迅速响应的场合，所以对实时性要求较高。
- 可靠性。系统构件、模块和体系结构必须达到应有的可靠性，对关键要害应用还要提供容错和防故障措施。
- 易移植性。为了提高系统的易移植性，通常采用硬件抽象层和板级支撑包的底层设计技术

嵌入式系统初始化过程按照自底向上、从硬件到软件的次序依次为:片级初始化（芯片级别的初始化）→板级初始化（板上各种外设吃刷）→系统初始化（操作系统初始化）。个人PC的启动也是有启动顺序：硬件启动->BIOS(烧在主板上的固化程序)->系统初始化

#### 1.2 进程组成和状态

**进程组成：**

- 进程控制块PCB（process controller block唯一标志）
- 程序（描述进程要做什么）
- 数据（存放进程执行时所需数据）

**三态图：**进程三态之间转换如左图所示（右侧五态图不要求掌握）

![image-20250227230830476](%E4%BA%8C%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20250227230830476.png)

- 运行态：需要CPU资源进行运行
- 就绪态：除了CPU，其他需要的资源都有了
- 阻塞：除了CPU，还缺其他条件（如外设需要传输数据，即IO操作，速度比较慢，需要把CPU让出去）

扩展：

- 新建：新建一个进程后，还没有分配到就绪队列中
- 终止：运行完了，还要释放一些资源



> 真题：AC
>
> ![image-20250303235018238](%E4%BA%8C%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20250303235018238.png)



#### 1.3 前驱图

用来表示哪些任务可以并行执行，哪些任务之间有顺序关系，具体如下图:可知，ABC可以并行执行，但是必须ABC都执行完后，才能执行D，这就确定了两点:任务间的并行、任务间的先后顺序

![image-20250303235112828](%E4%BA%8C%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20250303235112828.png)



#### 1.4 进程资源图

用来表示进程和资源之间的分配和请求关系，，如下图所示

![image-20250303235323848](%E4%BA%8C%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20250303235323848.png)

- P代表进程，R代表资源，R方框中有几个圆球就表示有几个这种资源，在上图中，R1指向P1，表示R1有一个资源已经分配给了P1，P1指向R2，表示P1还需要请求一个R2资源才能执行，
- 阻塞节点:某进程所请求的资源已经全部分配完毕，无法获取所需资源，该进程被阻塞了无法继续。如上图中P2。
- 非阻塞节点:某进程所请求的资源还有剩余，可以分配给该进程继续运行。如上图中P1、P3。
- 当一个进程资源图中所有进程都是阻塞节点时，即陷入死锁状态



真题：CB

![image-20250304222352901](%E4%BA%8C%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20250304222352901.png)![image-20250304222413820](%E4%BA%8C%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20250304222413820.png)



#### 1.5 进程同步或互斥

一些概念：

- 临界资源:各进程间需要以互斥方式对其进行访问的资源。

- 临界区:指进程中对临界资源实施操作的那段程序。本质是一段程序代码。
- 互斥:某资源(即临界资源)在同一时间内只能由一个任务单独使用，使用时需要加锁，使用完后解锁才能被其他任务使用。如打印机。
- 同步:多个任务可以并发执行，只不过有速度上的差异，在一定情况下停下等待，不存在资源是否单独或共享的问题。如A—>B,可以选择自行车和汽车，但是汽车先到要等待自行车一起到了再去做后面的事情。
- 互斥信号量:对临界资源采用互斥访问，使用互斥信号量后其他进程无法访问，初值为1。
- 同步信号量:对共享资源的访问控制（有数量上限，需要控制），初值一般是共享资源的数量



对于信号量的操作：

S是信号量（包括互斥信号量和同步信号量），当S大于0表示资源的个数，当S小于0表示有多少个进程等待这个资源。

- P操作：申请资源，S = S - 1,若S>0,则执行P操作的进程继续执行；若S<0,则置该进程为阻塞状态（因为无可用资源），并将其插入阻塞队列。
- V操作：释放资源，S=S+1，若S>0，则执行V操作的进程继续执行:若S<=0，则从阻塞状态唤醒一个进程，并将其插入就绪队列(此时因为缺少资源被P操作阻塞的进程可以继续执行)，然后执行V操作的进程继续。

![image-20250304223622723](%E4%BA%8C%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20250304223622723.png)





金典问题：

![image-20250304224632284](%E4%BA%8C%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20250304224632284.png)

互斥信号量需要配套，一一对应，即 有P就要V

同步信号量没事



真题：

![image-20250304224610355](%E4%BA%8C%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20250304224610355.png)



#### 1.6 进程调度

##### 1. 进程调度方式

进程调度方式是指当有更高优先级的进程到来时如何分配CPU资源。分为可剥夺和不可剥夺两种，可剥夺指当有更高优先级进程到来时，强行将正在运行进程的CPU分配给高优先级进程;不可剥夺是指高优先级进程必须等待当前进程自动释放CPU。

##### 2.三级调度

在某些操作系统中，一个作业从提交到完成需要经历高、中、低三级调度。

(1)高级调度。高级调度又称“长调度”、“作业调度”或“接纳调度”，它决定处于输入池中的哪个后备作业可以调入主系统做好运行的准备，成为一个或一组就绪进程。在系统中一个作业（一组进程，一组完整的程序）只需经过一次高级调度。

(2)中级调度。中级调度又称“中程调度”或“对换调度”，它决定处于交换区中的哪个就绪进程可以调入内存（放入就绪队列中），以便直接参与对CPU的竞争（还没有获取CPU）。

(3)低级调度。低级调度又称“短程调度”或“进程调度”它决定处于内存中的哪个就绪进程可以占用CPU。低级调度是操作系统中最活跃、最重要的调度程序，对系统的影响很大

##### 3.调度算法

通过调度算法，决定哪一个进程来使用CPU。属于低级调度中的算法。

- 先来先服务FCFS：先到达的进程优先分配CPU。用于宏观调度。
- 时间片轮转（分时系统）:分配给每个进程CPU时间片，轮流使用CPU，每个进程时间片大小相同，很公平，用于微观调度。
- 优先级调度:每个进程都拥有一个优先级，优先级大的先分配CPU。
- 多级反馈调度：时间片轮转和优先级调度结合而成，设置多个就绪队列1,2,3...n，每个队列分别赋予不同的优先级，分配不同的时间片长度:新进程先进入队列1的末尾，按FCFS原则，执行队列1的时间片;若未能执行完进程，则转入队列2的末尾，如此重复。（不同队列通过优先级排列，同一个队列通过时间片轮转获取CPU，不同优先级队列中的时间片设置大小不一样）

![image-20250324210052307](%E4%BA%8C%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20250324210052307.png)





#### 1.7 死锁

##### 1.概念

当一个进程在等待永远不可能发生的事件时，就会产生死锁，若系统中有多个进程处于死锁状态，就会造成系统死锁。

##### 2.死锁产生的四个必要条件

- 资源互斥
- 每个进程占有资源并等待其他资源
- 系统不能剥夺进程资源
- 进程资源图是一个环路（循环）

##### 3.解决死锁

死锁产生后解决措施是打破四大条件，有下列方法:

- 死锁预防：采用某种策略限制并发进程对于资源的请求，破坏死锁产生的四个条件之一使系统任何时刻都不满足死锁的条件。
- 死锁避免：一般采用银行家算法来避免，银行家算法，就是提前计算出一条不会死锁的资源分配方法，才分配资源，否则不分配资源，相当于借贷，考虑对方还得起才借钱，提前考虑好以后，就可以避免死锁。
- 死锁检测：允许死锁产生，但系统定时运行一个检测死锁的程序，若检测到系统中发生死锁，则设法加以解除。
- 死锁解除：即死锁发生后的解除方法，如强制剥夺资源，撤销进程等。
- 死锁资源计算：系统内有n个进程，每个进程都需要R个资源，那么其发生死锁的最大资源数为`n*(R-1)`(即n个进程，都持有r-1个资源，等待1个资源)。其不发生死锁的最小资源数为`n*(R-1)+1`（有任何一个进程获取R个资源，即可打破死锁）



##### 4.真题

![image-20250324211710321](%E4%BA%8C%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20250324211710321.png)

B

BD

![image-20250324212850898](%E4%BA%8C%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20250324212850898.png)

DB



#### 1.8 线程

传统的进程有两个属性:可拥有资源的独立单位（PCB)；可独立调度和分配的基本单位。

引入线程的原因是进程在创建、撤销和切换中，系统必须为之付出较大的时空开销，故在系统中设置的进程数目不宜过多，进程切换的频率不宜太高，这就限制了并发程度的提高。引入线程后，将传统进程的两个基本属性分开，线程作为调度和分配的基本单位，进程作为独立分配资源的单位。用户可以通过创建线程来完成任务，以减少程序并发执行时付出的时空开销。

线程是进程中的一个实体（不拥有资源，资源都是进程拥有的，线程共享进程的资源），是被系统独立分配和调度的基本单位（TCB）。上不拥有资源，只拥有一点运行中必不可少的资源(如程序计数器.、一组寄存器和栈)，它可与同属一个进程的其他线程共享进程所拥有的全部资源，例如进程的公共数据、全局变量、代码、文件等资源，但不能共享线程独有的资源如线程的栈指针等标识数据。



### 2、存储管理

#### 2.1 分区存储管理

所谓分区存储组织，就是整存然后再执行。有三种分区方式：

- 固定分区: 静态分区方法，将主存分为若干个固定的分区，将要运行的作业装配进去，由于分区固定，大小和作业需要的大小不同，会产生内部碎片。如将8GM的主存，分为若干分区，每个分区大小100MB，如果此时的程序运行需要内存大小是50MB，那么就会有50MB的碎片。

- 可变分区:动态分区方法，主存空间的分区是在作业转入时划分，正好划分为作业需要的大小，这样就不存在内部碎片，但容易将整片主存空间切割成许多块，会产生外部碎片（如进程需要内存分别是10MB、1MB、5MB，那么1MB回收之后，中间就会有1MB的碎片，并且可能因为太小无法得到分配）。

  > 系统分配可变分区算法有很多，假设现在需要分配9KB空间，对于不同的算法的结果介绍如下：
  >
  > ![image-20250324214722509](%E4%BA%8C%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20250324214722509.png)
  >
  > 循环首次适应法：找到作业3后，在放入作业4后，会从作业3接着往后找，只有到结尾，才会从头往下找。

- 可重定位分区:可以解决碎片问题，移动所有已经分配好的区域，使其成为个连续的区域，这样其他外部细小的分区碎片可以合并为大的分区，满足作业要求。只在外部作业请求空间得不到满足时进行。



#### 2.2 分页存储管理

##### 1.出现分页存储的原因（原理）

前面的分区存储管理，不管是静态（内存提前分配好）还是动态（进程来的时候分配），其都属于整存，即进程需要多少就给多少，但是当内存空间小于进程需要的空间的时候，即内存不够的时候，如果使用分区存储去进行整存的时候就无法进行存储了。所以，一般计算机中都采用分页存储管理或者分段存储管理，即不需要一次性将进程需要的空间全部分配过去，可以利用程序的局部性原理（即一个10GB的进程，不是一下子就需要使用10GB中的所有东西），一页一页往里面调，一条一条指令往下执行（下一个需要执行的指令，调入进来即可）

分页存储管理本身属于静态、固定的分配方法，因此会有碎片（最后一页中存在碎片，即程序的大小不是内存内存中页的整数倍），即如果内存有4GB，一页有4KB，那么会将进程也分为一个个页框/页帧，大小为4KB，当执行这个程序的时候，就按照执行顺序一页一页往内存中去调。

优点：利用率高，碎片小，分配及管理简单

缺点：增加系统开销，可能产生抖动现象（内存中有10页，外存中有20个页框，外存需要往内存中一个一个调，按道理来说内存中的页越多，往里面调的次数越少，但是如果算法选的不好，反而会增加往里面调的次数，即为抖动）

##### 2.组成

![image-20250324224733477](%E4%BA%8C%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20250324224733477.png)

逻辑页分为页号和页内地址，页内地址就是物理偏移地址，而页号与物理块号并非按序对应的，需要查询页表，才能得知页号对应的物理块号，再用物理块号加上偏移地址才得出了真正运行时的物理地址。

假设主存大小为4GB，每个页的大小为4KB，那么一共有2的20次页，即上述页号就占20位，有多少个页，就有多少个页号。页内地址和页的大小相关，即在页中的位置。



##### 3.逻辑地址（主存）和物理地址（外存）的转换

页内地址不变，因为页内地址就是页的大小，主存中页的大小和外存中页框的大小是一样的。逻辑地址中页号和物理地址中的块号（页号）需要根据页表去查询对应的映射关系。

![image-20250324225616663](%E4%BA%8C%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20250324225616663.png)

##### 4.页面置换算法

![image-20250324225731382](%E4%BA%8C%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20250324225731382.png)

##### 5.快表（快速页表）

是一块小容量的相联存储器，存储了慢表中访问最频繁的页号和物理块号的映射关系，由快速存储器组成，按内容访问，速度快，并且可以从硬件上保证按内容并行查找，一般用来存放当前访问最频繁的少数活动页面的页号。快表是将页表存于Cache中，慢表是将页表存于内存上。慢表需要访问两次内存才能取出页（第一次根据慢表获取映射关系，第二次去内存中获取数据），而快表是访问一次Cache和一次内存（一次Cache，通过快表找到对应关系，从内存中获取内容），因此更快。



##### 6.真题

![image-20250324230310255](%E4%BA%8C%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20250324230310255.png)

![image-20250324230324020](%E4%BA%8C%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20250324230324020.png)



#### 2.3 分段存储管理



#### 2.4 段页式存储管理





### 3、设备管理

#### 3.1 设备管理概述

#### 3.2 I/O软件

#### 3.3 设备管理技术

### 4、文件管理

#### 4.1 文件管理概述

#### 4.2 索引文件结构

#### 4.3 文件目录

#### 4.4 文件存储空间管理



