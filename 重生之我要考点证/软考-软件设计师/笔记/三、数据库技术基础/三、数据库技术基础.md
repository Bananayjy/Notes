## 三、数据库技术基础

### 1、数据库基本概念

#### 1.1 数据库系统

**数据:**是数据库中存储的基本对象，是描述事物的符号记录。

**数据的种类**：文本、图形、图像、音频、视频、学生的档案记录、货物的运输情况等。

**数据库DB:** 是长期存储在计算机内、有组织的、可共享的大量数据的集合

**数据库的基本特征: **

1、数据按一定的数据模型组织、描述和存储；

2、可为各种用户共享;

3、冗余度较小;

4、数据独立性较高;

5、易扩展。

**数据库系统(DBS)：**是一个采用了数据库技术，有组织地、动态地存储大量相关数据，方便多用户访问的计算机系统。其由下面四个部分组成:

- 数据库(统一管理、长期存储在计算机内的，有组织的相关数据的集合)
- 硬件(构成计算机系统包括存储数据所需的外部设备)
- 软件(操作系统、数据库管理系统及应用程序)
- 人员(系统分析和数据库设计人员、应用程序员、最终用户、数据库管理员
  DBA)

**数据库管理系统(DBMS):** 属于数据库系统中的软件，如navicat，实现对共享数据有效的组织、管理和存取。包括数据定义、数据库操作、数据库运行管理、数据的存储管理、数据库的建立和维护等。



#### 1.2 三级模型-两级映像

![image-20250327204325515](%E4%B8%89%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80.assets/image-20250327204325515.png)

（从下往上看，越往上越和用户/应用程序相关，如java使用mysql-j驱动操作mysql数据库，越往下，和数据库的存储相关）

三级模式：

- 内模式:管理如何存储物理的数据，对应具体物理存储文件（即如何存储数据）。
- 模式:又称为概念模式，就是我们通常使用的基本表，根据应用、需求将物理数据划分成一张张表。
- 外模式:对应数据库中的视图这个级别，将表进行一定的处理后再提供给用户使用。（将一些表进行查询或者组合返回给用户进行查看 ）

两级映像：目的是当数据库中发生修改的时候（如数据发生修改），应用程序不需要修改（不需要改代码）。即防止内模式修改（即数据库有一点变动）的时候，就需要去修改概念模式和外模式内容，这样是不好的，如果有映射，只需要概念模式和内模式的映射即可。

- 外模式一模式映像:是表和视图之间的映射，存在于概念级和外部级之间，若表中数据发生了修改，只需要修改此映射，而无需修改应用程序。保证看逻辑独立性。
- 模式一内模式映像:是表和数据的物理存储之间的映射存在于概念级和内部级之间，若修改了数据存储方式，只需要修改此映射，而不需要去修改应用程序。保证了物理独立性。



#### 1.3 数据库设计

![image-20250327205323655](%E4%B8%89%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80.assets/image-20250327205323655.png)

- 需求分析:即分析数据存储的要求（需要存储哪些东西），产出物有数据流图数据字典、需求说明书
- 概念结构设计:就是设计E-R图，即实体-联系图，与物理无关，说明有哪些实体，实体有哪些属性。（如学生一个实体，其属性有学号、姓名、年龄）
- 逻辑结构设计:将E-R图，转换成关系模式，也即转换成实际的表和表中的列属性，这里要考虑很多规范化的东西。
- 物理设计:根据生成的表等概念，生成成物理数据库



> 真题：
>
> ![image-20250327205806876](%E4%B8%89%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80.assets/image-20250327205806876.png)
>
> 1、C
>
> 2、A
>
> 3、A
>
> 4、C



#### 1.4 数据模型

- 关系模型是二维表的形式表示的实体-联系模型，是将实体-联系模型转换而来的，经过开发人员设计的;
- 概念模型是从用户的角度进行建模的，是现实世界到信息世界的第一抽象是真正的实体-联系模型。
- 网状模型表示实体类型及其实体之间的联系，一个事物和另外几个都有联系形成一张网。
- 面向对象模型是采用面向对象的方法设计数据库，以对象为单位，每个对象包括属性和方法，具有类和继承等特点。
- 数据模型三要素:数据结构(所研究的对象类型的集合)、数据操作（对数据库中各种对象的实例允许执行的操作的集合)、数据的约束条件(一组完整性规则的集合)。



#### 1.5 E-R模型

##### 1.概述

用E-R图来描述概念数据模型，世界是由一组称作实体的基本对象和这些对象之间的联系构成的。
在E-R模型中，使用椭圆表示属性(一般没有)、长方形表示实体（人、物，名次）、菱形表示联系（动词），联系的两端要填写联系类型，示例如下图:

![image-20250327211414863](%E4%B8%89%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80.assets/image-20250327211414863.png)

##### 2.属性

**实体:**客观存在并可相互区别的事物。可以是具体的人、事、物或抽象概念，如人、汽车、图书、账户、贷款。

- 弱实体（长方形中加两条竖杠）和强实体:弱实体依赖于强实体的存在而存在（弱实体和强实体通过圆圈链接，如员工和经理）。
- 实体集:具有相同类型和共享相同属性的实体的集合，如学生、课程。

**属性:** 实体所具有的特性。
**属性分类**:简单属性（单个，年龄）和复合属性（由多个简单属性组成，如家庭住址，国家哪个省哪个市）;单值属性（人的年龄只有一个）和多值属性（人的电话号码可以多个）;NULL属性;派生属（可以有其他属性计算而来，如年龄可以通过出生日期计算得到）
性。

- **域:**属性的取值范围称为该属性的域。
- **码(key):**唯一标识实体的属性集。

**联系:**现实世界中事物内部以及事物之间的联系:，在E-R图中反映为实体内部的联系和实体之间的联系，
**联系类型:**一对一1:1、一对多1:N、多对多M:N.



##### 3. 两个以上实体联系

![image-20250327213209162](%E4%B8%89%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80.assets/image-20250327213209162.png)



#### 1.6 关系模型

##### 1.概述

关系模型中数据的逻辑结构是一张二维表，由行列组成。用表格结构表达实体集，用外键标识实体间的联系。如下图:

![image-20250327213501078](%E4%B8%89%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80.assets/image-20250327213501078.png)

优点:建立在严格的数学概念基础上;概念单一、结构简单、清晰，用户易懂易用;存取路径对用户透明，从而数据独立性、安全性好，简化数据库开发工作。缺点:由于存取路径透明，查询效率往往不如非关系数据模型，



##### 2.E-R模型转换为关系模型方法

E-R模型转换为关系模型:每个实体（必须是强实体）都对应一个关系模式;联系分为三种：

- 1:1联系中，联系可以放到任意的两端实体中，作为一个属性(要保证1:1的两端关联)，也可以转换为一个单独的关系模式（一般不这样做）;

- 1:N的联系中，联系可以单独作为一个关系模式，也可以在N端中加入1端实体的主键;

  如现在有员工（学号、姓名）、部门（部门编号、名称），员工和部门是N:1的关系，那么在员工中加上部门编号的属性。

- M:N的联系中，联系必须作为一个单独的关系模式，其主键是M和N端的联合主键。

> 真题：
>
> ![image-20250327214802331](%E4%B8%89%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80.assets/image-20250327214802331.png)
>
> C A
>
> ![image-20250327215140833](%E4%B8%89%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80.assets/image-20250327215140833.png)



#### 1.7 关系代数

关系代数，就是关系模型之间的代数运算，关系模式就是二维表，所以就是表和表之间的逻辑运算。

相关的关系代数有如下几种：

- 并：结果是两张表中所有记录数合并，相同记录只显示一次，
- 交：结果是两张表中相同的记录。
- 差：S1-S2，结果是S1表中有而S2表中没有的那些记录。

![image-20250331210128569](%E4%B8%89%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80.assets/image-20250331210128569.png)

- 笛卡尔积：`s1*s2`，产生的结果包括S1和S2的所有属性列，并且S1中每条记录依次和S2中所有记录组合成一条记录，最终属性列为S1+S2属性列，记录数为S1*S2记录数。
- 投影：实际是按条件选择某关系模式中的某列，列也可以用数字表示
- 选择：实际是按条件选择某关系模式中的某条记录。（如Sno = No0003，结果如下面所示）

![image-20250331210504495](%E4%B8%89%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80.assets/image-20250331210504495.png)

- 自然连接的结果显示全部的属性列，但是相同属性列只显示一次，显示两个关系模式中属性相同且值相同的记录。

  设有关系R、S如下左图所示，自然连接结果如下右图所示：

![image-20250331212454287](%E4%B8%89%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80.assets/image-20250331212454287.png)



真题：

![image-20250331213554697](%E4%B8%89%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80.assets/image-20250331213554697.png)

> B D
>
> 说明：
>
> 投影：π
>
> 选择：O
>
> 关系表达式中数字不需要加引号





### 2、规范化和并发控制

#### 2.1 函数依赖

给定一个X，能唯一确定一个Y就称X确定Y，或者说Y依赖于X，例如Y=X*X函数。写作：X --> Y

函数依赖又可扩展以下两种规则:

- 部分函数依赖:A可确定C，(A,B)也可确定C，(A,B)中的一部分(即A)可以确定C，称为部分函数依赖。
- 传递函数依赖:当A和B不等价时，A可确定B，B可确定C，则A可确定C，是传递函数依赖;若A和B等价，则不存在传递，直接就可确定C

![image-20250331214707063](%E4%B8%89%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80.assets/image-20250331214707063.png)



函数依赖的公理系统（Armstrong）

设关系模式R<U，F>,U是关系模式R的属性全集（即表中的属性），F是关系模式R的一个函数依赖集（即前面讲的A决定B）。对于R<U，F>来说有以下的:

![image-20250331214825664](%E4%B8%89%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80.assets/image-20250331214825664.png)

> 第一个：如果Y包含于X包含于U，那么X决定Y，因为X范围比Y大，所以X确定下来后，Y就确定了
>
> 其他可以自己推。

#### 2.2 键与约束范式

键/码：

- 超键:能唯一标识此表的属性的组合。

  eg：学生表，有学号、姓名、年龄，能够唯一标识的属性组合即超键，即只要包含学号就可以，如学号、姓名可以表示唯一，学号、年龄也可以表示唯一，单独一个学号也可以表示超键

- 候选键:超键中去掉冗余的属性，剩余的属性就是候选键

  eg：上述学生表中，只要学号就可以唯一标识，因此学号就是候选键

- 主键：任选一个候选键（可能有多个，比如加一个身份证号），即可作为主键。

  候选键有多个的时候。

- 外键:其他表中的主键。

  eg：学生表中有一个字段系id，系id是系表的主键，该主键就是外键

- 主属性:候选键内的属性为主属性，其他属性为非主属性。

  eg：学生表，有学号、姓名、年龄、身份证号，学号和身份证号都可以作为主键，即两个都是主属性，其他属性都是非主属性。



约束范式：

- 实体完整性约束:即主键约束主键值不能为空，也不能重复
- 参照完整性约束:即外键约束，外键必须是其他表中已经存在的主键的值或者为空(这里为空，代表可能其他表还没建立或者还没有数据的情况)。
- 用户自定义完整性约束:自定义表达式约束，如设定年龄属性的值必须在0到150之间。



#### 2.3 模式分解

**第一范式1NF：**

![image-20250331221221356](%E4%B8%89%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80.assets/image-20250331221221356.png)

即每个属性必须是简单属性，不能是复合属性（如薪资/月）。

![image-20250331221345063](%E4%B8%89%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80.assets/image-20250331221345063.png)

这张表包含了三块内容，学生的内容、课程的内容和系的内容

依赖关系如下所示（上述有错误）：

- 学号 --> 学生姓名
- 学号 --> 所在系
- 学号 --> 课程号
- 学号 + 课程号 --> 成绩
- 所在系 --> 系主任姓名

这里的主键是联合主键，即学号 + 课程号，这两个可以唯一标识一条记录。

首先其是不满足**第二范式**的，第二范式的相关内容如下所示：

**第二范式定义**：如果关系R属于1NF，且每一个非主属性完全函数依赖于任何一个候选码，则R属于2NF；
通俗地说，2NF就是在1NF的基础上，表中的每一个非主属性不会依赖复合主键中的某一个列（即不存在部分依赖，即A+B->C,A->C这种情况）。按照定义，上面的学生表就不满足2NF，因为学号 --> 学生姓名；学号 --> 所在系；学号 --> 课程号；所在系 --> 系主任姓名。注意：单主键一定是满足第二范式的（部分依赖一定要主键有多个属性），其目的就是消除部分依赖。

将学生表分解为（此时这两张表都符合第二范式）:

- 学生(学号,学生姓名,系编号,系名,系主任)
- 选课(学号,课程号,成绩)。每张表均属于2NF。

但是上面这种分发，还是不满足**第三范式**，第三范式主要用于消除传递依赖

**第三范式定义**：在满足1NF的基础上，表中不存在非主属性对码的传递依赖；

继续上面的实例，学生关系模式就不属于3NF，因为学生无法直接决定系主任和系名，是由学号->系编号，再由系编号->系主任，系编号->系名，因此存在非主属性对主属性的传递依赖，

将学生表进一步分解为（每张表都属于3NF）:

- 学生(学号，学生姓名，系编号)
- 系名，系主任)系(系编号，
- 选课(学号,课程号,成绩)

第四范式、第五范式……



![image-20250331230203244](%E4%B8%89%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80.assets/image-20250331230203244.png)



真题：

![image-20250331231728106](%E4%B8%89%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80.assets/image-20250331231728106.png)

> 解题思路：
>
> 1、未在右边出现过的属性，肯定是候选键之一，因为其无法被推导出来，因此可以确定A、D为候选键。然后可以判断出ABD、ACD都可以推导出所有属性，因此第一个空选C。因为有两个候选键，并且两个候选键中的属性都是非主属性，因此第二个空选择A。
>
> 2、未在右边出现过的属性，肯定是候选键之一，因此既定EM,然后发现可以通过EM确定所有的属性，因此主键为EM，因为E->N,M->L,存在非主属性对主属性的部分依赖，所以不满足第二范式，所以选A、D





#### 2.4 并发控制

#### 2.5 封锁协议







### 3、数据库新技术

#### 3.1 数据库安全

#### 3.2 分布式数据库

#### 3.3 数据仓库

#### 3.4 反规范化技术

#### 3.5 大数据

#### 3.6 SQL语言