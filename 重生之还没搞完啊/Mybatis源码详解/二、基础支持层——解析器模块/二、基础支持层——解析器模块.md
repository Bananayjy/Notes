# 二、基础支持层——解析器模块

## 1、前言

解析器模块主要功能：

- 对 [XPath](http://www.w3school.com.cn/xpath/index.asp) （XPath 是一门在 XML 文档中查找信息的语，XPath 可用来在 XML 文档中对元素和属性进行遍历，XPath 是 W3C XSLT 标准的主要元素，并且 XQuery 和 XPointer 都构建于 XPath 表达之上）进行封装，为 MyBatis 初始化时解析 `mybatis-config.xml` 配置文件以及映射配置文件提供支持。
- 为处理动态 SQL 语句中的占位符提供支持

相关实现内容位于`parsing包`下

![image-20250112165354939](%E4%BA%8C%E3%80%81%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82%E2%80%94%E2%80%94%E8%A7%A3%E6%9E%90%E5%99%A8%E6%A8%A1%E5%9D%97.assets/image-20250112165354939.png)



## 2、相关内容

### 2.1 XPathParser

#### 1. 功能：

`org.apache.ibatis.parsing.XPathParser` ，基于 Java XPath 解析器，用于解析 MyBatis `mybatis-config.xml` 和 `**Mapper.xml` 等 XML 配置文件。

#### 2. 属性

关于XPathParser的属性如下所示

![image-20250115185258159](%E4%BA%8C%E3%80%81%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82%E2%80%94%E2%80%94%E8%A7%A3%E6%9E%90%E5%99%A8%E6%A8%A1%E5%9D%97.assets/image-20250115185258159.png)

- document （XML Document 对象）

  xml文件被解析后，生成的 `org.w3c.dom.Document` 对象。

- validation（是否校验标志）

  是否需要校验 XML 

- entityResolver（XML 实体解析器）

  `org.xml.sax.EntityResolver` 对象，XML 实体解析器。默认情况下，对 XML 进行校验时，会基于 XML 文档开始位置指定的 DTD 文件或 XSD 文件来进行解析。如解析 `mybatis-config.xml` 配置文件时，会加载 `http://mybatis.org/dtd/mybatis-3-config.dtd` 这个 DTD 文件。但是，如果每个应用启动都从网络加载该 DTD 文件，势必在弱网络下体验非常下，甚至说应用部署在无网络的环境下，还会导致下载不下来，那么就会出现 XML 校验失败的情况。所以，在实际场景下，MyBatis 自定义了 EntityResolver 的实现，达到使用本地 DTD 文件，从而避免下载网络 DTD 文件的效果。详细解析，见 XMLMapperEntityResolver 相关内容。

- variables（变量 Properties 对象）

  变量 Properties 对象，用来替换需要动态配置的属性值,例如：

  ```xml
  <dataSource type="POOLED">
      <property name="driver" value="${driver}"/>
      <property name="url" value="${url}"/>
      <property name="username" value="${username}"/>
      <property name="password" value="${password}"/>
  </dataSource>
  ```

  `variables` 的来源，即可以在常用的 Java Properties 文件中配置，也可以使用 MyBatis `<property />` 标签中配置

  ```xml
  <properties resource="org/mybatis/example/config.properties">
    <property name="username" value="dev_user"/>
    <property name="password" value="F2Fa3!33TYyg"/>
  </properties>
  ```

  这里配置的 `username` 和 `password` 属性，就可以替换上面的 `${username}` 和 `${password}` 这两个动态属性。（具体实现爱你参考`PropertyParser#parse(String string, Properties variables)` 方法）

- xpath（Java XPath 对象）

  `javax.xml.xpath.XPath` 对象，用于查询 XML 中的节点和元素（相关使用：[Java XPath 解析器 - 解析 XML 文档](https://www.yiibai.com/java_xml/java_xpath_parse_document.html)  ）

  

#### 3. 构造方法

关于XPathParser的构造器有16个

![image-20250115191514438](%E4%BA%8C%E3%80%81%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82%E2%80%94%E2%80%94%E8%A7%A3%E6%9E%90%E5%99%A8%E6%A8%A1%E5%9D%97.assets/image-20250115191514438.png)

选一个入参InputStream来分析

```java
public XPathParser(InputStream inputStream, boolean validation, Properties variables, EntityResolver entityResolver) {
    commonConstructor(validation, variables, entityResolver);
    this.document = createDocument(new InputSource(inputStream));
}
```

首先会调用公共的方法commonConstructor，其源码如下所示

```java
private void commonConstructor(boolean validation, Properties variables, EntityResolver entityResolver) {
    this.validation = validation;
    this.entityResolver = entityResolver;
    this.variables = variables;
    // 通过工厂对象创建Java XPath 对象
    XPathFactory factory = XPathFactory.newInstance();
    this.xpath = factory.newXPath();
}
```

然后会调用createDocument方法，将 通过输入流传递进来的XML 文件解析成 Document 对象，其源码如下所示

```java
private Document createDocument(InputSource inputSource) {
    // important: this must only be called AFTER common constructor
    try {
        // 创建 DocumentBuilderFactory 对象
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);
        // 根据validation对象设置是否需要验证XML
        factory.setValidating(validation);

        factory.setNamespaceAware(false);
        factory.setIgnoringComments(true);
        factory.setIgnoringElementContentWhitespace(false);
        factory.setCoalescing(false);
        factory.setExpandEntityReferences(false);

        // 创建 DocumentBuilder 对象
        DocumentBuilder builder = factory.newDocumentBuilder();
        // 设置实体解析器
        builder.setEntityResolver(entityResolver);
        // 设置错误处理器
        builder.setErrorHandler(new ErrorHandler() {
            @Override
            public void error(SAXParseException exception) throws SAXException {
                throw exception;
            }

            @Override
            public void fatalError(SAXParseException exception) throws SAXException {
                throw exception;
            }

            @Override
            public void warning(SAXParseException exception) throws SAXException {
                // NOP
            }
        });
        // 解析 XML 文件
        return builder.parse(inputSource);
    } catch (Exception e) {
        throw new BuilderException("Error creating document instance.  Cause: " + e, e);
    }
}
```

如果构造方法入参有传递document参数，直接赋值给document对象即可，不再需要调用createDocument方法区解析

```java
public XPathParser(InputStream inputStream, boolean validation, Properties variables, EntityResolver entityResolver) {
    commonConstructor(validation, variables, entityResolver);
    this.document = createDocument(new InputSource(inputStream));
}
```



#### 4. eval 方法族

**用于获取各个元素的方法**

XPathParser 提供了一系列的 `#eval*` 方法，用于获得 Boolean、Short、Integer、Long、Float、Double、String、Node 类型的元素或节点的“值：

![image-20250115194301427](%E4%BA%8C%E3%80%81%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82%E2%80%94%E2%80%94%E8%A7%A3%E6%9E%90%E5%99%A8%E6%A8%A1%E5%9D%97.assets/image-20250115194301427.png)

本质都是调用的evaluate方法，调用 `xpath` 的 `evaluate(String expression, Object root, QName returnType)` 方法，获得指定元素或节点的值

```java
private Object evaluate(String expression, Object root, QName returnType) {
    try {
        return xpath.evaluate(expression, root, returnType);
    } catch (Exception e) {
        throw new BuilderException("Error evaluating XPath.  Cause: " + e, e);
    }
}
```

以evalString方法为例进行分析，其代码如下所示：

对于单入参方法，其本质调用的是双参的evalString方法

```java
public String evalString(String expression) {
    return evalString(document, expression);
}
```

双参的evalString方法如下所示

```java
public String evalString(Object root, String expression) {
    // <1> 获得值
    String result = (String) evaluate(expression, root, XPathConstants.STRING);
    // <2> 基于 variables 替换动态值，如果 result 为动态值
    return PropertyParser.parse(result, variables);
  }
```

<1> 获得值:调用 `#evaluate(String expression, Object root, QName returnType)` 方法，获得值。其中，`returnType` 方法传入的是 `XPathConstants.STRING` ，表示返回的值是 String 类型

<2> 调用 `PropertyParser#parse(String string, Properties variables)` 方法，基于 `variables` 替换动态值，如果 `result` 为动态值。这就是 MyBatis 如何替换掉 XML 中的动态值实现的方式。



**用于获得 Node 类型的节点的值的eval方法**

相关方法如下所示

```java
// XPathParser.java

public List<XNode> evalNodes(String expression) { // Node 数组
    return evalNodes(document, expression);
}

public List<XNode> evalNodes(Object root, String expression) { // Node 数组
    // <1> 获得 Node 数组
    NodeList nodes = (NodeList) evaluate(expression, root, XPathConstants.NODESET);
    // <2> 封装成 XNode 数组
    List<XNode> xnodes = new ArrayList<>();
    for (int i = 0; i < nodes.getLength(); i++) {
        xnodes.add(new XNode(this, nodes.item(i), variables));
    }
    return xnodes;
}

public XNode evalNode(String expression) { // Node 对象
    return evalNode(document, expression);
}

public XNode evalNode(Object root, String expression) { // Node 对象
    // <1> 获得 Node 对象
    Node node = (Node) evaluate(expression, root, XPathConstants.NODE);
    if (node == null) {
        return null;
    }
    // <2> 封装成 XNode 对象
    return new XNode(this, node, variables);
}
```

- `<1>` 处，返回结果有 Node 对象和数组两种情况，根据方法参数 `expression` 需要获取的节点不同。
- `<2>` 处， 最终结果会将 Node 封装成 `org.apache.ibatis.parsing.XNode` 对象，主要为了动态值的替换（△）。例如：

```java
// XNode.java

public String evalString(String expression) {
    return xpathParser.evalString(node, expression);
}
```



**关于解析mybaits-config.xml流程初步解析**（△）

反正就是解析配置文件，放到全局配置文件configuration中

```java
// 读取mybatis-confg.xml配置文件
try (Reader reader = Resources.getResourceAsReader("org/apache/ibatis/autoconstructor/mybatis-config.xml")) {
    // 调用SqlSessionFactoryBuilder的build方法
    sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader);
}a

```

首先会读取mybatis-confg.xml配置文件，方法是 MyBatis 框架中的一部分，主要用于读取配置文件 `mybatis-config.xml` 并返回一个 `Reader` 对象， `Resources` 类中的一个静态方法，它从类路径中加载指定的资源文件，并返回一个 `Reader` 对象



### 2.2 XMLMapperEntityResolver

`org.apache.ibatis.builder.xml.XMLMapperEntityResolver` ，实现 EntityResolver 接口，MyBatis 自定义 EntityResolver 实现类，用于加载本地的 `mybatis-3-config.dtd` 和 `mybatis-3-mapper.dtd` 这两个 DTD 文件。（默认回去远程下载）

```java
public class XMLMapperEntityResolver implements EntityResolver {

    private static final String IBATIS_CONFIG_SYSTEM = "ibatis-3-config.dtd";
    private static final String IBATIS_MAPPER_SYSTEM = "ibatis-3-mapper.dtd";
    /**
     * 本地 mybatis-config.dtd 文件
     */
    private static final String MYBATIS_CONFIG_SYSTEM = "mybatis-3-config.dtd";
    /**
     * 本地 mybatis-mapper.dtd 文件
     */
    private static final String MYBATIS_MAPPER_SYSTEM = "mybatis-3-mapper.dtd";

    private static final String MYBATIS_CONFIG_DTD = "org/apache/ibatis/builder/xml/mybatis-3-config.dtd";
    private static final String MYBATIS_MAPPER_DTD = "org/apache/ibatis/builder/xml/mybatis-3-mapper.dtd";

    /**
   * Converts a public DTD into a local one.
   *
   * @param publicId
   *          The public id that is what comes after "PUBLIC"
   * @param systemId
   *          The system id that is what comes after the public id.
   *
   * @return The InputSource for the DTD
   *
   * @throws org.xml.sax.SAXException
   *           If anything goes wrong
   */
    @Override
    // publicId示例：-//mybatis.org//DTD Config 3.0//EN
    // systemId示例：https://mybatis.org/dtd/mybatis-3-config.dtd
    public InputSource resolveEntity(String publicId, String systemId) throws SAXException {
        try {
            if (systemId != null) {
                String lowerCaseSystemId = systemId.toLowerCase(Locale.ENGLISH);
                // 获取本地 mybatis-config.dtd 文件
                if (lowerCaseSystemId.contains(MYBATIS_CONFIG_SYSTEM) || lowerCaseSystemId.contains(IBATIS_CONFIG_SYSTEM)) {
                    return getInputSource(MYBATIS_CONFIG_DTD, publicId, systemId);
                }
                // 获取本地 mybatis-mapper.dtd 文件
                if (lowerCaseSystemId.contains(MYBATIS_MAPPER_SYSTEM) || lowerCaseSystemId.contains(IBATIS_MAPPER_SYSTEM)) {
                    return getInputSource(MYBATIS_MAPPER_DTD, publicId, systemId);
                }
            }
            return null;
        } catch (Exception e) {
            throw new SAXException(e.toString());
        }
    }

    private InputSource getInputSource(String path, String publicId, String systemId) {
        InputSource source = null;
        if (path != null) {
            try {
                // 创建 InputSource 对象
                InputStream in = Resources.getResourceAsStream(path);
                source = new InputSource(in);
                source.setPublicId(publicId);
                // 设置  publicId、systemId 属性
                source.setSystemId(systemId);
            } catch (IOException e) {
                // ignore, null is ok
            }
        }
        return source;
    }

}
```

### 2.3 GenericTokenParser

`org.apache.ibatis.parsing.GenericTokenParser` ，**通用**的 Token 解析器。

`GenericTokenParser` 是 MyBatis 提供的一个通用的标记解析器，通常用于处理 SQL 语句中的占位符，解析并将这些占位符替换成实际的内容。它是一个解析器（具体的替换功能是通过TokenHandler实现的），主要用于解析像 `${}` 和 `#{}` 这样的标记。

其源码如下所示

```java
package org.apache.ibatis.parsing;

/**
 * @author Clinton Begin
 */
public class GenericTokenParser {

    // 左开字符串
    private final String openToken;
    // 右闭字符串
    private final String closeToken;
    // 替换处理器
    private final TokenHandler handler;

    // <1> 构造函数，创建通用的 Token 解析器对象
    public GenericTokenParser(String openToken, String closeToken, TokenHandler handler) {
        this.openToken = openToken;
        this.closeToken = closeToken;
        this.handler = handler;
    }

    // 解析方法
    public String parse(String text) {
        // 如果解析的文本为null 或 空 则退出
        if (text == null || text.isEmpty()) {
            return "";
        }
        // search open token
        // 寻找开始的 openToken 的位置
        int start = text.indexOf(openToken);
        if (start == -1) {
            // 找不到，直接返回
            return text;
        }
        // 将解析的文本转换为字符串数组
        char[] src = text.toCharArray();
        // 起始查找位置
        int offset = 0;
        final StringBuilder builder = new StringBuilder();
        // 匹配到 openToken 和 closeToken 之间的表达式存储到builder对象中
        StringBuilder expression = null;
        do {
            // 转义字符
            if (start > 0 && src[start - 1] == '\\') {
                // this open token is escaped. remove the backslash and continue.
                // 因为 openToken 前面一个位置是 \ 转义字符，所以忽略 \
                // 添加 [offset, start - offset - 1] 和 openToken 的内容，添加到 builder 中
                builder.append(src, offset, start - offset - 1).append(openToken);
                // 修改 offset
                offset = start + openToken.length();
           	// 非转义字符
            } else {
                // found open token. let's search close token.
                // 创建/重置 expression 对象
                if (expression == null) {
                    expression = new StringBuilder();
                } else {
                    expression.setLength(0);
                }
                // 添加 offset 和 openToken 之间的内容，添加到 builder 中
                builder.append(src, offset, start - offset);
                // 修改 offset
                offset = start + openToken.length();
                // 继续，寻找结束的 closeToken 的位置
                int end = text.indexOf(closeToken, offset);
                while (end > -1) {
                    if ((end <= offset) || (src[end - 1] != '\\')) {
                        expression.append(src, offset, end - offset);
                        break;
                    }
                    // this close token is escaped. remove the backslash and continue.
                    expression.append(src, offset, end - offset - 1).append(closeToken);
                    offset = end + closeToken.length();
                    end = text.indexOf(closeToken, offset);
                }
                if (end == -1) {
                    // close token was not found.
                    builder.append(src, start, src.length - start);
                    offset = src.length;
                } else {
                    builder.append(handler.handleToken(expression.toString()));
                    offset = end + closeToken.length();
                }
            }
            start = text.indexOf(openToken, offset);
        } while (start > -1);
        if (offset < src.length) {
            builder.append(src, offset, src.length - offset);
        }
        return builder.toString();
    }
}

```

<1> 通用的 Token 解析器构造函数调用

可以看到其构造函数调用位置传递的一些参数如下所示，可以看到其主要用于解析像 `${}` 和 `#{}` 这样的标记。

![image-20250115210621040](%E4%BA%8C%E3%80%81%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82%E2%80%94%E2%80%94%E8%A7%A3%E6%9E%90%E5%99%A8%E6%A8%A1%E5%9D%97.assets/image-20250115210621040.png)



可以参考如下代码示例，就能理解GenericTokenParser和TokenHandler的作用：

```java
@Test
void innnt() {
    GenericTokenParser genericTokenParser = new GenericTokenParser("${", "}", new TokenHandler() {
        @Override
        public String handleToken(String content) {
            return "0000";
        }
    });
    String parse = genericTokenParser.parse("wowow is ${123} + ${wakaka} + ${xixixi}");
    System.out.println(parse);
}
```

出参：

```
wowow is 0000 + 0000 + 0000
```



### 2.4 PropertyParser

org.apache.ibatis.parsing.PropertyParser，动态属性解析器，通过调用VariableTokenHandler对象和GenericTokenParser 对象实现解析，相关源码如下所示

```java
public class PropertyParser {

    private static final String KEY_PREFIX = "org.apache.ibatis.parsing.PropertyParser.";
 
    public static final String KEY_ENABLE_DEFAULT_VALUE = KEY_PREFIX + "enable-default-value";


    public static final String KEY_DEFAULT_VALUE_SEPARATOR = KEY_PREFIX + "default-value-separator";

    private static final String ENABLE_DEFAULT_VALUE = "false";
    private static final String DEFAULT_VALUE_SEPARATOR = ":";

    
    // <1> 构造方法，修饰符为 private ，禁止构造 PropertyParser 对象，因为它是一个静态方法的工具类
    private PropertyParser() {
        // Prevent Instantiation
    }

    // <2> 基于 variables 变量，替换 string 字符串中的动态属性，并返回替换后的结果
    public static String parse(String string, Properties variables) {
        // <2.1> 创建 Token 处理器对象 VariableTokenHandler
        VariableTokenHandler handler = new VariableTokenHandler(variables);
        // <2.2> 创建通用的 Token 解析器
        GenericTokenParser parser = new GenericTokenParser("${", "}", handler);
        // <2.3> 调用通用的 Token 解析器的parse方法，对string进行解析
        return parser.parse(string);
    }

    private static class VariableTokenHandler implements TokenHandler {
        private final Properties variables;
        private final boolean enableDefaultValue;
        private final String defaultValueSeparator;

        private VariableTokenHandler(Properties variables) {
            this.variables = variables;
            this.enableDefaultValue = Boolean.parseBoolean(getPropertyValue(KEY_ENABLE_DEFAULT_VALUE, ENABLE_DEFAULT_VALUE));
            this.defaultValueSeparator = getPropertyValue(KEY_DEFAULT_VALUE_SEPARATOR, DEFAULT_VALUE_SEPARATOR);
        }

        private String getPropertyValue(String key, String defaultValue) {
            return variables == null ? defaultValue : variables.getProperty(key, defaultValue);
        }

        @Override
        public String handleToken(String content) {
            if (variables != null) {
                String key = content;
                if (enableDefaultValue) {
                    final int separatorIndex = content.indexOf(defaultValueSeparator);
                    String defaultValue = null;
                    if (separatorIndex >= 0) {
                        key = content.substring(0, separatorIndex);
                        defaultValue = content.substring(separatorIndex + defaultValueSeparator.length());
                    }
                    if (defaultValue != null) {
                        return variables.getProperty(key, defaultValue);
                    }
                }
                if (variables.containsKey(key)) {
                    return variables.getProperty(key);
                }
            }
            return "${" + content + "}";
        }
    }

}
```

- <1>  将构造方法修饰符为 private，即禁止构造 PropertyParser 对象，因为其是一个静态方法的工具类

- <2>  PropertyParser的parse方法，基于 variables 变量，替换 string 字符串中的动态属性，并返回替换后的结果

  - <2.1>  创建 Token 处理器对象 VariableTokenHandler， 并将需要动态替换的variables变量传入构造器。
  - <2.2> 创建通用的 Token 解析器。可以看到，`openToken = {` ，`closeToken = }`，就是上面看到的 `${username}` 和 `{password}`。并将2.1自定义实现的Token处理器对象VariableTokenHandler作为入参传入

  - <2.3> 调用通用的 Token 解析器GenericTokenParser对象的parse方法，对string进行解析。



### 2.5 TokenHandler

讲讲上面的VariableTokenHandler，其实现的接口是TokenHandler

该接口源码如下所示，其中就只有一个需要实现的方法

```java
public interface TokenHandler {
  String handleToken(String content);
}
```

handleToken存入的是需要处理的带有token的content Token 字符串，返回的是处理后的结果。

该方法在Token 解析器GenericTokenParser类的parse方法进行调用，如下所示

![image-20250118103331701](%E4%BA%8C%E3%80%81%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82%E2%80%94%E2%80%94%E8%A7%A3%E6%9E%90%E5%99%A8%E6%A8%A1%E5%9D%97.assets/image-20250118103331701.png)

其实现类共有四个子类实现，如下所示

![image-20250118104049085](%E4%BA%8C%E3%80%81%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82%E2%80%94%E2%80%94%E8%A7%A3%E6%9E%90%E5%99%A8%E6%A8%A1%E5%9D%97.assets/image-20250118104049085.png)

#### 1. VariableTokenHandler

VariableTokenHandler ，是 PropertyParser 的内部静态类，如下图源码所示

![image-20250118104303256](%E4%BA%8C%E3%80%81%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82%E2%80%94%E2%80%94%E8%A7%A3%E6%9E%90%E5%99%A8%E6%A8%A1%E5%9D%97.assets/image-20250118104303256.png)

**构造方法即变量**

```java
// ====== PropertyParser中的全局变量 ======
// key前缀
private static final String KEY_PREFIX = "org.apache.ibatis.parsing.PropertyParser.";
/**
* The special property key that indicate whether enable a default value on placeholder.
* 指示是否在占位符上启用默认值的特殊属性键
* <p>
*   The default value is {@code false} (indicate disable a default value on placeholder) 默认值是false，表示禁用占位符上的默认值
*   If you specify the {@code true}, you can specify key and default value on placeholder (e.g. {@code ${db.username:postgres}}).
* 如果你指定其值为true，可以在占位符上指定键和默认值
* </p>
* @since 3.4.2
*/
public static final String KEY_ENABLE_DEFAULT_VALUE = KEY_PREFIX + "enable-default-value";

/**
* The special property key that specify a separator for key and default value on placeholder. 特殊属性键，为键指定分隔符，并在占位符上指定默认值
* <p>
*   The default separator is {@code ":"}. 默认分隔符为:
* </p>
* @since 3.4.2
*/
public static final String KEY_DEFAULT_VALUE_SEPARATOR = KEY_PREFIX + "default-value-separator";

// 是否在占位符上启用默认值的特殊属性键默认值
private static final String ENABLE_DEFAULT_VALUE = "false";
// 默认分隔符
private static final String DEFAULT_VALUE_SEPARATOR = ":";

// VariableTokenHandler类
private static class VariableTokenHandler implements TokenHandler {
    // 变量 Properties 对象
    private final Properties variables;
    // 是否开启默认值功能。默认为false
    private final boolean enableDefaultValue;
    // 默认值的分隔符。默认为:
    private final String defaultValueSeparator;

    // 构造函数
    private VariableTokenHandler(Properties variables) {
        this.variables = variables;
        this.enableDefaultValue = Boolean.parseBoolean(getPropertyValue(KEY_ENABLE_DEFAULT_VALUE, ENABLE_DEFAULT_VALUE));
        this.defaultValueSeparator = getPropertyValue(KEY_DEFAULT_VALUE_SEPARATOR, DEFAULT_VALUE_SEPARATOR);
    }
	
    // 从变量 Properties 对象获取对应key的值，获取不到使用默认值defaultValue
    private String getPropertyValue(String key, String defaultValue) {
        return variables == null ? defaultValue : variables.getProperty(key, defaultValue);
    }

    @Override
    public String handleToken(String content) {
        if (variables != null) {
            String key = content;
            if (enableDefaultValue) {
                final int separatorIndex = content.indexOf(defaultValueSeparator);
                String defaultValue = null;
                if (separatorIndex >= 0) {
                    key = content.substring(0, separatorIndex);
                    defaultValue = content.substring(separatorIndex + defaultValueSeparator.length());
                }
                if (defaultValue != null) {
                    return variables.getProperty(key, defaultValue);
                }
            }
            if (variables.containsKey(key)) {
                return variables.getProperty(key);
            }
        }
        return "${" + content + "}";
    }
}

```

在配置文件中添加如下开启默认值功能：

是否开启默认值功能。默认为 `ENABLE_DEFAULT_VALUE` ，即**不开启**。想要开启，可以配置如下：

```xml
<properties resource="org/mybatis/example/config.properties">
    <!-- ... -->
    <property name="org.apache.ibatis.parsing.PropertyParser.enable-default-value" value="true"/> <!-- Enable this feature -->
</properties>
```

在配置文件中修改默认值的分隔符：

默认为 `KEY_DEFAULT_VALUE_SEPARATOR` ，即 `":"` 。想要修改，可以配置如下，此时分隔符被修改成了 `?:` 

```xml
<properties resource="org/mybatis/example/config.properties">
  <!-- ... -->
  <property name="org.apache.ibatis.parsing.PropertyParser.default-value-separator" value="?:"/> <!-- Change default value of separator -->
</properties>
```



**handleToken方法实现**

源码如下所示

```java
@Override
public String handleToken(String content) {
    // 如果variables不为空则进行替换逻辑
    if (variables != null) {
        String key = content;
        // 是否开启默认值功能
        if (enableDefaultValue) {
            final int separatorIndex = content.indexOf(defaultValueSeparator);
            String defaultValue = null;
            if (separatorIndex >= 0) {
                key = content.substring(0, separatorIndex);
                defaultValue = content.substring(separatorIndex + defaultValueSeparator.length());
            }
            // 有默认值，优先替换，不存在则返回默认值
            if (defaultValue != null) {
                return variables.getProperty(key, defaultValue);
            }
        }
        // 未开启默认值功能，直接替换
        if (variables.containsKey(key)) {
            return variables.getProperty(key);
        }
    }
    // 返回替换后的结果
    return "${" + content + "}";
}
```

