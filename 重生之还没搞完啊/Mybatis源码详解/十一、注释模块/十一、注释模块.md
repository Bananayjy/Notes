## 十一、注释模块

### 一、前言

#### 1、概述

注解相关内容位于`org.apache.ibatis.annotations`包下，如下图所示

![image-20250330150220395](%E5%8D%81%E4%B8%80%E3%80%81%E6%B3%A8%E9%87%8A%E6%A8%A1%E5%9D%97.assets/image-20250330150220395.png)

> 随着 Java 注解的慢慢流行，MyBatis 提供了**注解**的方式，使得我们方便的在 Mapper 接口上编写简单的数据库 SQL 操作代码，而无需像之前一样，必须编写 SQL 在 XML 格式的 Mapper 文件中。虽然说，实际场景下，大家还是喜欢在 XML 格式的 Mapper 文件中编写响应的 SQL 操作。
>
> 分类如下所示：
>
> - **增删改查：** @Insert、@Update、@Delete、@Select、@MapKey、@Options、@SelelctKey、@Param、@InsertProvider、@UpdateProvider、@DeleteProvider、@SelectProvider
> - **结果集映射：** @Results、@Result、@ResultMap、@ResultType、@ConstructorArgs、@Arg、@One、@Many、@TypeDiscriminator、@Case
> - **缓存：** @CacheNamespace、@Property、@CacheNamespaceRef、@Flush



### 二、相关内容

#### 1、CRUD常用操作注解

使用示例如下所示：

```java
package com.whut.inter;
import java.util.List;
import org.apache.ibatis.annotations.Delete;
import org.apache.ibatis.annotations.Insert;
import org.apache.ibatis.annotations.Param;
import org.apache.ibatis.annotations.Select;
import org.apache.ibatis.annotations.Update;
import com.whut.model.User;

// 最基本的注解CRUD
public interface IUserDAO {

    @Select("select *from User")
    public List<User> retrieveAllUsers();
                                
    //注意这里只有一个参数，则#{}中的标识符可以任意取
    @Select("select *from User where id=#{idss}")
    public User retrieveUserById(int id);
                                
    @Select("select *from User where id=#{id} and userName like #{name}")
    public User retrieveUserByIdAndName(@Param("id")int id,@Param("name")String names);
                                 
    @Insert("INSERT INTO user(userName,userAge,userAddress) VALUES(#{userName},"
            + "#{userAge},#{userAddress})")
    public void addNewUser(User user);
                                 
    @Delete("delete from user where id=#{id}")
    public void deleteUser(int id);
    
    @Update("update user set userName=#{userName},userAddress=#{userAddress}"
            + " where id=#{id}")
    public void updateUser(User user);
    
}
```

##### 1. @Select

```java
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
@Repeatable(Select.List.class)
public @interface Select {
    /**
   * Returns an SQL for retrieving record(s).
   * 返回用于检索记录的SQL
   *
   * @return an SQL for retrieving record(s)
   */
    String[] value();

    /**
   * @return A database id that correspond this statement
   * 与此语句对应的数据库id
   * 用于多数据库支持的特性，允许你为不同的数据库编写特定的 SQL 语句
   *
   * @since 3.5.5
   */
    String databaseId() default "";

    /**
   * Returns whether this select affects DB data.<br>
   * e.g. RETURNING of PostgreSQL or OUTPUT of MS SQL Server.
   * 返回此选择是否影响DB数据。
   * 例如：PostgreSQL的return或MS SQL Server的OUTPUT。
   *
   * @return {@code true} if this select affects DB data; {@code false} if otherwise
   *
   * @since 3.5.12
   */
    boolean affectData() default false;

    /**
   * The container annotation for {@link Select}.
   * Select的容器式注解
   *
   * @author Kazuki Shimizu
   *
   * @since 3.5.5
   */
    @Documented
    @Retention(RetentionPolicy.RUNTIME)
    @Target(ElementType.METHOD)
    @interface List {
        Select[] value();
    }

}
```

- 关于`@Select.List` 

`@Select.List` 是 MyBatis 提供的**重复注解容器**（Container Annotation），用于在同一个方法上声明多个 `@Select` 注解。Java 8 引入了 `@Repeatable` 元注解，允许同一个注解在同一个位置多次出现。但底层实现需要**一个容器注解**来包装多个相同注解。`@Select.List` 就是 `@Select` 的容器，用于支持以下写法：

```java
@Select("SELECT * FROM users WHERE id = #{id}")
@Select("SELECT * FROM users WHERE name = #{name}")
// 编译错误：Java 不允许直接重复使用 @Select
```

需要通过 `@Select.List` 包装：

```java
@Select.List({
  @Select("SELECT * FROM users WHERE id = #{id}"),
  @Select("SELECT * FROM users WHERE name = #{name}")
})
```

注意：如果同时存在单独的 `@Select` 和 `@Select.List`，MyBatis 会优先处理 `@Select`，忽略 `@Select.List`。

- databaseId

参考文章：https://blog.csdn.net/cj_eryue/article/details/146068448

- affectData

`affectData` 是 MyBatis `@Select` 注解中一个相对较新的属性（自 3.5.12 版本引入），用于**标记一个查询操作是否会修改数据库数据**。

那为什么需要显示声明这个变量呢：

- **事务控制**
  - 如果 `affectData = true`，MyBatis 会确保该方法在**事务中执行**（即使没有显式 `@Transactional`）。
  - 避免只读事务优化导致的数据不一致。
- **框架行为调整**
  - 某些插件或扩展可能需要根据该标记调整逻辑（如审计插件不记录纯查询操作）。
- **代码可读性**
  - 明确告知开发者这个“查询”实际会修改数据



##### 2.@Insert

```java
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
@Repeatable(Insert.List.class)
public @interface Insert {
    /**
   * Returns an SQL for inserting record(s).
   * 返回用于插入记录的SQL
   *
   * @return an SQL for inserting record(s)
   */
    String[] value();

    /**
   * @return A database id that correspond this statement
   * 此语句对应的数据库id
   * 用于多数据库支持的特性，允许你为不同的数据库编写特定的 SQL 语句
   *
   * @since 3.5.5
   */
    String databaseId() default "";

    /**
   * The container annotation for {@link Insert}.
   * Insert
   *
   * @author Kazuki Shimizu
   *
   * @since 3.5.5
   */
    @Documented
    @Retention(RetentionPolicy.RUNTIME)
    @Target(ElementType.METHOD)
    @interface List {
        Insert[] value();
    }

}
```

##### 3.@Update

```java
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
@Repeatable(Update.List.class)
public @interface Update {
    /**
   * Returns an SQL for updating record(s).
   * 返回用于更新记录的SQL
   *
   * @return an SQL for updating record(s)
   */
    String[] value();

    /**
   * @return A database id that correspond this statement
   * 此语句对应的数据库id
   * 用于多数据库支持的特性，允许你为不同的数据库编写特定的 SQL 语句
   * @since 3.5.5
   */
    String databaseId() default "";

    /**
   * The container annotation for {@link Update}.
   * Update的容器式注解
   *
   * @author Kazuki Shimizu
   *
   * @since 3.5.5
   */
    @Documented
    @Retention(RetentionPolicy.RUNTIME)
    @Target(ElementType.METHOD)
    @interface List {
        Update[] value();
    }
}
```

##### 4.@Delete

```java
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
@Repeatable(Delete.List.class)
public @interface Delete {
    /**
   * Returns an SQL for deleting record(s).
   * 返回用于删除记录的SQL
   *
   * @return an SQL for deleting record(s)
   */
    String[] value();

    /**
   * @return A database id that correspond this statement
   * 与此语句对应的数据库id
   * 用于多数据库支持的特性，允许你为不同的数据库编写特定的 SQL 语句
   * @since 3.5.5
   */
    String databaseId() default "";

    /**
   * The container annotation for {@link Delete}.
   * Delete的容器式注解
   *
   * @author Kazuki Shimizu
   *
   * @since 3.5.5
   */
    @Documented
    @Retention(RetentionPolicy.RUNTIME)
    @Target(ElementType.METHOD)
    @interface List {
        Delete[] value();
    }

}
```

##### 5.@Param

> 当映射器方法需多个参数，这个注解可以被应用于映射器方法参数来给每个参数一个名字。否则，多参数将会以它们的顺序位置来被命名。比如 `#{1}`，`#{2}` 等，这是默认的。
>
> 使用 `@Param("person")` ，SQL 中参数应该被命名为 `#{person}` 

```java
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.PARAMETER)
public @interface Param {
    /**
   * Returns the parameter name.
   * 返回参数名称
   *
   * @return the parameter name
   */
    String value();
}
```



#### 2、CRUD高级操作注解

##### 1.@SelectProvider

```java
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
@Repeatable(SelectProvider.List.class)
public @interface SelectProvider {

    /**
   * Specify a type that implements an SQL provider method.
   * 指定实现SQL提供程序方法的类型
   *
   * @return a type that implements an SQL provider method 实现SQL提供程序方法的类型
   *
   * @since 3.5.2
   *
   * @see #type()
   */
    Class<?> value() default void.class;

    /**
   * Specify a type that implements an SQL provider method.
   * 指定实现SQL提供程序方法的类型
   * <p>
   * This attribute is alias of {@link #value()}. 这个属性是{@link #value()}的别名
   *
   * @return a type that implements an SQL provider method 实现SQL提供程序方法的类型
   *
   * @see #value()
   */
    Class<?> type() default void.class;

    /**
   * Specify a method for providing an SQL.
   * 指定提供SQL的方法
   * <p>
   * Since 3.5.1, this attribute can omit. 从3.5.1开始，这个属性可以省略。
   * <p>
   * If this attribute omit, the MyBatis will call a method that decide by following rules. 如果省略此属性，MyBatis将调用一个方法，该方法根据以下规则决定
   * <ul>
   * <li>If class that specified the {@link #type()} attribute implements the
   * {@link org.apache.ibatis.builder.annotation.ProviderMethodResolver}, the MyBatis use a method that returned by it.
   * 如果指定{@link #type()}属性的类实现了
   * {@link org.apache.ibatis.builder.annotation.ProviderMethodResolver}， MyBatis使用由它返回的方法
   * </li>
   * <li>If cannot resolve a method by {@link org.apache.ibatis.builder.annotation.ProviderMethodResolver} (= not
   * implement it or it was returned <code>null</code>), the MyBatis will search and use a fallback method that named
   * <code>provideSql</code> from specified type.</li>
   * 如果无法解析方法 {@link org.apache.ibatis.builder.annotation.ProviderMethodResolver} 如果没有实现它，或者返回<code>null</code>)，
   * MyBatis将搜索并使用一个名为<code>provideSql</code> from指定的类型
   * </ul>
   *
   * @return a method name of method for providing an SQL 提供SQL的方法的方法名
   */
    String method() default "";

    /**
   * @return A database id that correspond this provider 与此提供程序对应的数据库id
   *
   * @since 3.5.5
   */
    String databaseId() default "";

    /**
   * Returns whether this select affects DB data.<br>
   * e.g. RETURNING of PostgreSQL or OUTPUT of MS SQL Server.
   * 返回此选择是否影响DB数据。
   * 例如：PostgreSQL的return或MS SQL Server的OUTPUT。
   *
   * @return {@code true} if this select affects DB data; {@code false} if otherwise
   *
   * @since 3.5.12
   */
    boolean affectData() default false;

    /**
   * The container annotation for {@link SelectProvider}.
   * SelectProviderd的容器式注解
   *
   * @author Kazuki Shimizu
   *
   * @since 3.5.5
   */
    @Documented
    @Retention(RetentionPolicy.RUNTIME)
    @Target(ElementType.METHOD)
    @interface List {
        SelectProvider[] value();
    }

}
```

具体使用方式示例：

（1）基本用法

定义 Provider 类，其中包含返回 SQL 字符串的方法：

```java
public class UserSqlProvider {
    // 方法返回需要执行的SQL字符串
    public String selectUserById(Long id) {
        return "SELECT * FROM user WHERE id = #{id}";
    }
}
```

在Mapper接口中通过@SelectProvider进行使用

```java
public interface UserMapper {
    @SelectProvider(type = UserSqlProvider.class, method = "selectUserById")
    User findUserById(@Param("id") Long id);
}
```

（2）动态SQL

根据条件动态生成 WHERE 子句：

```java
public class UserSqlProvider {
    public String findUsersByCondition(User user) {
        return new SQL() {{
            SELECT("*");
            FROM("user");
            if (user.getName() != null) {
                WHERE("name = #{name}");
            }
            if (user.getAge() != null) {
                WHERE("age = #{age}");
            }
        }}.toString();
    }
}
```

Mapper 接口：

```java
@SelectProvider(type = UserSqlProvider.class, method = "findUsersByCondition")
List<User> findUsersByCondition(User user);
```

（3）复杂场景：多参数+动态 SQL

Provider 类：

```java
public class UserSqlProvider {
    public String findUsersByMultiParams(
        @Param("name") String name, 
        @Param("minAge") Integer minAge,
        @Param("maxAge") Integer maxAge) {
        
        return new SQL() {{
            SELECT("*");
            FROM("user");
            if (name != null) {
                WHERE("name LIKE CONCAT('%', #{name}, '%')");
            }
            if (minAge != null) {
                WHERE("age >= #{minAge}");
            }
            if (maxAge != null) {
                WHERE("age <= #{maxAge}");
            }
        }}.toString();
    }
}
```

mapper接口：

```java
@SelectProvider(type = UserSqlProvider.class, method = "findUsersByMultiParams")
List<User> findUsers(
    @Param("name") String name,
    @Param("minAge") Integer minAge,
    @Param("maxAge") Integer maxAge);
```

关于@InsertProvider、@UpdateProvider、@DeleteProvider的使用基本类似。



##### 2.@Results & @Result & @One & Many

`@Results` 是 MyBatis 用于**自定义结果集映射**的注解，主要用于解决数据库字段与 Java 对象属性不一致的情况。其对应 XML 标签为 `<resultMap />`：

```java
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Results {
  /**
   * Returns the id of this result map.
   * 返回结果映射的id。
   *
   * @return the id of this result map
   */
  String id() default "";

  /**
   * Returns mapping definitions for property.
   * 返回属性的映射定义。
   *
   * @return mapping definitions
   */
  Result[] value() default {};
}
```

@Result 是结果字段的注解,起源码如下所示：

```java
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
@Repeatable(Results.class)
public @interface Result {
    /**
   * Returns whether id column or not.
   *  是否是 ID 字段
   *
   * @return {@code true} if id column; {@code false} if otherwise
   */
    boolean id() default false;

    /**
   * Return the column name(or column label) to map to this argument.
   * 返回列名（或列标签）以映射到此参数。
   *
   * @return the column name(or column label)
   */
    String column() default "";

    /**
   * Returns the property name for applying this mapping.
   * 返回应用此映射的属性名称。
   *
   * @return the property name
   */
    String property() default "";

    /**
   * Return the java type for this argument.
   * 返回该参数的java类型。
   *
   * @return the java type
   */
    Class<?> javaType() default void.class;

    /**
   * Return the jdbc type for column that map to this argument.
   * 返回映射到该参数的列的jdbc类型。
   *
   * @return the jdbc type
   */
    JdbcType jdbcType() default JdbcType.UNDEFINED;

    /**
   * Returns the {@link TypeHandler} type for retrieving a column value from result set.
   * 返回从结果集中检索列值的{@link TypeHandler}类型
   *
   * @return the {@link TypeHandler} type
   */
    Class<? extends TypeHandler> typeHandler() default UnknownTypeHandler.class;

    /**
   * Returns the mapping definition for single relationship.
   * 返回单个关系的映射定义。
   *
   * @return the mapping definition for single relationship
   */
    One one() default @One;

    /**
   * Returns the mapping definition for collection relationship.
   * 返回集合关系的映射定义。
   *
   * @return the mapping definition for collection relationship
   */
    Many many() default @Many;
}
```

@One是复杂类型的单独属性值的注解，其源码如下：

```java
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target({})
public @interface One {
  /**
   * Returns the columnPrefix.
   * 列名前缀，用于去重和匹配关联对象的字段
   * 示例："dept_"（会自动映射 dept_id → id）
   *
   * @return the columnPrefix.
   *
   * @since 3.5.5
   */
  String columnPrefix() default "";

  /**
   * Returns the result map id used to map single object.
   * 返回用于映射单个对象的结果映射id
   * 即引用已定义的 <resultMap> 或 @Results 的 ID
   *
   * @return the result map id
   *
   * @since 3.5.5
   */
  String resultMap() default "";

  /**
   * Returns the statement id that retrieves single object.
   * 返回检索单个对象的语句id,即指定另一个 Mapper 方法的全限定名，用于查询关联对象
   * 示例："com.example.mapper.DeptMapper.findById"
   *
   * @return the statement id
   */
  String select() default "";

  /**
   * Returns the fetch strategy for nested statement.
   * 返回嵌套语句的获取策略。
   * 加载策略：
   * - LAZY（延迟加载）
   * - EAGER（立即加载）
   * - DEFAULT（全局配置）
   *
   * @return the fetch strategy
   */
  FetchType fetchType() default FetchType.DEFAULT;

}

```

@Many是复杂类型的集合属性值的注解，其源码如下：

```java
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target({})
public @interface Many {
    /**
   * Returns the columnPrefix.
   * 列名前缀，用于去重和匹配关联对象的字段
   * 示例："dept_"（会自动映射 dept_id → id）
   *
   * @return the columnPrefix.
   *
   * @since 3.5.5
   */
    String columnPrefix() default "";

    /**
   * Returns the result map id used to map collection.
   * 返回用于映射单个对象的结果映射id
   * 即引用已定义的 <resultMap> 或 @Results 的 ID
   * @return the result map id
   *
   * @since 3.5.5
   */
    String resultMap() default "";

    /**
   * Returns the statement id that retrieves collection.
   * 返回检索单个对象的语句id,即指定另一个 Mapper 方法的全限定名，用于查询关联对象
   * 示例："com.example.mapper.DeptMapper.findById"
   *
   * @return the statement id
   */
    String select() default "";

    /**
   * Returns the fetch strategy for nested statement.
   * 返回嵌套语句的获取策略。
   * 加载策略：
   * - LAZY（延迟加载）
   * - EAGER（立即加载）
   * - DEFAULT（全局配置）
   *
   * @return the fetch strategy
   */
    FetchType fetchType() default FetchType.DEFAULT;

}

```

具体使用示例：

（1）基本用法：字段名和属性名不一致时

当数据库字段名（如 `user_name`）和 Java 对象属性名（如 `userName`）不同时：

```java
public class User {
    private Integer id;
    private String userName; // 属性名 ≠ 数据库字段名 user_name
    // getters/setters...
}
```

使用 `@Results` 映射：

```java
@Select("SELECT id, user_name, user_age FROM users WHERE id = #{id}")
@Results({
    @Result(property = "userName", column = "user_name"), // 属性 → 字段
    @Result(property = "userAge", column = "user_age")
})
User getUserById(Integer id);
```

（2）复杂映射：嵌套对象

当查询包含关联对象时（如 `User` 包含 `Department`）：

```java
public class User {
    private Integer id;
    private String userName;
    private Department dept; // 嵌套对象
}
```

使用 `@Result` 的 `one` 或 `many`：

```java
@Select("SELECT u.id, u.user_name, d.dept_id, d.dept_name " +
        "FROM users u LEFT JOIN departments d ON u.dept_id = d.dept_id " +
        "WHERE u.id = #{id}")
@Results({
    @Result(property = "id", column = "id"),
    @Result(property = "userName", column = "user_name"),
    @Result(property = "dept", column = "dept_id", 
            one = @One(select = "com.example.mapper.DepartmentMapper.getDeptById"))
})
User getUserWithDept(Integer id);
```

其中`@One` 表示一对一关联，通过另一个 Mapper 方法查询

##### 3.@ResultMap

```java
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface ResultMap {
  /**
   * Returns result map names to use.
   * 返回要使用的结果映射名称。
   *
   * @return result map names
   */
  String[] value();
}

```

示例：复用结果映射（`id` 属性），通过 `id` 定义可复用的结果集：

```java
// 定义可复用的映射
@Results(id = "userResultMap", value = {
    @Result(property = "userName", column = "user_name"),
    @Result(property = "userAge", column = "user_age")
})
@Select("SELECT * FROM users WHERE id = #{id}")
User getUserById(Integer id);

// 通过 @ResultMap 复用
@ResultMap("userResultMap")
@Select("SELECT * FROM users")
List<User> getAllUsers();
```

##### 4.@ResultType

```java
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface ResultType {
    /**
   * Returns the return type.
   * 返回类型
   *
   * @return the return type
   */
    Class<?> value();
}

```

@ResultType和`@Results` + `@Result`区别：

| 注解                   | 用途               | 适用场景                                |
| :--------------------- | :----------------- | :-------------------------------------- |
| `@ResultType`          | **仅指定结果类型** | 简单映射（字段名与属性名一致）          |
| `@Results` + `@Result` | **自定义字段映射** | 复杂映射（字段名 ≠ 属性名或有关联对象） |

##### 5.@CacheNamespace

缓存空间配置的注解，对应 XML 标签为 `<cache />`

```java
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface CacheNamespace {

    /**
   * Returns the cache implementation type to use.
   * 负责存储的 Cache 实现类
   *
   * @return the cache implementation type
   */
    Class<? extends Cache> implementation() default PerpetualCache.class;

    /**
   * Returns the cache evicting implementation type to use.
   * 负责过期的 Cache 实现类
   *
   * @return the cache evicting implementation type
   */
    Class<? extends Cache> eviction() default LruCache.class;

    /**
   * Returns the flush interval.
   * 清空缓存的频率。0 代表不清空
   *
   * @return the flush interval
   */
    long flushInterval() default 0;

    /**
   * Return the cache size.
   * 缓存容器大小
   *
   * @return the cache size
   */
    int size() default 1024;

    /**
   * Returns whether use read/write cache.
   * 是否序列化。{@link org.apache.ibatis.cache.decorators.SerializedCache}
   *
   * @return {@code true} if use read/write cache; {@code false} if otherwise
   */
    boolean readWrite() default true;

    /**
   * Returns whether block the cache at request time or not.
   * 返回是否在请求时阻塞缓存。
   *
   * @return {@code true} if block the cache; {@code false} if otherwise
   */
    boolean blocking() default false;

    /**
   * Returns property values for a implementation object.
   * 返回实现对象的属性值
   *
   * @return property values
   *
   * @since 3.4.2
   */
    Property[] properties() default {};

}
```

```java
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target({})
public @interface Property {

    /**
   * Returns the property name.
   * 属性名
   *
   * @return the property name
   */
    String name();

    /**
   * Returns the property value or placeholder.
   * 返回属性值或占位符
   *
   * @return the property value or placeholder
   */
    String value();
}
```

##### 6.@CacheNamespaceRef

指向指定命名空间的注解，对应 XML 标签为 `<cache-ref />`

```java
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface CacheNamespaceRef {

    /**
   * Returns the namespace type to reference a cache (the namespace name become a FQCN of specified type).
   * 返回引用缓存的命名空间类型
   *
   * @return the namespace type to reference a cache
   */
    Class<?> value() default void.class;

    /**
   * Returns the namespace name to reference a cache.
   * 返回用于引用缓存的命名空间名称。
   *
   * @return the namespace name
   *
   * @since 3.4.2
   */
    String name() default "";
}
```



##### 7.@Options

`@Options` 是 MyBatis 提供的一个功能丰富的注解，用于**配置 SQL 语句执行的细节选项**，例如主键生成、超时控制、缓存行为等。

```java
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
@Repeatable(Options.List.class)
public @interface Options {
    /**
   * The options for the {@link Options#flushCache()}. The default is {@link FlushCachePolicy#DEFAULT}
   */
    enum FlushCachePolicy {
        /** <code>false</code> for select statement; <code>true</code> for insert/update/delete statement. */
        // <code>false</code> 更新语句；<code>true</code>插入/更新/删除语句。
        DEFAULT,
        /** Flushes cache regardless of the statement type. */
        // 无论语句类型如何，都会刷新缓存。
        TRUE,
        /** Does not flush cache regardless of the statement type. */
        // 无论语句类型如何，都不刷新缓存
        FALSE
    }

    /**
   * Returns whether use the 2nd cache feature if assigned the cache.
   * 如果分配了缓存，返回是否使用第二个缓存特性
   *
   * @return {@code true} if use; {@code false} if otherwise
   */
    boolean useCache() default true;

    /**
   * Returns the 2nd cache flush strategy.
   * 刷新缓存的策略
   *
   * @return the 2nd cache flush strategy
   */
    FlushCachePolicy flushCache() default FlushCachePolicy.DEFAULT;

    /**
   * Returns the result set type.
   * 结果类型
   *
   * @return the result set type
   */
    ResultSetType resultSetType() default ResultSetType.DEFAULT;

    /**
   * Return the statement type.
   * 语句类型
   *
   * @return the statement type
   */
    StatementType statementType() default StatementType.PREPARED;

    /**
   * Returns the fetch size.
   * 加载数量
   *
   * @return the fetch size
   */
    int fetchSize() default -1;

    /**
   * Returns the statement timeout.
   * 超时时间
   *
   * @return the statement timeout
   */
    int timeout() default -1;

    /**
   * Returns whether use the generated keys feature supported by JDBC 3.0
   * 是否生成主键
   *
   * @return {@code true} if use; {@code false} if otherwise
   */
    boolean useGeneratedKeys() default false;

    /**
   * Returns property names that holds a key value.
   * 主键在 Java 类中的属性
   * <p>
   * If you specify multiple property, please separate using comma(',').
   *
   * @return property names that separate with comma(',')
   */
    String keyProperty() default "";

    /**
   * Returns column names that retrieves a key value.
   * 主键在数据库中的字段
   * <p>
   * If you specify multiple column, please separate using comma(',').
   *
   * @return column names that separate with comma(',')
   */
    String keyColumn() default "";

    /**
   * Returns result set names.
   * 结果集
   * <p>
   * If you specify multiple result set, please separate using comma(',').
   *
   * @return result set names that separate with comma(',')
   */
    String resultSets() default "";

    /**
   * @return A database id that correspond this options
   *
   * @since 3.5.5
   */
    String databaseId() default "";

    /**
   * The container annotation for {@link Options}.
   * Options的容器式注解
   *
   * @author Kazuki Shimizu
   *
   * @since 3.5.5
   */
    @Documented
    @Retention(RetentionPolicy.RUNTIME)
    @Target(ElementType.METHOD)
    @interface List {
        Options[] value();
    }

}
```

示例1：获取自增主键（MySQL）

```java
@Insert("INSERT INTO user(name, age) VALUES(#{name}, #{age})")
@Options(useGeneratedKeys = true, keyProperty = "id", keyColumn = "id")
int insertUser(User user); // 插入后，user对象的id属性会被自动赋值
```

- **`useGeneratedKeys=true`**：启用数据库生成的主键。
- **`keyProperty="id"`**：将主键值赋给 `user.id` 属性。

示例2：配置超时和缓存行为

```java
@Update("UPDATE user SET name = #{name} WHERE id = #{id}")
@Options(timeout = 5, flushCache = Options.FlushCachePolicy.TRUE)
int updateUserName(User user); // 设置5秒超时，并刷新缓存
```



##### 8.@SelectKey

`@SelectKey` 注解用于在插入或更新操作前后获取数据库生成的主键或序列值，特别适用于不支持自动生成主键的数据库（如 Oracle）

```java
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
@Repeatable(SelectKey.List.class)
public @interface SelectKey {
    /**
   * Returns an SQL for retrieving a key value.
   * 获取键值的 SQL 语句（如查询序列或触发器的 SQL）
   *
   * @return an SQL for retrieving a key value
   */
    String[] statement();

    /**
   * Returns property names that holds a key value.
   * 将键值赋给参数对象的哪个属性（支持逗号分隔多个属性）
   * <p>
   * If you specify multiple property, please separate using comma(',').
   *
   * @return property names that separate with comma(',')
   */
    String keyProperty();

    /**
   * Returns column names that retrieves a key value.
   * 数据库中的键列名（当列名与属性名不一致时指定）
   * <p>
   * If you specify multiple column, please separate using comma(',').
   *
   * @return column names that separate with comma(',')
   */
    String keyColumn() default "";

    /**
   * Returns whether retrieves a key value before executing insert/update statement.
   * true：在插入/更新前执行；false：在插入/更新后执行。
   *
   * @return {@code true} if execute before; {@code false} if otherwise
   */
    boolean before();

    /**
   * Returns the key value type.
   * 键值的数据类型（如 Long.class、String.class）
   *
   * @return the key value type
   */
    Class<?> resultType();

    /**
   * Returns the statement type to use.
   * SQL 执行方式（默认 PREPARED，可选 STATEMENT/CALLABLE）
   *
   * @return the statement type
   */
    StatementType statementType() default StatementType.PREPARED;

    /**
   * @return A database id that correspond this select key
   * 指定数据库厂商 ID（用于多数据库支持）
   *
   * @since 3.5.5
   */
    String databaseId() default "";

    /**
   * The container annotation for {@link SelectKey}.
   * SelectKey的容器式注解
   *
   * @author Kazuki Shimizu
   *
   * @since 3.5.5
   */
    @Documented
    @Retention(RetentionPolicy.RUNTIME)
    @Target(ElementType.METHOD)
    @interface List {
        SelectKey[] value();
    }

}
```



##### 9.@MapKey

`@MapKey` 是 MyBatis 中用于**指定 Map 类型返回结果的键（Key）**的注解，主要用在方法返回类型为 `Map` 或 `Map` 的子类时，明确指定使用结果对象的哪个属性作为 Map 的 Key。当查询返回 `Map` 时，默认以数据库的主键列作为 Key。通过 `@MapKey` 可以指定使用结果对象的任意属性作为 Key。（注意：确保 Map 的 Key 唯一性，避免数据覆盖）

```java
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface MapKey {
    /**
   * Returns the property name(or column name) for a key value of {@link java.util.Map}.
   * 返回{@link java.util.Map}键值的属性名（或列名）
   *
   * @return the property name(or column name)
   */
    String value();
}
```

使用示例：MySQL 自增主键（插入后获取 ID）

```java
@Insert("INSERT INTO users(name) VALUES(#{name})")
@SelectKey(
    statement = "SELECT LAST_INSERT_ID()",
    keyProperty = "id",
    before = false,  // 在INSERT后执行
    resultType = Long.class
)
int insertUser(User user);
```

执行流程：

1. 先执行 `INSERT`。
2. 再执行 `SELECT LAST_INSERT_ID()` 获取自增 ID。
3. 将 ID 赋给 `user.id`



##### 10.@Flush

如果使用了这个注解，定义在 Mapper 接口中的方法能够调用 `SqlSession#flushStatements()` 方法。（Mybatis 3.3及以上）

```java
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Flush {
}
```



#### 3、其他注解

- @Mapper
- @Lang

- `@TypeDiscriminator` + `@Case`
- `@ConstructorArgs` + `@Arg`
- `@AutomapConstructor`

