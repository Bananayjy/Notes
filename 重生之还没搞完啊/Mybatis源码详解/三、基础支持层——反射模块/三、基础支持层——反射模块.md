# 三、基础支持层——反射模块

##  一、前言

### 1.1 内容结构

MyBatis 的反射模块，对应 `reflection` 包下的内容

![image-20250121152010148](%E4%B8%89%E3%80%81%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82%E2%80%94%E2%80%94%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9D%97.assets/image-20250121152010148.png)

### 1.2 主要功能

> Java 中的反射虽然功能强大，但对大多数开发人员来说，写出高质量的反射代码还是 有一定难度的。MyBatis 中专门提供了反射模块，该模块对 Java 原生的反射进行了良好的封装，提了更加**简洁易用的 API**，方便上层使调用，并且对**反射操作进行了一系列优化**，例如缓存了类的元数据，提高了反射操作的性能。



## 二、相关内容

### 2.1 Reflector

Reflector类(反射器)位于`org.apache.ibatis.reflection.Reflector`包下,个 Reflector 对应一个类。Reflector 会**缓存**反射操作需要的类的信息，例如：构造方法、属性名、setting / getting 方法等等。

#### 1.属性/成员变量

```java

// ……
private static final MethodHandle isRecordMethodHandle = getIsRecordMethodHandle();

// 每个Reflector对象对应的类的类对象
private final Class<?> type;

// 可读属性集合
private final String[] readablePropertyNames;

//可写属性集合
private final String[] writablePropertyNames;

/**
* 属性对应的 setting 方法的映射。
*
* key 为属性名称
* value 为 Invoker 对象
*/
private final Map<String, Invoker> setMethods = new HashMap<>();

/**
* 属性对应的 getting 方法的映射。
*
* key 为属性名称
* value 为 Invoker 对象
*/
private final Map<String, Invoker> getMethods = new HashMap<>();

 /**
* 属性对应的 setting 方法的方法参数类型的映射。{@link #setMethods}
*
* key 为属性名称
* value 为方法参数类型
*/
private final Map<String, Class<?>> setTypes = new HashMap<>();

/**
* 属性对应的 getting 方法的返回值类型的映射。{@link #getMethods}
*
* key 为属性名称
* value 为返回值的类型
*/
private final Map<String, Class<?>> getTypes = new HashMap<>();

/**
* 默认构造方法（默认为无参构造方法）
*/
private Constructor<?> defaultConstructor;

/**
* 不区分大小写的属性集合
*/
private final Map<String, String> caseInsensitivePropertyMap = new HashMap<>();
```



#### 2.构造函数

```java
public Reflector(Class<?> clazz) {
    
    // 设置对应的类对象给当前Reflector对象的成员变量 Class<?> type
    type = clazz;
    
    // <1> 初始化defualtConstructor
    addDefaultConstructor(clazz);
    
    // <2> 获取当前类对象的方法，并赋值给classMethods局部变量
    Method[] classMethods = getClassMethods(clazz);
    
    // <3> jdk 高版本的record内容
    if (isRecord(type)) {
        // 加入Record类的get方法
        addRecordGetMethods(classMethods);
    } else {
        // <4> 初始化 getMethods 和 getTypes，通过遍历getting方法
        addGetMethods(classMethods);
        // <5> 初始化 setMethods 和 setTypes，通过遍历setting方法
        addSetMethods(classMethods);
        // <6> 初始化 getMethods + getTypes 和 setMethods + setTypes
        addFields(clazz);
    }
    // 初始化 readablePropertyNames、writeablePropertyNames、caseInsensitivePropertyMap 属性 
    // 将getting方法的key赋值给String字符串可读属性集合
    readablePropertyNames = getMethods.keySet().toArray(new String[0]);
    // 将setting方法的key赋值给String字符串可写属性集合
    writablePropertyNames = setMethods.keySet().toArray(new String[0]);
    // 将可读属性集合以小写的方式赋值给不区分大小写的属性集合
    for (String propName : readablePropertyNames) {
        caseInsensitivePropertyMap.put(propName.toUpperCase(Locale.ENGLISH), propName);
    }
    // 将可写属性集合以小写的方式赋值给不区分大小写的属性集合
    for (String propName : writablePropertyNames) {
        caseInsensitivePropertyMap.put(propName.toUpperCase(Locale.ENGLISH), propName);
    }
}
```



##### <1> 初始化defualtConstructor

addDefaultConstructor方法查找默认的午餐构造器，并将其赋值给defaultConstructor对象

```java
private void addDefaultConstructor(Class<?> clazz) {
    
    // 获取当前类对象中所有构造方法
    Constructor<?>[] constructors = clazz.getDeclaredConstructors();
    // 将当前Constructor数组转化为stream对象
    Arrays.stream(constructors)
        // 获取无参构造方法
        .filter(constructor -> constructor.getParameterTypes().length == 0)
        // 找到一个
        .findAny()
        // 如果存在无参构造方法，就赋值给当前Reflector对象的成员变量defaultConstructor
        .ifPresent(constructor -> this.defaultConstructor = constructor);
}
```

> 在先前的版本，可能需要设置构造方法可以访问，避免private修饰方法，相关代码如下所示：
>
> ```java
> private void addDefaultConstructor(Class<?> clazz) {
>     // 获得所有构造方法
>     Constructor<?>[] consts = clazz.getDeclaredConstructors();
>     // 遍历所有构造方法，查找无参的构造方法
>     for (Constructor<?> constructor : consts) {
>         // 判断无参的构造方法
>         if (constructor.getParameterTypes().length == 0) {
>             // 设置构造方法可以访问，避免是 private 等修饰符
>             if (canControlMemberAccessible()) {
>                 try {
>                     constructor.setAccessible(true);
>                 } catch (Exception e) {
>                     // Ignored. This is only a final precaution, nothing we can do.
>                 }
>             }
>             // 如果构造方法可以访问，赋值给 defaultConstructor
>             if (constructor.isAccessible()) {
>                 this.defaultConstructor = constructor;
>             }
>         }
>     }
> }
> 
> /**
>  * Checks whether can control member accessible.
>  *
>  * 判断，是否可以修改可访问性
>  *
>  * @return If can control member accessible, it return {@literal true}
>  * @since 3.5.0
>  */
> public static boolean canControlMemberAccessible() {
>     try {
>         SecurityManager securityManager = System.getSecurityManager();
>         if (null != securityManager) {
>             securityManager.checkPermission(new ReflectPermission("suppressAccessChecks"));
>         }
>     } catch (SecurityException e) {
>         return false;
>     }
>     return true;
> }
> ```



##### <2> 获取当前类对象的方法

```java
/**
* This method returns an array containing all methods declared in this class and any superclass. We use this method,
* instead of the simpler <code>Class.getMethods()</code>, because we want to look for private methods as well.
* 此方法返回一个数组，其中包含在该类和任何超类中声明的所有方法，我们使用这个方法，而不是更简单的Class.getMethods()，因为我们也想寻找私有方法
* @param clazz
*          The class
*
* @return An array containing all methods in this class
*/
private Method[] getClassMethods(Class<?> clazz) {

    // 声明一个局部变量，用来存放所有方法（unique唯一，一个方法名一个方法）
    Map<String, Method> uniqueMethods = new HashMap<>();

    // 获取当前需要反射对象的类对象
    Class<?> currentClass = clazz;

    // 如果当前对象 不为null 并且 不是Object类（所有类的父类） 
    // 递归添加方法
    while (currentClass != null && currentClass != Object.class) {

        addUniqueMethods(uniqueMethods, currentClass.getDeclaredMethods());

        // we also need to look for interface methods -
        // because the class may be abstract
        // 将接口方法也加入
        Class<?>[] interfaces = currentClass.getInterfaces();
        for (Class<?> anInterface : interfaces) {
            addUniqueMethods(uniqueMethods, anInterface.getMethods());
        }

        // 设置当前类为当前类的父类，递归查找所有方法
        currentClass = currentClass.getSuperclass();
    }

    // 获取当前获取的所有方法（接口、普通、抽象类），并以数组方式返回
    Collection<Method> methods = uniqueMethods.values();
    return methods.toArray(new Method[0]);
}

// 将当前类中的方法加入到uniqueMethods的map中
private void addUniqueMethods(Map<String, Method> uniqueMethods, Method[] methods) {
    // 遍历当前类下的所有方法
    for (Method currentMethod : methods) {

        // 判断当前方法不是桥接的方法
        if (!currentMethod.isBridge()) {
            String signature = getSignature(currentMethod);
            // check to see if the method is already known
            // if it is known, then an extended class must have
            // overridden a method
            if (!uniqueMethods.containsKey(signature)) {
                uniqueMethods.put(signature, currentMethod);
            }	
        }
    }
}

// 获取当前方法的签名（用于map中的key） 结果示例：java.lang.Object#getId
private String getSignature(Method method) {
    // 获取StringBuilder
    StringBuilder sb = new StringBuilder();
    // 获取当前方法的返回类型的类对象
    Class<?> returnType = method.getReturnType();
    sb.append(returnType.getName()).append('#');
    sb.append(method.getName());
    Class<?>[] parameters = method.getParameterTypes();
    for (int i = 0; i < parameters.length; i++) {
        sb.append(i == 0 ? ':' : ',').append(parameters[i].getName());
    }
    return sb.toString();
}
```

> 相关问题：
>
> 1、isBridge桥接方法 
>
> 参考文章：https://blog.csdn.net/gongm24/article/details/121440121
>



##### <3> jdk 高版本的record内容

参考文章：

- https://blog.csdn.net/weixin_65032328/article/details/138043991

- https://blog.csdn.net/weixin_50843918/article/details/122849956

判断代码如下所示：

```java
/**
* Class.isRecord() alternative for Java 15 and older.
*/
private static boolean isRecord(Class<?> clazz) {
    try {
        return isRecordMethodHandle != null && (boolean) isRecordMethodHandle.invokeExact(clazz);
    } catch (Throwable e) {
        throw new ReflectionException("Failed to invoke 'Class.isRecord()'.", e);
    }
}
```



##### <4> 初始化 getMethods 和 getTypes，通过遍历getting方法

对于`getMethods`、`getTypes` 属性，分别为属性对应的 getting 方法、getting 方法的返回类型的映射

```java
// 这里的mehtod数组包括的当前类和父类中的所有方法，包括重写的方法
private void addGetMethods(Method[] methods) {
    // 存放属性与其getting方法的映射
    Map<String, List<Method>> conflictingGetters = new HashMap<>();
    // 将当前类中的所有方法转换成Stream流
    Arrays.stream(methods)
        // 过滤参数==0的（如果大于0即不是getting方法，忽略） 以及 以get和is方法开头的方法（通过1.PropertyNamer的静态方法isGetter去判断）
        .filter(m -> m.getParameterTypes().length == 0 && PropertyNamer.isGetter(m.getName()))
        // 3.调用addMethodConflict方法添加到confictingGetters属性中
        // 2.调用PropertyNamer.methodToProperty方法，获得属性名
        .forEach(m -> addMethodConflict(conflictingGetters, PropertyNamer.methodToProperty(m.getName()), m));
    // 4.解决 getting 冲突方法
    resolveGetterConflicts(conflictingGetters);
}
```

1.PropertyNamer的静态方法isGetter去判断是否是get和is方法开头的方法

```java
public static boolean isGetter(String name) {
    return name.startsWith("get") && name.length() > 3 || name.startsWith("is") && name.length() > 2;
}
```

2.调用PropertyNamer的静态方法methodToProperty获取属性名

> 示例：
>
> - isAbc：abc
> - isAAA：AAA
> - isAaBbCc：aaBbCc

```java
public static String methodToProperty(String name) {
    // 去前缀is、get、set
    if (name.startsWith("is")) {
        name = name.substring(2);
    } else if (name.startsWith("get") || name.startsWith("set")) {
        name = name.substring(3);
    } else {
        throw new ReflectionException(
            "Error parsing property name '" + name + "'.  Didn't start with 'is', 'get' or 'set'.");
    }

    // 去前缀后的属性名长度为1  或者  属性名长度大于1并且第2个单词是小写
    // 将其第一个字母转换为小写
    if (name.length() == 1 || name.length() > 1 && !Character.isUpperCase(name.charAt(1))) {
        name = name.substring(0, 1).toLowerCase(Locale.ENGLISH) + name.substring(1);
    }

    // 返回属性名
    return name;
}
```

3.调用addMethodConflict方法添加到confictingGetters属性中

```java
private void addMethodConflict(Map<String, List<Method>> conflictingMethods, String name, Method method) {
    // 校验是否以$开头，并且不是class和serialVersionUID作为关键字
    if (isValidPropertyName(name)) {
        // 将当前get方法加入到conflictingMethods中，以属性名作为key，method作为value
        // 先获取value的引用对象，再进行加入
        List<Method> list = MapUtil.computeIfAbsent(conflictingMethods, name, k -> new ArrayList<>());
        list.add(method);
    }
}
```

isValidPropertyName方法：

```java
private boolean isValidPropertyName(String name) {
    return !name.startsWith("$") && !"serialVersionUID".equals(name) && !"class".equals(name);
}
```

4.resolveGetterConflicts方法解决getting 冲突方法

这段代码的核心逻辑是通过比较getter方法的返回类型来解决多个getter方法之间的冲突。它优先选择返回类型更具体（子类）的方法，并且在某些情况下（如返回类型相同且不是 `boolean` 类型）会标记为歧义。最终，代码会将最合适的getter方法与属性名一起传递给 `addGetMethod` 方法进行进一步处理。

```java
private void resolveGetterConflicts(Map<String, List<Method>> conflictingGetters) {
    // 遍历每个属性，查找其最匹配的方法。因为子类可以覆写父类的方法，所以一个属性，可能对应多个 getting 方法
    for (Entry<String, List<Method>> entry : conflictingGetters.entrySet()) {
        // 记录最匹配的方法
        Method winner = null;
        // 获取当前属性名
        String propName = entry.getKey();
        // 标记是否存在歧义（即无法确定最合适的getter方法），即无法查找到最佳匹配
        boolean isAmbiguous = false;
        for (Method candidate : entry.getValue()) {
            // winner 为空，说明 candidate 为最匹配的方法（默认）
            if (winner == null) {
                winner = candidate;
                continue;
            }
            // 基于返回类型比较
            Class<?> winnerType = winner.getReturnType();
            Class<?> candidateType = candidate.getReturnType();
            // 如果返回类型相同
            if (candidateType.equals(winnerType)) {
                // 如果返回类型不是 boolean，则标记为歧义（isAmbiguous = true）并跳出循环
                if (!boolean.class.equals(candidateType)) {
                    isAmbiguous = true;
                    break;
                }
                // 如果返回类型是 boolean，并且 candidate 的方法名以 "is" 开头，则将 candidate 赋值给 winner（优选选择is方法）
                if (candidate.getName().startsWith("is")) {
                    winner = candidate;
                }
            } else if (candidateType.isAssignableFrom(winnerType)) {
                // 如果 candidate 的返回类型是 winner 返回类型的子类，则不做处理（winner 保持不变）
                // OK getter type is descendant
            } else if (winnerType.isAssignableFrom(candidateType)) {
                // 如果 winner 的返回类型是 candidate 返回类型的子类，则将 candidate 赋值给 winner
                winner = candidate;
            } else {
                // 如果返回类型不兼容（既不是子类也不是父类），则标记为歧义并跳出循环
                isAmbiguous = true;
                break;
            }
        }
        // 将属性名、最匹配的getter方法（winner）以及是否存在歧义（isAmbiguous）传递给 addGetMethod 方法进行处理
        // 添加到 getMethods 和 getTypes 中
        addGetMethod(propName, winner, isAmbiguous);
    }
}
```

> 相关问题：
>
> 1、isAssignableFrom是什么？
>
> ```java
> /**
>  * Determines if the class or interface represented by this
>  * {@code Class} object is either the same as, or is a superclass or
>  * superinterface of, the class or interface represented by the specified
>  * {@code Class} parameter. It returns {@code true} if so;
>  * otherwise it returns {@code false}. If this {@code Class}
>  * object represents a primitive type, this method returns
>  * {@code true} if the specified {@code Class} parameter is
>  * exactly this {@code Class} object; otherwise it returns
>  * {@code false}.
>  *
>  * <p> Specifically, this method tests whether the type represented by the
>  * specified {@code Class} parameter can be converted to the type
>  * represented by this {@code Class} object via an identity conversion
>  * or via a widening reference conversion. See <cite>The Java Language
>  * Specification</cite>, sections {@jls 5.1.1} and {@jls 5.1.4},
>  * for details.
>  *
>  * @param     cls the {@code Class} object to be checked
>  * @return    the {@code boolean} value indicating whether objects of the
>  *            type {@code cls} can be assigned to objects of this class
>  * @throws    NullPointerException if the specified Class parameter is
>  *            null.
>  * @since     1.1
>  */
> @IntrinsicCandidate
> public native boolean isAssignableFrom(Class<?> cls);
> ```
>
> 在 Java 中，`Class` 类的 `isAssignableFrom(Class<?> cls)` 方法是一个非常重要的方法，用于判断一个类是否可以被另一个类赋值（即是否是其父类、接口或自身）。它的作用是检查当前 `Class` 对象所代表的类或接口是否是指定 `Class` 参数所代表的类或接口的父类、超接口或本身。
>
> - **`@IntrinsicCandidate`**：
>   这是一个注解，表示该方法可能是由 JVM 内部实现的（即 JVM 可能会对其进行特殊优化）。
> - **`native`**：
>   表示该方法的实现是由本地代码（通常是 C/C++）提供的，而不是用 Java 实现的。
> - **返回值**：
>   - `true`：如果当前 `Class` 对象所代表的类或接口是指定 `Class` 参数所代表的类或接口的父类、超接口或本身。
>   - `false`：否则。
>
> 方法的作用：
>
> `isAssignableFrom` 方法用于判断一个类或接口是否可以赋值给另一个类或接口。具体来说：
>
> - 如果 `A.isAssignableFrom(B)` 返回 `true`，则表示 `B` 可以赋值给 `A`，即：
>   - `B` 是 `A` 的子类。
>   - `B` 实现了 `A` 接口。
>   - `B` 和 `A` 是同一个类或接口。
>
> 2、为什么要这么去选择最佳匹配的方法？
>
> **`boolean` 类型的特殊性**：
> 对于 `boolean` 类型的属性，Java Bean 规范允许两种命名方式的getter方法：
>
> - 以 `get` 开头的方法，例如 `getEnabled()`。
> - 以 `is` 开头的方法，例如 `isEnabled()`。
>   因此，如果返回类型是 `boolean`，代码可以通过方法名（优先选择 `is` 开头的方法）来进一步区分，从而避免歧义。
>
> **非 `boolean` 类型的问题**：
> 对于非 `boolean` 类型的属性，如果存在多个返回类型相同的getter方法，代码无法通过方法名或其他规则来确定哪个方法更合适。因此，直接标记为歧义
>
> 并且基于返回类型比较。重点在 `<1.1>` 和 `<1.2>` 的情况，因为子类可以修改放大返回值，**所以在出现这个情况时，选择子类的该方法**。例如，父类的一个方法的返回值为 List ，子类对该方法的返回值可以覆写为 ArrayList 。

关于addGetMethod(propName, winner, isAmbiguous)方法

```java
private void addGetMethod(String name, Method method, boolean isAmbiguous) {
    // 判断是否有歧义，有歧义封装成AmbiguousMethodInvoker（MethodInvoker子类），没歧义将该方法封装成一个 ①MethodInvoker
    MethodInvoker invoker = isAmbiguous ? new AmbiguousMethodInvoker(method, MessageFormat.format(
        "Illegal overloaded getter method with ambiguous type for property ''{0}'' in class ''{1}''. This breaks the JavaBeans specification and can cause unpredictable results.",
        name, method.getDeclaringClass().getName())) : new MethodInvoker(method);
    // 以属性名作为key，invoker作为value放入getMethods属性对象中
    getMethods.put(name, invoker);
    
    // ②调用TypeParameterResolver的resolveReturnType方法获取Type对象
    Type returnType = TypeParameterResolver.resolveReturnType(method, type);
    // ③通过typeToClass将type转化为对应的class对象，并放入到getTypes属性对象中
    // 同样以属性名作为key，返回参数的class对象作为value
    getTypes.put(name, typeToClass(returnType));
}
```

①MethodInvoker

跳转到2.3中查看详细介绍

②调用TypeParameterResolver的resolveReturnType方法获取Type对象

##### （△）14

③通过typeToClass将type转化为对应的class对象，并放入到getTypes属性对象中

首先看一下typeToClass方法，其是Reflector对象中的方法，用于寻找 Type 真正对应的类，并返回

```java
private Class<?> typeToClass(Type src) {
    // 设置返回类型先为null
    Class<?> result = null;
    if (src instanceof Class) {
        // 普通类型，直接使用类
        result = (Class<?>) src;
    } else if (src instanceof ParameterizedType) {
        // 泛型类型，使用泛型
        result = (Class<?>) ((ParameterizedType) src).getRawType();
    } else if (src instanceof GenericArrayType) {
        // 泛型数组，获得具体类
        Type componentType = ((GenericArrayType) src).getGenericComponentType();
        if (componentType instanceof Class) {
            // 普通类型
            result = Array.newInstance((Class<?>) componentType, 0).getClass();
        } else {
            // 递归该方法，返回类
            Class<?> componentClass = typeToClass(componentType);
            result = Array.newInstance(componentClass, 0).getClass();
        }
    }
    // 都不符合，使用 Object 类
    if (result == null) {
        result = Object.class;
    }
    // 返回class对象
    return result;
}
```



##### <5> 初始化 setMethods 和 setTypes，通过遍历setting方法

`#addSetMethods(Class<?> cls)` 方法，初始化 `setMethods` 和 `setTypes` ，通过遍历 setting 方法，其本质上和addGetMethods类似。

```java
private void addSetMethods(Method[] methods) {
    Map<String, List<Method>> conflictingSetters = new HashMap<>();
    Arrays.stream(methods).filter(m -> m.getParameterTypes().length == 1 && PropertyNamer.isSetter(m.getName()))
        .forEach(m -> addMethodConflict(conflictingSetters, PropertyNamer.methodToProperty(m.getName()), m));
    resolveSetterConflicts(conflictingSetters);
}
```

主要区别在于其resolveSetterConflicts方法去解决setting冲突方法的过程中

```java
private void resolveSetterConflicts(Map<String, List<Method>> conflictingSetters) {
    // 遍历每个属性，查找其最匹配的方法。因为子类可以覆写父类的方法，所以一个属性，可能对应多个 setting 方法
    for (Entry<String, List<Method>> entry : conflictingSetters.entrySet()) {
        // 当前属性名称
        String propName = entry.getKey();
        // 当前属性对应的所有setting方法
        List<Method> setters = entry.getValue();
        // 获取当前属性的返回类型（从之前查找get方法的时候获取）
        Class<?> getterType = getTypes.get(propName);
        // 判断当前属性的getting方法是否有歧义
        boolean isGetterAmbiguous = getMethods.get(propName) instanceof AmbiguousMethodInvoker;
        // 标记setting方法是否有歧义
        boolean isSetterAmbiguous = false;
        // 匹配的Method
        Method match = null;
        for (Method setter : setters) {
            // 当前属性的getting方法没有歧义，并且setting方法的入参和getting方法的返回类型一直，则直接匹配使用
            if (!isGetterAmbiguous && setter.getParameterTypes()[0].equals(getterType)) {
                // should be the best match
                match = setter;
                break;
            }、
             // 当前setting方法没有歧义
            if (!isSetterAmbiguous) {
                // 选择一个更加匹配的
                match = pickBetterSetter(match, setter, propName);
                isSetterAmbiguous = match == null;
            }
        }
        // 添加到 setMethods 和 setTypes 中
        if (match != null) {
            addSetMethod(propName, match);
        }
    }
}
```

pickBetterSetter方法如下，选择一个更加匹配的，和 getting 方法是**相同**的，因为要选择精准的方法（即类型可以精确到子类，就用这个精确到子类的）

```java
private Method pickBetterSetter(Method setter1, Method setter2, String property) {
    if (setter1 == null) {
        return setter2;
    }
    Class<?> paramType1 = setter1.getParameterTypes()[0];
    Class<?> paramType2 = setter2.getParameterTypes()[0];
    if (paramType1.isAssignableFrom(paramType2)) {
        return setter2;
    }
    if (paramType2.isAssignableFrom(paramType1)) {
        return setter1;
    }
    MethodInvoker invoker = new AmbiguousMethodInvoker(setter1,
                                                       MessageFormat.format(
                                                           "Ambiguous setters defined for property ''{0}'' in class ''{1}'' with types ''{2}'' and ''{3}''.", property,
                                                           setter2.getDeclaringClass().getName(), paramType1.getName(), paramType2.getName()));
    setMethods.put(property, invoker);
    Type[] paramTypes = TypeParameterResolver.resolveParamTypes(setter1, type);
    setTypes.put(property, typeToClass(paramTypes[0]));
    return null;
}
```

调用addSetMethod，将对应的方法和参数类型设置给属性变量setMethods和setTypes

```java
private void addSetMethod(String name, Method method) {
    MethodInvoker invoker = new MethodInvoker(method);
    setMethods.put(name, invoker);
    Type[] paramTypes = TypeParameterResolver.resolveParamTypes(method, type);
    setTypes.put(name, typeToClass(paramTypes[0]));
}
```



##### <6> 初始化 getMethods + getTypes 和 setMethods + setTypes

`#addFields(Class<?> clazz)` 方法，初始化 `getMethods` + `getTypes` 和 `setMethods` + `setTypes` ，通过遍历 fields 属性。实际上，它是 `#addGetMethods(...)` 和 `#addSetMethods(...)` 方法的补充，因为有些 field ，不存在对应的 setting 或 getting 方法，**所以直接使用对应的 field** ，而不是方法。代码如下

```java
private void addFields(Class<?> clazz) {
    // 获得当前对象的所有fields
    Field[] fields = clazz.getDeclaredFields();
    for (Field field : fields) {
        // 将不存在setting方法的field添加到 setMethods 和 setTypes 中
        if (!setMethods.containsKey(field.getName())) {
            // issue #379 - removed the check for final because JDK 1.5 allows
            // modification of final fields through reflection (JSR-133). (JGB)
            // pr #16 - final static can only be set by the classloader
            // 获取字段的修饰符（表示该字段的所有修饰符（如 public、private、static、final 等））
            int modifiers = field.getModifiers();
            // 排除nal和static的属性（如上所述，final和static只能被类加载器进行set
            // 修饰符是以位掩码（bitmask）的形式存储的，可以通过 java.lang.reflect.Modifier 类中的静态方法（如 Modifier.isStatic、Modifier.isFinal 等）来检查具体的修饰符
            if (!Modifier.isFinal(modifiers) || !Modifier.isStatic(modifiers)) {
                addSetField(field);
            }
        }
         // 添加到 getMethods 和 getTypes 中
        if (!getMethods.containsKey(field.getName())) {
            addGetField(field);
        }
    }
    // 递归当前对象的父类
    if (clazz.getSuperclass() != null) {
        addFields(clazz.getSuperclass());
    }
}
```

addSetField方法：

```java
private void addSetField(Field field) {
    // 校验是否以$开头，并且不是class和serialVersionUID作为关键字
    if (isValidPropertyName(field.getName())) {
        // 添加到 setMethods 中
        setMethods.put(field.getName(), new SetFieldInvoker(field));
        // 添加到 setTypes 中
        Type fieldType = TypeParameterResolver.resolveFieldType(field, type);
        setTypes.put(field.getName(), typeToClass(fieldType));
    }
}
```

addGetField方法：

```java
private void addGetField(Field field) {
    // 校验是否以$开头，并且不是class和serialVersionUID作为关键字
    if (isValidPropertyName(field.getName())) {
         // 添加到 getMethods 中
        getMethods.put(field.getName(), new GetFieldInvoker(field));
         // 添加到 getTypes 中
        Type fieldType = TypeParameterResolver.resolveFieldType(field, type);
        getTypes.put(field.getName(), typeToClass(fieldType));
    }
}
```

##### △这里的GetFieldInvoker和SetFieldInvoker



### 2.2 ReflectorFactory

`org.apache.ibatis.reflection.ReflectorFactory`,其是Reflector对象的工厂接口，用于创建和缓存 Reflector 对象。

```java
public interface ReflectorFactory {

	// 是否缓存Reflector对象
    boolean isClassCacheEnabled();

    // 设置是否缓存 Reflector 对象
    // @param classCacheEnabled 是否缓存
    void setClassCacheEnabled(boolean classCacheEnabled);

    // 获取 Reflector 对象
    // @param type 指定类
    // @return Reflector 对象
    Reflector findForClass(Class<?> type);
}
```

其默认实现类是`org.apache.ibatis.reflection.DefaultReflectorFactory`,相关源码如下所示

```java
public class DefaultReflectorFactory implements ReflectorFactory {
    // 是否缓存
    private boolean classCacheEnabled = true;
    // Reflector 的缓存映射
    // key：类  value：Reflector 对象
    private final ConcurrentMap<Class<?>, Reflector> reflectorMap = new ConcurrentHashMap<>();

    // 无参构造器
    public DefaultReflectorFactory() {
    }

    @Override
    public boolean isClassCacheEnabled() {
        return classCacheEnabled;
    }

    @Override
    public void setClassCacheEnabled(boolean classCacheEnabled) {
        this.classCacheEnabled = classCacheEnabled;
    }

    @Override
    public Reflector findForClass(Class<?> type) {
        // 开启缓存，则从 reflectorMap 中获取
        if (classCacheEnabled) {
            // synchronized (type) removed see issue #461
            return MapUtil.computeIfAbsent(reflectorMap, type, Reflector::new);
        }
        // 关闭缓存，则创建 Reflector 对象
        return new Reflector(type);
    }

}
```



### 2.3 Invoker

#### 1.Invoker

`org.apache.ibatis.reflection.invoker`接口相关内容如下所示：

![image-20250322151912972](%E4%B8%89%E3%80%81%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82%E2%80%94%E2%80%94%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9D%97.assets/image-20250322151912972.png)

其源码如下所示：

```java
public interface Invoker {
    /**
     * 执行一次调用，具体调用的方法由子类来实现
     *
     * @param target 目标
     * @param args 参数
     * @return 结果
     * @throws IllegalAccessException
     * @throws InvocationTargetException
     */
    Object invoke(Object target, Object[] args) throws IllegalAccessException, InvocationTargetException;

    /**
     * @return 类
     */
    Class<?> getType();
}
```

#### 2.GetFieldInvoker

该实现类用于获取Field

```java
public class GetFieldInvoker implements Invoker {
    // Field 对象
    private final Field field;

    // 获取field对象
    public GetFieldInvoker(Field field) {
        this.field = field;
    }

    // 获得属性
    @Override
    public Object invoke(Object target, Object[] args) throws IllegalAccessException {
        try {
            return field.get(target);
        } catch (IllegalAccessException e) {
            // 如果是IllegalAccessException异常，检查是否可以控制字段的可访问性
            if (Reflector.canControlMemberAccessible()) {
                // 设置字段为可访问
                field.setAccessible(true);
                // 再次尝试获取字段的值
                return field.get(target);
            }
            throw e;
        }
    }

    // 返回属性类型
    @Override
    public Class<?> getType() {
        return field.getType();
    }
}
```



#### 3.SetFieldInvoker

该实现类用于设置 Field 

```java
public class SetFieldInvoker implements Invoker {
    
    // Field 对象
    private final Field field;

    public SetFieldInvoker(Field field) {
        this.field = field;
    }

    // 设置 Field 属性
    @Override
    public Object invoke(Object target, Object[] args) throws IllegalAccessException {
        try {
            field.set(target, args[0]);
        } catch (IllegalAccessException e) {
            if (!Reflector.canControlMemberAccessible()) {
                throw e;
            }
            field.setAccessible(true);
            field.set(target, args[0]);
        }
        return null;
    }

    // 返回属性类型
    @Override
    public Class<?> getType() {
        return field.getType();
    }
}
```



#### 4.MethodInvoker

该实现用于指定方法的调用

```java
public class MethodInvoker implements Invoker {

    // 类型
    private final Class<?> type;
    // 指定方法
    private final Method method;

    public MethodInvoker(Method method) {
        this.method = method;
		// 参数大小为 1 时，一般是 setting 方法，设置 type 为方法参数[0]
        if (method.getParameterTypes().length == 1) {
            type = method.getParameterTypes()[0];
        } else {
            // 否则，一般是 getting 方法，设置 type 为返回类型
            type = method.getReturnType();
        }
    }

    // 执行指定方法
    @Override
    public Object invoke(Object target, Object[] args) throws IllegalAccessException, InvocationTargetException {
        try {
            return method.invoke(target, args);
        } catch (IllegalAccessException e) {
            if (Reflector.canControlMemberAccessible()) {
                method.setAccessible(true);
                return method.invoke(target, args);
            }
            throw e;
        }
    }

    // 返回类型
    @Override
    public Class<?> getType() {
        return type;
    }
}
```



#### 5.AmbiguousMethodInvoker

其是MethodInvoker的实现类，异常方法的调用者

```java
public class AmbiguousMethodInvoker extends MethodInvoker {
    
    // 异常信息
    private final String exceptionMessage;

    // 构造器（保存异常信息）
    public AmbiguousMethodInvoker(Method method, String exceptionMessage) {
        super(method);
        this.exceptionMessage = exceptionMessage;
    }

    // 调用invoke，直接抛出异常
    @Override
    public Object invoke(Object target, Object[] args) throws IllegalAccessException, InvocationTargetException {
        throw new ReflectionException(exceptionMessage);
    }
}
```



### 2.4 ObjectFactory

#### 1、ObjectFactory

`org.apache.ibatis.reflection.factory.ObjectFactory`,Object工厂接口，用于创建指定类的对象，相关源码如下所示：

```java
public interface ObjectFactory {

    /**
   * Sets configuration properties. 设置properties
   *
   * @param properties
   *          configuration properties
   */
    default void setProperties(Properties properties) {
        // NOP
    }

    /**
   * Creates a new object with default constructor. 创建指定类的对象，使用默认构造方法
   *
   * @param <T>
   *          the generic type
   * @param type
   *          Object type
   *
   * @return the t
   */
    <T> T create(Class<T> type);

    /**
   * Creates a new object with the specified constructor and params. 创建指定类的对象，使用特定的构造方法
   *
   * @param <T>
   *          the generic type
   * @param type
   *          Object type
   * @param constructorArgTypes
   *          Constructor argument types 指定构造方法的参数列表
   * @param constructorArgs
   *          Constructor argument values 参数数组
   *
   * @return the t
   */
    <T> T create(Class<T> type, List<Class<?>> constructorArgTypes, List<Object> constructorArgs);

    /**
   * 判断指定类是否为集合类
   * Returns true if this object can have a set of other objects. It's main purpose is to support
   * non-java.util.Collection objects like Scala collections.
   *
   * @param <T>
   *          the generic type
   * @param type
   *          Object type
   *
   * @return whether it is a collection or not
   *
   * @since 3.1.0
   */
    <T> boolean isCollection(Class<T> type);

}
```



#### 2、DefaultObjectFactory

`org.apache.ibatis.reflection.factory.DefaultObjectFactory`,实现 ObjectFactory、Serializable 接口，是ObjectFactory的默认实现类。

关于create方法的实现：

单参数create方法，本质上调用的是多参的create方法

```java
@Override
public <T> T create(Class<T> type) {
    return create(type, null, null);
}
```

多参数create方法，首先通过DefaultObjectFactory类中的resolveInterface方法获取当前type的类型，然后通过instantiateClass创建对象

```java
@Override
public <T> T create(Class<T> type, List<Class<?>> constructorArgTypes, List<Object> constructorArgs) {
    Class<?> classToCreate = resolveInterface(type);
    // we know types are assignable
    return (T) instantiateClass(classToCreate, constructorArgTypes, constructorArgs);
}
```

关于resolveInterface方法如下所示，根据type的类对象，对于常用的集合接口，返回对应的实现类

```java
protected Class<?> resolveInterface(Class<?> type) {
    Class<?> classToCreate;
    if (type == List.class || type == Collection.class || type == Iterable.class) {
        classToCreate = ArrayList.class;
    } else if (type == Map.class) {
        classToCreate = HashMap.class;
    } else if (type == SortedSet.class) { // issue #510 Collections Support
        classToCreate = TreeSet.class;
    } else if (type == Set.class) {
        classToCreate = HashSet.class;
    } else {
        classToCreate = type;
    }
    return classToCreate;
}
```

通过反射获取类的构造器，创建对象

```java
private <T> T instantiateClass(Class<T> type, List<Class<?>> constructorArgTypes, List<Object> constructorArgs) {
    try {
        // 声明构造对象
        Constructor<T> constructor;
        // 无参构造器
        if (constructorArgTypes == null || constructorArgs == null) {
            constructor = type.getDeclaredConstructor();
            try {
                return constructor.newInstance();
            } catch (IllegalAccessException e) {
                // 如果是访问异常，重新尝试
                if (Reflector.canControlMemberAccessible()) {
                    constructor.setAccessible(true);
                    return constructor.newInstance();
                }
                throw e;
            }
        }
        // 有参构造器
        constructor = type.getDeclaredConstructor(constructorArgTypes.toArray(new Class[0]));
        try {
            return constructor.newInstance(constructorArgs.toArray(new Object[0]));
        } catch (IllegalAccessException e) {
            // 如果是访问异常，重新尝试
            if (Reflector.canControlMemberAccessible()) {
                constructor.setAccessible(true);
                return constructor.newInstance(constructorArgs.toArray(new Object[0]));
            }
            throw e;
        }
    } catch (Exception e) {
        // 拼接参数类型
        String argTypes = Optional.ofNullable(constructorArgTypes).orElseGet(Collections::emptyList).stream()
            .map(Class::getSimpleName).collect(Collectors.joining(","));
        // 拼接参数值
        String argValues = Optional.ofNullable(constructorArgs).orElseGet(Collections::emptyList).stream()
            .map(String::valueOf).collect(Collectors.joining(","));
        // 抛出ReflectionException异常
        throw new ReflectionException("Error instantiating " + type + " with invalid types (" + argTypes + ") or values ("
                                      + argValues + "). Cause: " + e, e);
    }
}
```

isCollection方法，判定指定类是否为集合类，相关代码如下所示

```java
@Override
public <T> boolean isCollection(Class<T> type) {
    return Collection.class.isAssignableFrom(type);
}
```

setProperties没有在子类ObjectFactory中实现，使用父类的默认方法

```java
default void setProperties(Properties properties) {
	// NOP
}
```



### 2.5 Property工具类

#### 1、位置

`org.apache.ibatis.reflection.property` 包下，提供了 PropertyCopier、PropertyNamer、PropertyTokenizer 三个属性相关的工具类

#### 2、PropertyCopier

位于`org.apache.ibatis.reflection.property.PropertyCopier`下，是属性复制器

```java
public final class PropertyCopier {

    private PropertyCopier() {
        // Prevent Instantiation of Static Class
    }
	
    // 将sourceBean的属性，复制到destinationBean中
  	// @param type 指定类
 	// @param sourceBean 来源 Bean 对象
 	// @param destinationBean 目标 Bean 对象
    public static void copyBeanProperties(Class<?> type, Object sourceBean, Object destinationBean) {
        // 循环，从当前类开始，不断复制到父类，直到父类不存在
        Class<?> parent = type;
        while (parent != null) {
            // 获得当前 parent 类定义的属性
            final Field[] fields = parent.getDeclaredFields();
            for (Field field : fields) {
                try {
                    try {
                        // 从 sourceBean 中，复制到 destinationBean 去
                        field.set(destinationBean, field.get(sourceBean));
                    } catch (IllegalAccessException e) {
                        // 设置属性可访问
                        if (!Reflector.canControlMemberAccessible()) {
                            throw e;
                        }
                        field.setAccessible(true);
                        field.set(destinationBean, field.get(sourceBean));
                    }
                } catch (Exception e) {
                    // Nothing useful to do, will only fail on final fields, which will be ignored.
                }
            }
            // 获得父类
            parent = parent.getSuperclass();
        }
    }

}
```



#### 3、PropertyNamer

`org.apache.ibatis.reflection.property.PropertyNamer` ，属性名相关的工具类方法

```java
public final class PropertyNamer {

    private PropertyNamer() {
        // Prevent Instantiation of Static Class
    }

    /**
     * 根据方法名，获得对应的属性名
     *
     * @param name 方法名
     * @return 属性名
     */
    public static String methodToProperty(String name) {
        if (name.startsWith("is")) {
            // 对 is 方法处理
            name = name.substring(2);
        } else if (name.startsWith("get") || name.startsWith("set")) {
            // 对 get 或者 set 方法处理
            name = name.substring(3);
        } else {
            // 抛出 ReflectionException 异常，因为只能处理 is、set、get 方法
            throw new ReflectionException(
                "Error parsing property name '" + name + "'.  Didn't start with 'is', 'get' or 'set'.");
        }

        // 首字母小写
        if (name.length() == 1 || name.length() > 1 && !Character.isUpperCase(name.charAt(1))) {
            name = name.substring(0, 1).toLowerCase(Locale.ENGLISH) + name.substring(1);
        }

        return name;
    }

    
    /**
     * 判断是否为 is、get、set 方法
     *
     * @param name 方法名
     * @return 是否
     */
    public static boolean isProperty(String name) {
        return isGetter(name) || isSetter(name);
    }

    
    /**
     * 判断是否为 get、is 方法
     *
     * @param name 方法名
     * @return 是否
     */
    public static boolean isGetter(String name) {
        return name.startsWith("get") && name.length() > 3 || name.startsWith("is") && name.length() > 2;
    }

    /**
     * 判断是否为 set 方法
     *
     * @param name 方法名
     * @return 是否
     */
    public static boolean isSetter(String name) {
        return name.startsWith("set") && name.length() > 3;
    }

}
```



#### 4、PropertyTokenizer 

`org.apache.ibatis.reflection.property.PropertyTokenizer` ，其实现 Iterator 接口，属性分词器，支持迭代器的访问方式。

举例：在访问 `"order[0].item[0].name"` 时，我们希望拆分成 `"order[0]"`、`"item[0]"`、`"name"` 三段，那么就可以通过 PropertyTokenizer 来实现。

相关源码如下所示：

```java
public class PropertyTokenizer implements Iterator<PropertyTokenizer> {
    // 当前字符串
    private String name;
    
    // 名称+索引
    private final String indexedName;
    
    /**
     * 编号，有两种情况：
     * 对于数组 name[0] ，则 index = 0
     * 对于 Map map[key] ，则 index = key
     */
    private String index;
    
    // 剩余字符串
    private final String children;

    // 构造方法
    public PropertyTokenizer(String fullname) {
        // 初始化 name、children 字符串，使用 . 作为分隔
        int delim = fullname.indexOf('.');
        if (delim > -1) {
            name = fullname.substring(0, delim);
            children = fullname.substring(delim + 1);
        } else {
            name = fullname;
            children = null;
        }
        // 记录当前 name
        indexedName = name;
        // 若存在 [ ，则获得 index ，并修改 name
        delim = name.indexOf('[');
        if (delim > -1) {
            index = name.substring(delim + 1, name.length() - 1);
            name = name.substring(0, delim);
        }
    }

    public String getName() {
        return name;
    }

    public String getIndex() {
        return index;
    }

    public String getIndexedName() {
        return indexedName;
    }

    public String getChildren() {
        return children;
    }

    // 判断是否有下一个元素
    @Override
    public boolean hasNext() {
        return children != null;
    }

    // 迭代获得下一个 PropertyTokenizer 对象
    @Override
    public PropertyTokenizer next() {
        return new PropertyTokenizer(children);
    }

    @Override
    public void remove() {
        throw new UnsupportedOperationException(
            "Remove is not supported, as it has no meaning in the context of properties.");
    }
}
```

测试示例：

```java
@Test
void test() {
    PropertyTokenizer propertyTokenizer = new PropertyTokenizer("order[0].item[0].name");
}
```

创建完对象后，PropertyTokenizer对象中的属性如下：

![image-20250322224640198](%E4%B8%89%E3%80%81%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82%E2%80%94%E2%80%94%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9D%97.assets/image-20250322224640198.png)



### 2.6 MetaClass

该类位于`org.apache.ibatis.reflection.MetaClass`包下，是类的元数据，基于 Reflector 和 PropertyTokenizer ，操作指定类。

#### 1、构造方法

```java
// reflector工厂
private final ReflectorFactory reflectorFactory;
// reflector
private final Reflector reflector;

// 构造器
// type：class对象（一个MetaClass对象对应一个class对象）
// reflectorFactory：reflector工厂
private MetaClass(Class<?> type, ReflectorFactory reflectorFactory) {
    this.reflectorFactory = reflectorFactory;
    this.reflector = reflectorFactory.findForClass(type);
}
```

调用方式一：静态方法

```java
public static MetaClass forClass(Class<?> type, ReflectorFactory reflectorFactory) {
    return new MetaClass(type, reflectorFactory);
}
```

调用方式二：创建类中指定属性的类（根据name）的 MetaClass 对象，简介静态方法forClass调用构造方法

```java
public MetaClass metaClassForProperty(String name) {
    Class<?> propType = reflector.getGetterType(name);
    return MetaClass.forClass(propType, reflectorFactory);
}
```

#### 2、findProperty

根据表达式，获取MetaClass封装对象对应属性的字符串名称。如下官方测试示例：

```java
@Test
void shouldFindPropertyName() {
    ReflectorFactory reflectorFactory = new DefaultReflectorFactory();
    MetaClass meta = MetaClass.forClass(RichType.class, reflectorFactory);
    assertEquals("richField", meta.findProperty("RICHfield"));
}
```

即先将RichType对象封装为MetaClass对象，再通过MetaClass对象的findProperty方法，获取其中的

richField的属性字符串，即`meta.findProperty("RICHfield")`的结果就是等于`richField`。



MetaClass的findProperty方法如下所示：

```java
public String findProperty(String name, boolean useCamelCaseMapping) {
    // 下划线转驼峰
    if (useCamelCaseMapping) {
      name = name.replace("_", "");
    }
    return findProperty(name);
  }
```

```java
public String findProperty(String name) {
    StringBuilder prop = buildProperty(name, new StringBuilder());
    return prop.length() > 0 ? prop.toString() : null;
}
```

buildProperty方法如下所示：

```java
private StringBuilder buildProperty(String name, StringBuilder builder) {
    // 创建 PropertyTokenizer 对象，对 name 进行分词
    PropertyTokenizer prop = new PropertyTokenizer(name);
    if (prop.hasNext()) {
        // 有子表达式 即A对象中有个成员变量B b，b对象中有个成员变量C c，此时name=b.c则是有子表达式
        // 从Reflect对象的caseInsensitivePropertyMap（忽略大小写集合）中获取到当前属性
        String propertyName = reflector.findPropertyName(prop.getName());
        if (propertyName != null) {
            // 获取到当前属性，将其加入到builder中
            builder.append(propertyName);
            builder.append(".");
            // 为当前属性创建MetaClass对象
            MetaClass metaProp = metaClassForProperty(propertyName);
            // 递归解析子表达式 children ，并将结果添加到 builder 中
            metaProp.buildProperty(prop.getChildren(), builder);
        }
    } else {
        // 无子表达式
        // 获得属性名，并添加到 builder 中
        String propertyName = reflector.findPropertyName(name);
        if (propertyName != null) {
            builder.append(propertyName);
        }
    }
    return builder;
}
```

> 注意：
>
> - 解决“下划线转驼峰”的关键是通过Reflector提供的忽略大小写集合：caseInsensitivePropertyMap实现的。



#### 3、hasGetter

```java
public boolean hasGetter(String name) {
    // 创建 PropertyTokenizer 对象，对 name 进行分词
    PropertyTokenizer prop = new PropertyTokenizer(name);
    if (!prop.hasNext()) {
        // 没有子表达式
        // 1.调用Reflector对象的hasGetter方法
        return reflector.hasGetter(prop.getName());
    }
    
    // 判断是否有该属性的 getting 方法
    if (reflector.hasGetter(prop.getName())) {
        // 2.根据属性名称创建 MetaClass 对象
        MetaClass metaProp = metaClassForProperty(prop);
        // 递归判断子表达式 children ，是否有 getting 方法
        return metaProp.hasGetter(prop.getChildren());
    }
    return false;
}
```

1.调用Reflector对象的hasGetter方法、

即从Reflector对象的getMethods成员对象中查找是否包含当前属性名称

```java
public boolean hasGetter(String propertyName) {
    return getMethods.containsKey(propertyName);
}
```

2.根据属性名称创建 MetaClass 对象

```java
private MetaClass metaClassForProperty(PropertyTokenizer prop) {
    // 调用getGetterType方法获取当前属性名称为prop的类型
    Class<?> propType = getGetterType(prop);
    // 为当前属性创建MetaClass对象
    return MetaClass.forClass(propType, reflectorFactory);
}
```

调用getGetterType方法，通过属性名称，以及Reflector回去对应属性的类型信息（即getting方法的返回值）

```java
private Class<?> getGetterType(PropertyTokenizer prop) {
    // 获得返回类型
    Class<?> type = reflector.getGetterType(prop.getName());
    // 如果是获取数组的某个位置的元素，则获取其泛型。例如说：list[0].field ，那么就会解析 list 是什么类型，这样才好通过该类型，继续获得 field
    if (prop.getIndex() != null && Collection.class.isAssignableFrom(type)) {
        // 【调用】获得返回的类型
        Type returnType = getGenericGetterType(prop.getName());
        // 如果是泛型，进行解析真正的类型
        if (returnType instanceof ParameterizedType) {
            Type[] actualTypeArguments = ((ParameterizedType) returnType).getActualTypeArguments();
            // 为什么这里判断大小为 1 呢，因为 Collection 是 Collection<T> ，至多一个
            if (actualTypeArguments != null && actualTypeArguments.length == 1) {
                returnType = actualTypeArguments[0];
                if (returnType instanceof Class) {
                    type = (Class<?>) returnType;
                } else if (returnType instanceof ParameterizedType) {
                    type = (Class<?>) ((ParameterizedType) returnType).getRawType();
                }
            }
        }
    }
    return type;
}
```

#### △getGenericGetterType

```java
private Type getGenericGetterType(String propertyName) {
    try {
        // // 获得 Invoker 对象（属性=propertyName的getting方法）
        Invoker invoker = reflector.getGetInvoker(propertyName);
        if (invoker instanceof MethodInvoker) {
            // 如果 MethodInvoker 对象，则说明是 getting 方法，解析方法返回类型
            Field declaredMethod = MethodInvoker.class.getDeclaredField("method");
            declaredMethod.setAccessible(true);
            Method method = (Method) declaredMethod.get(invoker);
            return TypeParameterResolver.resolveReturnType(method, reflector.getType());
        }
        if (invoker instanceof GetFieldInvoker) {
            // 如果 GetFieldInvoker 对象，则说明是 field ，直接访问
            Field declaredField = GetFieldInvoker.class.getDeclaredField("field");
            declaredField.setAccessible(true);
            Field field = (Field) declaredField.get(invoker);
            return TypeParameterResolver.resolveFieldType(field, reflector.getType());
        }
    } catch (NoSuchFieldException | IllegalAccessException e) {
        // Ignored
    }
    return null;
}
```

#### 4、hasSetter

同理hasGetter

#### 5、getGetterType

```java
public Class<?> getGetterType(String name) {
    // 创建 PropertyTokenizer 对象，对 name 进行分词
    PropertyTokenizer prop = new PropertyTokenizer(name);
    if (prop.hasNext()) {
        // 有子表达式
        // 为当前属性创建 MetaClass 对象
        MetaClass metaProp = metaClassForProperty(prop);
        // 递归判断子表达式 children ，获得返回值的类型
        return metaProp.getGetterType(prop.getChildren());
    }
    // issue #506. Resolve the type inside a Collection Object
    // 直接获得返回值的类型（即上述5介绍）
    return getGetterType(prop);
}
```

#### 6、getSetterType

同理getGetterType

#### 7、hasDefaultConstructor

调用Reflector对象的hasDefaultConstructor方法，判断当前类是否有默认的构造器

```java
public boolean hasDefaultConstructor() {
    return reflector.hasDefaultConstructor();
}
```

#### 8、其他

基本都是在Reflector对象上进行封装，省略……



### 2.7 ObjectWrapper（△）

#### 1、ObjectWrapper

`org.apache.ibatis.reflection.wrapper.ObjectWrapper` ，对象包装器接口，基于 MetaClass 工具类，定义对指定对象的各种操作。或者可以说，ObjectWrapper 是 MetaClass 的指定类的具象化。其接口源码如下所示：

```java
public interface ObjectWrapper {

    /**
   * 获得值
   * @param prop 键
   * @return 值
   */
    Object get(PropertyTokenizer prop);

    /**
   * 设置值
   * @param prop 键
   * @param value 值
   */
    void set(PropertyTokenizer prop, Object value);

    /**
   * {@link MetaClass#findProperty(String, boolean)}
   */
    String findProperty(String name, boolean useCamelCaseMapping);

    /**
   * {@link MetaClass#getGetterNames()}
   */
    String[] getGetterNames();

    /**
   * {@link MetaClass#getSetterNames()}
   */
    String[] getSetterNames();

    /**
   * {@link MetaClass#getSetterType(String)}
   */
    Class<?> getSetterType(String name);

    /**
   * {@link MetaClass#getGetterType(String)}
   */
    Class<?> getGetterType(String name);

    /**
   * {@link MetaClass#hasSetter(String)}
   */
    boolean hasSetter(String name);

    /**
   * {@link MetaClass#hasGetter(String)}
   */
    boolean hasGetter(String name);

    /**
   * {@link MetaObject#forObject(Object, ObjectFactory, ObjectWrapperFactory, ReflectorFactory)}
   */
    MetaObject instantiatePropertyValue(String name, PropertyTokenizer prop, ObjectFactory objectFactory);

    /**
   * 是否为集合
   */
    boolean isCollection();

    /**
   * 添加元素到集合
   */
    void add(Object element);

    /**
   * 添加多个元素到集合
   */
    <E> void addAll(List<E> element);

}
```

其子类实现如下图所示：

![image-20250323103238770](%E4%B8%89%E3%80%81%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82%E2%80%94%E2%80%94%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9D%97.assets/image-20250323103238770.png)



#### 2、BaseWrapper.BaenWrapper

其位于`org.apache.ibatis.reflection.wrapper.BeanWrapper`包下，继承抽象类BaseWrapper，是普通对象的ObjectWrapper的实现类，例如User、Order这样的POJO类。

##### 1.属性&构造器

```java
private final Object object;
private final MetaClass metaClass;

public BeanWrapper(MetaObject metaObject, Object object) {
    super(metaObject);
    this.object = object;
    // 在这里调用MetaClass的静态方法forClass创建 MetaClass 对象
    this.metaClass = MetaClass.forClass(object.getClass(), metaObject.getReflectorFactory());
}
```

其中通过super调用父类BaseWrapper的构造器，父类BaseWrapper的属性和构造器如下所示：

```java
protected static final Object[] NO_ARGUMENTS = {};
protected final MetaObject metaObject;

protected BaseWrapper(MetaObject metaObject) {
    this.metaObject = metaObject;
}
```

##### 2.get方法

其作用用于获取指定属性的值

```java
@Override
public Object get(PropertyTokenizer prop) {
    if (prop.hasNext()) { // （1）通过分词器对象判断，有子内容/子表达式
        // （2）调用getChildValue方法，递归去解析获取子内容/子表达式的值
        return getChildValue(prop);
    } else if (prop.getIndex() != null) { // （3）获取集合类型的属性或指定位置/索引的的值，如list[0], map['123']
        return getCollectionValue(prop, resolveCollection(prop, object));
    } else { // （4）获得属性的值
        return getBeanProperty(prop, object);
    }
}
```

（1）通过分词器对象判断，有子内容/子表达式

本质上就是看下PropertyTokenizer对象中的成员变量child是否有值

```java
@Override
public boolean hasNext() {
    return children != null;
}
```

（2）调用BaseWrapper#getChildValue方法，递归去解析子表达式的值

```java
protected Object getChildValue(PropertyTokenizer prop) {
    // 通过当前MetaObject对象的metaObjectForProperty方法，根据子表达式的值创建对象元数据，即MetaObject对象
    MetaObject metaValue = metaObject.metaObjectForProperty(prop.getIndexedName());
    // 原始Object对象==null，则返回SystemMetaObject.NULL_META_OBJECT 对象
    if (metaValue == SystemMetaObject.NULL_META_OBJECT) {
        return null;
    }
    // 调用子表达式对应的MetaObject对象的getValue获取子表达式的值
    // 实质：调用 ObjectWrapper 的 get 方法，获取属性值
    return metaValue.getValue(prop.getChildren());
}
```

metaObject#metaObjectForProperty：

```java
public MetaObject metaObjectForProperty(String name) {
    // 根据属性名称name获取对应的属性值，本质上也是调用objectWrapper的get方法
    Object value = getValue(name);
    // 根据属性值，创建MetaObject对象
    return MetaObject.forObject(value, objectFactory, objectWrapperFactory, reflectorFactory);
}
```

```java
public Object getValue(String name) {
    // 创建 PropertyTokenizer 对象，对 name 分词
    PropertyTokenizer prop = new PropertyTokenizer(name);
    // 调用 ObjectWrapper 的 get 方法，获取属性值
    return objectWrapper.get(prop);
}
```

metaValue#getValue(prop.getChildren())

```java
public Object getValue(String name) {
    // 创建 PropertyTokenizer 对象，对 name 分词
    PropertyTokenizer prop = new PropertyTokenizer(name);
    // 调用 ObjectWrapper 的 get 方法，获取属性值
    return objectWrapper.get(prop);
}
```

（3）获取集合类型的属性或指定位置/索引的的值，如list[0], map['123']

BaseWrapper#resolveCollection方法：

```java
protected Object resolveCollection(PropertyTokenizer prop, Object object) {
    // 如果当前要找的属性名称=="", 直接返回object对象
    if ("".equals(prop.getName())) {
        return object;
    }
    // 调用metaObject的getValue方法，获取对应属性名称的值
    // 本质上调用 ObjectWrapper 的 get 方法，获取属性值
    return metaObject.getValue(prop.getName());
}
```

BeanWrapper#getCollectionValue方法：

根据不同集合类型获取值

```java
protected Object getCollectionValue(PropertyTokenizer prop, Object collection) {
    if (collection == null) {
        throw new ReflectionException("Cannot get the value '" + prop.getIndexedName() + "' because the property '"
                                      + prop.getName() + "' is null.");
    }
    if (collection instanceof Map) {
        return ((Map) collection).get(prop.getIndex());
    }
    int i = Integer.parseInt(prop.getIndex());
    if (collection instanceof List) {
        return ((List) collection).get(i);
    } else if (collection instanceof Object[]) {
        return ((Object[]) collection)[i];
    } else if (collection instanceof char[]) {
        return ((char[]) collection)[i];
    } else if (collection instanceof boolean[]) {
        return ((boolean[]) collection)[i];
    } else if (collection instanceof byte[]) {
        return ((byte[]) collection)[i];
    } else if (collection instanceof double[]) {
        return ((double[]) collection)[i];
    } else if (collection instanceof float[]) {
        return ((float[]) collection)[i];
    } else if (collection instanceof int[]) {
        return ((int[]) collection)[i];
    } else if (collection instanceof long[]) {
        return ((long[]) collection)[i];
    } else if (collection instanceof short[]) {
        return ((short[]) collection)[i];
    } else {
        throw new ReflectionException("Cannot get the value '" + prop.getIndexedName() + "' because the property '"
                                      + prop.getName() + "' is not Map, List or Array.");
    }
}
```

（4）获得属性的值

```java
private Object getBeanProperty(PropertyTokenizer prop, Object object) {
    try {
        // 通过Reflector对象获取当前属性对应的getter方法
        Invoker method = metaClass.getGetInvoker(prop.getName());
        try {
            // 调用其getter方法，并返回结果值
            return method.invoke(object, NO_ARGUMENTS);
        } catch (Throwable t) {
            throw ExceptionUtil.unwrapThrowable(t);
        }
    } catch (RuntimeException e) {
        throw e;
    } catch (Throwable t) {
        throw new ReflectionException(
            "Could not get property '" + prop.getName() + "' from " + object.getClass() + ".  Cause: " + t.toString(), t);
    }
}
```

##### 3.set方法

```java
@Override
public void set(PropertyTokenizer prop, Object value) {
    if (prop.hasNext()) { // 通过分词器对象判断，是否有子内容
        setChildValue(prop, value);
    } else if (prop.getIndex() != null) { // 获取指定位置的值
        setCollectionValue(prop, resolveCollection(prop, object), value);
    } else { // 设置属性的值
        setBeanProperty(prop, object, value);
    }
}
```

```java
private void setBeanProperty(PropertyTokenizer prop, Object object, Object value) {
    try {
        // 过Reflector对象获取当前属性对应的setter方法
        Invoker method = metaClass.getSetInvoker(prop.getName());
        Object[] params = { value };
        try {
            // 设置值
            method.invoke(object, params);
        } catch (Throwable t) {
            throw ExceptionUtil.unwrapThrowable(t);
        }
    } catch (Throwable t) {
        throw new ReflectionException("Could not set property '" + prop.getName() + "' of '" + object.getClass()
                                      + "' with value '" + value + "' Cause: " + t.toString(), t);
    }
}
```

##### 3.getGetterType/getSetterType

```java
@Override
public Class<?> getGetterType(String name) {
    // 根据name获取分词器对象
    PropertyTokenizer prop = new PropertyTokenizer(name);
    if (!prop.hasNext()) { // 没有子内容/子表达式
        // 直接获取返回值的类型
        return metaClass.getGetterType(name);
    }
    // 有子内容/子表达式
    // 创建 MetaObject 对象
    MetaObject metaValue = metaObject.metaObjectForProperty(prop.getIndexedName());
    // 如果 metaValue 为空，则基于 metaClass 获得返回类型
    if (metaValue == SystemMetaObject.NULL_META_OBJECT) {
        return metaClass.getGetterType(name);
    }
    // 如果 metaValue 非空，则基于 metaValue 获得返回类型
    // 递归判断子表达式 children ，获得返回值的类型
    return metaValue.getGetterType(prop.getChildren());
}
```

##### 4.hasGetter/hasSetter

用于判断指定的属性是否有getter方法

```java
@Override
public boolean hasGetter(String name) {
    // 创建分词对象PropertyTokenizer，对name进行分词
    PropertyTokenizer prop = new PropertyTokenizer(name);
    if (!prop.hasNext()) {  // 没有子内容/子表达式
        // 调用MetaClass的hasGetter方法判断，是否有getter方法
        return metaClass.hasGetter(name);
    }
    // 调用MetaClass的hasGetter方法判断，是否有getter方法
    if (metaClass.hasGetter(prop.getIndexedName())) {
        // 创建 MetaObject 对象
        MetaObject metaValue = metaObject.metaObjectForProperty(prop.getIndexedName());
        if (metaValue == SystemMetaObject.NULL_META_OBJECT) { // 如果 metaValue 为空，则基于 metaClass 判断是否有该属性的 getter 方法
            return metaClass.hasGetter(name);
        }
        // 如果 metaValue 非空，则基于 metaValue 判断是否有 getter 方法
        // 递归判断子表达式 children ，判断是否有 getting 方法
        return metaValue.hasGetter(prop.getChildren());
    }
    return false;
}
```

##### 5.instantiatePropertyValue

```java
@Override
public MetaObject instantiatePropertyValue(String name, PropertyTokenizer prop, ObjectFactory objectFactory) {
    // 声明一个元数据对象 MetaObject
    MetaObject metaValue;
    // 获得 当前属性值 = prop.getName() 的 setter 方法的方法参数类型
    Class<?> type = getSetterType(prop.getName());
    try {
        // 创建对象
        Object newObject = objectFactory.create(type);
        // 创建 元数据 MetaObject 对象
        metaValue = MetaObject.forObject(newObject, metaObject.getObjectFactory(), metaObject.getObjectWrapperFactory(),
                                         metaObject.getReflectorFactory());
        // 设置当前对象的值，即设置newObject到当前对象的prop属性上
        set(prop, newObject);
    } catch (Exception e) {
        throw new ReflectionException("Cannot set value of property '" + name + "' because '" + name
                                      + "' is null and cannot be instantiated on instance of " + type.getName() + ". Cause:" + e.toString(), e);
    }
    // 返回元数据对象 MetaObject
    return metaValue;
}
```

##### 6.isCollection

默认返回false

```java
@Override
public boolean isCollection() {
    return false;
}
```

##### 7.add和addAll

都是不支持的，直接抛出异常

```java
@Override
public void add(Object element) {
    throw new UnsupportedOperationException();
}

@Override
public <E> void addAll(List<E> list) {
    throw new UnsupportedOperationException();
}
```



#### 3、BaseWrapper.MapWrapper

`org.apache.ibatis.reflection.wrapper.MapWrapper` ，继承 BaseWrapper 抽象类，**Map** 对象的 ObjectWrapper 实现类。

MapWrapper 和 BeanWrapper 的大体逻辑是一样的，差异点主要如下：

```
// MapWrapper.java

// object 变成了 map
private final Map<String, Object> map;

// 属性的操作变成了
map.put(prop.getName(), value);
map.get(prop.getName());
```



#### 4、CollectionWrapper

`org.apache.ibatis.reflection.wrapper.CollectionWrapper` ，实现 ObjectWrapper 接口，集合 ObjectWrapper 实现类。

相关源码：

```java
public class CollectionWrapper implements ObjectWrapper {

    private final Collection<Object> object;

    public CollectionWrapper(MetaObject metaObject, Collection<Object> object) {
        this.object = object;
    }

    @Override
    public Object get(PropertyTokenizer prop) {
        throw new UnsupportedOperationException();
    }

    @Override
    public void set(PropertyTokenizer prop, Object value) {
        throw new UnsupportedOperationException();
    }

    @Override
    public String findProperty(String name, boolean useCamelCaseMapping) {
        throw new UnsupportedOperationException();
    }

    @Override
    public String[] getGetterNames() {
        throw new UnsupportedOperationException();
    }

    @Override
    public String[] getSetterNames() {
        throw new UnsupportedOperationException();
    }

    @Override
    public Class<?> getSetterType(String name) {
        throw new UnsupportedOperationException();
    }

    @Override
    public Class<?> getGetterType(String name) {
        throw new UnsupportedOperationException();
    }

    @Override
    public boolean hasSetter(String name) {
        throw new UnsupportedOperationException();
    }

    @Override
    public boolean hasGetter(String name) {
        throw new UnsupportedOperationException();
    }

    @Override
    public MetaObject instantiatePropertyValue(String name, PropertyTokenizer prop, ObjectFactory objectFactory) {
        throw new UnsupportedOperationException();
    }

    @Override
    public boolean isCollection() {
        return true;
    }

    @Override
    public void add(Object element) {
        object.add(element);
    }

    @Override
    public <E> void addAll(List<E> element) {
        object.addAll(element);
    }

}

```



### 2.8 ObjectWrapperFactory

#### 1、ObjectWrapperFactory

`org.apache.ibatis.reflection.wrapper.ObjectWrapperFactory` ，ObjectWrapper 工厂接口

```java
public interface ObjectWrapperFactory {

    /**
   * 是否对指定对象object进行了包装
   * @param object 指定对象
   * @return 是否
   */
    boolean hasWrapperFor(Object object);

    /**
   * 获得指定对象的 ObjectWrapper 对象
   * @param metaObject MetaObject 对象
   * @param object 指定对象
   * @return ObjectWrapper 对象
   */
    ObjectWrapper getWrapperFor(MetaObject metaObject, Object object);

}
```

#### 2、DefaultObjectWrapperFactory实现类

没啥用。。。

```java
public class DefaultObjectWrapperFactory implements ObjectWrapperFactory {

    @Override
    public boolean hasWrapperFor(Object object) {
        return false;
    }

    @Override
    public ObjectWrapper getWrapperFor(MetaObject metaObject, Object object) {
        throw new ReflectionException(
            "The DefaultObjectWrapperFactory should never be called to provide an ObjectWrapper.");
    }

}
```



### 2.9 MetaObject

#### 1、MetaObject

`org.apache.ibatis.reflection.MetaObject` ，对象元数据，提供了**对象的属性值**的获得和设置等等方法。

#### 2、属性

```java
// 原始 Object 对象
private final Object originalObject;
// 封装过的 Object 对象
private final ObjectWrapper objectWrapper;
private final ObjectFactory objectFactory;
private final ObjectWrapperFactory objectWrapperFactory;
private final ReflectorFactory reflectorFactory;
```

#### 3、创建对象方法

##### 1、构造器

```java
private MetaObject(Object object, ObjectFactory objectFactory, ObjectWrapperFactory objectWrapperFactory,
                   ReflectorFactory reflectorFactory) {
    this.originalObject = object;
    this.objectFactory = objectFactory;
    this.objectWrapperFactory = objectWrapperFactory;
    this.reflectorFactory = reflectorFactory;

    // 根据object的类型，创建不同的ObjectWrapper对象
    if (object instanceof ObjectWrapper) {
        this.objectWrapper = (ObjectWrapper) object;
    } else if (objectWrapperFactory.hasWrapperFor(object)) {
        // DefaultObjectWrapperFactory 未实现任何逻辑，所以这块逻辑相当于暂时不起作用
        this.objectWrapper = objectWrapperFactory.getWrapperFor(this, object);
    } else if (object instanceof Map) {
        this.objectWrapper = new MapWrapper(this, (Map) object);
    } else if (object instanceof Collection) {
        this.objectWrapper = new CollectionWrapper(this, (Collection) object);
    } else {
        this.objectWrapper = new BeanWrapper(this, object);
    }
}
```

##### 2、静态方法forObject创建MetaObject对象

```java
public static MetaObject forObject(Object object, ObjectFactory objectFactory,
                                   ObjectWrapperFactory objectWrapperFactory, ReflectorFactory reflectorFactory) {
    if (object == null) { // 原始Object对象==null，则返回SystemMetaObject.NULL_META_OBJECT 对象
        return SystemMetaObject.NULL_META_OBJECT;
    }
    // 根据object创建MetaObject对象
    return new MetaObject(object, objectFactory, objectWrapperFactory, reflectorFactory);
}
```

##### 3、metaObjectForProperty

`#metaObjectForProperty(String name)` 方法，创建指定属性的 MetaObject 对象（需要已完成MetaObject对象的创建）

```java
public MetaObject metaObjectForProperty(String name) {
    // 根据属性名称name获取对应的属性值
    Object value = getValue(name);
    // 场景MetaObject对象
    return MetaObject.forObject(value, objectFactory, objectWrapperFactory, reflectorFactory);
}
```

#### 4、一些方法

##### 1、getValue

通过`#getValue(String name)` 方法，可以获得指定属性的值，相关源码如下所示：

```java
public Object getValue(String name) {
    // 创建 PropertyTokenizer 对象，对 name 分词
    PropertyTokenizer prop = new PropertyTokenizer(name);
    // 调用 ObjectWrapper 的 get 方法，获取属性值
    return objectWrapper.get(prop);
}
```

##### 2、setValue

```java
public void setValue(String name, Object value) {
    objectWrapper.set(new PropertyTokenizer(name), value);
}
```

##### 3、isCollection

```java
public boolean isCollection() {
    return objectWrapper.isCollection();
}
```



### 2.10 SystemMetaObject

`org.apache.ibatis.reflection.SystemMetaObject` ，系统级的 MetaObject 对象，主要提供了 ObjectFactory、ObjectWrapperFactory、空 MetaObject 的单例。相关源码如下所示：

```java
public final class SystemMetaObject {

    // ObjectFactory 的单例
    public static final ObjectFactory DEFAULT_OBJECT_FACTORY = new DefaultObjectFactory();

    // ObjectWrapperFactory 的单例
    public static final ObjectWrapperFactory DEFAULT_OBJECT_WRAPPER_FACTORY = new DefaultObjectWrapperFactory();

    // 空对象的 MetaObject 对象单例
    public static final MetaObject NULL_META_OBJECT = MetaObject.forObject(new NullObject(), DEFAULT_OBJECT_FACTORY,
                                                                           DEFAULT_OBJECT_WRAPPER_FACTORY, new DefaultReflectorFactory());

    private SystemMetaObject() {
        // Prevent Instantiation of Static Class
    }

    private static class NullObject {
    }

    /**
   * 创建 MetaObject 对象
   *
   * @param object 指定对象
   * @return MetaObject 对象
   */
    public static MetaObject forObject(Object object) {
        return MetaObject.forObject(object, DEFAULT_OBJECT_FACTORY, DEFAULT_OBJECT_WRAPPER_FACTORY,
                                    new DefaultReflectorFactory());
    }

}
```



### 2.11 ParamNameUtil

`org.apache.ibatis.reflection.ParamNameUtil` ，参数名工具类，获得构造方法、普通方法的参数列表。相关源码如下所示：

```java
public class ParamNameUtil {
    /**
   * 获得普通方法的参数列表
   *
   * @param method 普通方法
   * @return 参数集合
   */
    public static List<String> getParamNames(Method method) {
        return getParameterNames(method);
    }

    /**
   * 获得构造方法的参数列表
   *
   * @param constructor 构造方法
   * @return 参数集合
   */
    public static List<String> getParamNames(Constructor<?> constructor) {
        return getParameterNames(constructor);
    }


    private static List<String> getParameterNames(Executable executable) {
        // 1.获得 Parameter 数组，并转换为Strem流
        // 2.获得参数名
        // 3.转换成List集合
        return Arrays.stream(executable.getParameters()).map(Parameter::getName).collect(Collectors.toList());
    }

    private ParamNameUtil() {
    }
}

```



### 2.12 ParamNameResolver

`org.apache.ibatis.reflection.ParamNameResolver`，用于参数名的解析（参数名解析器），即解析`org.apache.ibatis.annotations.Param`注释

#### 1、属性

```java
public static final String GENERIC_NAME_PREFIX = "param";

// 通过静态代码块初始化后：param0、param1、param2 ……
public static final String[] GENERIC_NAME_CACHE = new String[10];

static {
    for (int i = 0; i < 10; i++) {
        GENERIC_NAME_CACHE[i] = GENERIC_NAME_PREFIX + (i + 1);
    }
}

// 是否使用实际的参数名称
private final boolean useActualParamName;

// 参数名映射  key：参数顺序  value：参数名
/**
* The key is the index and the value is the name of the parameter.<br />
* The name is obtained from {@link Param} if specified. When {@link Param} is not specified, the parameter index is
* used. Note that this index could be different from the actual index when the method has special parameters (i.e.
* {@link RowBounds} or {@link ResultHandler}).
* <ul>
* <li>aMethod(@Param("M") int a, @Param("N") int b) -&gt; {{0, "M"}, {1, "N"}}</li>
* <li>aMethod(int a, int b) -&gt; {{0, "0"}, {1, "1"}}</li>
* <li>aMethod(int a, RowBounds rb, int b) -&gt; {{0, "0"}, {2, "1"}}</li>
* </ul>
*/
private final SortedMap<Integer, String> names;

// 是否有@Param注解
private boolean hasParamAnnotation;
```



#### 2、构造函数

```java
public ParamNameResolver(Configuration config, Method method) {
    // 从配置文件中读取参数，是否使用实际的参数名称
    this.useActualParamName = config.isUseActualParamName();
    // 获取当前方法的参数类型，并作为一个数组返回
    final Class<?>[] paramTypes = method.getParameterTypes();
    // 获取当前所有参数的注解信息（二维，一维表示哪一个参数，二维表示有哪些注释）
    final Annotation[][] paramAnnotations = method.getParameterAnnotations();
    // 声明一个TreeMap，用于参访参数顺序（key）和参数名称（value）
    final SortedMap<Integer, String> map = new TreeMap<>();
    // 获取当前参数属性
    int paramCount = paramAnnotations.length;
    // get names from @Param annotations
    for (int paramIndex = 0; paramIndex < paramCount; paramIndex++) {
        // 忽略，如果是特殊参数
        if (isSpecialParameter(paramTypes[paramIndex])) {
            // skip special parameters
            continue;
        }
        String name = null;
        for (Annotation annotation : paramAnnotations[paramIndex]) { // 首先，从 @Param 注解中获取参数
            if (annotation instanceof Param) {
                hasParamAnnotation = true;
                // 获取名称
                name = ((Param) annotation).value();
                break;
            }
        }
        if (name == null) {
            // @Param was not specified.
            if (useActualParamName) { // 其次，获取真实的参数名（如果在配置文件中开启了使用真实参数名称）
                name = getActualParamName(method, paramIndex);
            }
            if (name == null) {  // 最差，使用 map 的顺序，作为编号
                // use the parameter index as the name ("0", "1", ...)
                // gcode issue #71
                name = String.valueOf(map.size());
            }
        }
        // 添加到 map 中
        map.put(paramIndex, name);
    }
    // 构建不可变集合
    names = Collections.unmodifiableSortedMap(map);
}

```



#### 3、一些方法

##### 1.getNamedParams

`#getNamedParams(Object[] args)` 方法，获得参数名与值的映射，相关代码如下所示：

```java

/**
   * A single non-special parameter is returned without a name. Multiple parameters are named using the naming rule. In
   * addition to the default names, this method also adds the generic names (param1, param2, ...).
   *
   * @param args
   *          the args
   *
   * @return the named params
   */
public Object getNamedParams(Object[] args) {
    // 获取参数数量
    final int paramCount = names.size();
    if (args == null || paramCount == 0) { // 无参数，则返回 null
        return null;
    }
    if (!hasParamAnnotation && paramCount == 1) { // 只有一个非注解的参数，直接返回首元素
        Object value = args[names.firstKey()];
        return wrapToMapIfCollection(value, useActualParamName ? names.get(names.firstKey()) : null);
    } else {
        // 集合。
        // 组合 1 ：KEY：参数名，VALUE：参数值
        // 组合 2 ：KEY：GENERIC_NAME_PREFIX + 参数顺序，VALUE ：参数值
        final Map<String, Object> param = new ParamMap<>();
        int i = 0;
        for (Map.Entry<Integer, String> entry : names.entrySet()) { // 遍历 names 集合
            // 组合 1 ：添加到 param 中
            param.put(entry.getValue(), args[entry.getKey()]);
            // add generic param names (param1, param2, ...)
            // 组合 2 ：添加到 param 中
            final String genericParamName = i < 10 ? GENERIC_NAME_CACHE[i] : GENERIC_NAME_PREFIX + (i + 1);
            // ensure not to overwrite parameter named with @Param
            if (!names.containsValue(genericParamName)) {
                param.put(genericParamName, args[entry.getKey()]);
            }
            i++;
        }
        return param;
    }
}

public static Object wrapToMapIfCollection(Object object, String actualParamName) {
    if (object instanceof Collection) {
        ParamMap<Object> map = new ParamMap<>();
        map.put("collection", object);
        if (object instanceof List) {
            map.put("list", object);
        }
        Optional.ofNullable(actualParamName).ifPresent(name -> map.put(name, object));
        return map;
    }
    if (object != null && object.getClass().isArray()) {
        ParamMap<Object> map = new ParamMap<>();
        map.put("array", object);
        Optional.ofNullable(actualParamName).ifPresent(name -> map.put(name, object));
        return map;
    }
    return object;
}
```



### 2.13 TypeParameterResolver(△)

#### 1、TypeParameterResolver









### 2.14 ArrayUtil

`org.apache.ibatis.reflection.ArrayUtil` ，数组工具类

```java
/*
 *    Copyright 2009-2023 the original author or authors.
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */
package org.apache.ibatis.reflection;

import java.util.Arrays;

/**
 * Provides hashCode, equals and toString methods that can handle array.
 */
public class ArrayUtil {

    /**
   * Returns a hash code for {@code obj}.
   *
   * @param obj
   *          The object to get a hash code for. May be an array or <code>null</code>.
   *
   * @return A hash code of {@code obj} or 0 if {@code obj} is <code>null</code>
   */
    public static int hashCode(Object obj) {
        if (obj == null) {
            // for consistency with Arrays#hashCode() and Objects#hashCode()
            return 0;
        }
        final Class<?> clazz = obj.getClass();
        if (!clazz.isArray()) {
            return obj.hashCode();
        }
        final Class<?> componentType = clazz.getComponentType();
        if (long.class.equals(componentType)) {
            return Arrays.hashCode((long[]) obj);
        }
        if (int.class.equals(componentType)) {
            return Arrays.hashCode((int[]) obj);
        } else if (short.class.equals(componentType)) {
            return Arrays.hashCode((short[]) obj);
        } else if (char.class.equals(componentType)) {
            return Arrays.hashCode((char[]) obj);
        } else if (byte.class.equals(componentType)) {
            return Arrays.hashCode((byte[]) obj);
        } else if (boolean.class.equals(componentType)) {
            return Arrays.hashCode((boolean[]) obj);
        } else if (float.class.equals(componentType)) {
            return Arrays.hashCode((float[]) obj);
        } else if (double.class.equals(componentType)) {
            return Arrays.hashCode((double[]) obj);
        } else {
            return Arrays.hashCode((Object[]) obj);
        }
    }

    /**
   * Compares two objects. Returns <code>true</code> if
   * <ul>
   * <li>{@code thisObj} and {@code thatObj} are both <code>null</code></li>
   * <li>{@code thisObj} and {@code thatObj} are instances of the same type and {@link Object#equals(Object)} returns
   * <code>true</code></li>
   * <li>{@code thisObj} and {@code thatObj} are arrays with the same component type and equals() method of
   * {@link Arrays} returns <code>true</code> (not deepEquals())</li>
   * </ul>
   *
   * @param thisObj
   *          The left hand object to compare. May be an array or <code>null</code>
   * @param thatObj
   *          The right hand object to compare. May be an array or <code>null</code>
   *
   * @return <code>true</code> if two objects are equal; <code>false</code> otherwise.
   */
    public static boolean equals(Object thisObj, Object thatObj) {
        if (thisObj == null) {
            return thatObj == null;
        }
        if (thatObj == null) {
            return false;
        }
        final Class<?> clazz = thisObj.getClass();
        if (!clazz.equals(thatObj.getClass())) {
            return false;
        }
        if (!clazz.isArray()) {
            return thisObj.equals(thatObj);
        }
        final Class<?> componentType = clazz.getComponentType();
        if (long.class.equals(componentType)) {
            return Arrays.equals((long[]) thisObj, (long[]) thatObj);
        }
        if (int.class.equals(componentType)) {
            return Arrays.equals((int[]) thisObj, (int[]) thatObj);
        } else if (short.class.equals(componentType)) {
            return Arrays.equals((short[]) thisObj, (short[]) thatObj);
        } else if (char.class.equals(componentType)) {
            return Arrays.equals((char[]) thisObj, (char[]) thatObj);
        } else if (byte.class.equals(componentType)) {
            return Arrays.equals((byte[]) thisObj, (byte[]) thatObj);
        } else if (boolean.class.equals(componentType)) {
            return Arrays.equals((boolean[]) thisObj, (boolean[]) thatObj);
        } else if (float.class.equals(componentType)) {
            return Arrays.equals((float[]) thisObj, (float[]) thatObj);
        } else if (double.class.equals(componentType)) {
            return Arrays.equals((double[]) thisObj, (double[]) thatObj);
        } else {
            return Arrays.equals((Object[]) thisObj, (Object[]) thatObj);
        }
    }

    /**
   * If the {@code obj} is an array, toString() method of {@link Arrays} is called. Otherwise {@link Object#toString()}
   * is called. Returns "null" if {@code obj} is <code>null</code>.
   *
   * @param obj
   *          An object. May be an array or <code>null</code>.
   *
   * @return String representation of the {@code obj}.
   */
    public static String toString(Object obj) {
        if (obj == null) {
            return "null";
        }
        final Class<?> clazz = obj.getClass();
        if (!clazz.isArray()) {
            return obj.toString();
        }
        final Class<?> componentType = obj.getClass().getComponentType();
        if (long.class.equals(componentType)) {
            return Arrays.toString((long[]) obj);
        }
        if (int.class.equals(componentType)) {
            return Arrays.toString((int[]) obj);
        } else if (short.class.equals(componentType)) {
            return Arrays.toString((short[]) obj);
        } else if (char.class.equals(componentType)) {
            return Arrays.toString((char[]) obj);
        } else if (byte.class.equals(componentType)) {
            return Arrays.toString((byte[]) obj);
        } else if (boolean.class.equals(componentType)) {
            return Arrays.toString((boolean[]) obj);
        } else if (float.class.equals(componentType)) {
            return Arrays.toString((float[]) obj);
        } else if (double.class.equals(componentType)) {
            return Arrays.toString((double[]) obj);
        } else {
            return Arrays.toString((Object[]) obj);
        }
    }

    private ArrayUtil() {
    }

}

```



### 2.15 ExceptionUtil

`org.apache.ibatis.reflection.ExceptionUtil` ，异常工具类

```java
public class ExceptionUtil {

    private ExceptionUtil() {
        // Prevent Instantiation
    }

    public static Throwable unwrapThrowable(Throwable wrapped) {
        Throwable unwrapped = wrapped;
        while (true) {
            if (unwrapped instanceof InvocationTargetException) {
                unwrapped = ((InvocationTargetException) unwrapped).getTargetException();
            } else if (unwrapped instanceof UndeclaredThrowableException) {
                unwrapped = ((UndeclaredThrowableException) unwrapped).getUndeclaredThrowable();
            } else {
                return unwrapped;
            }
        }
    }

}
```

