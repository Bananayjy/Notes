# 三、基础支持层——反射模块

##  一、前言

### 1.1 内容结构

MyBatis 的反射模块，对应 `reflection` 包下的内容

![image-20250121152010148](%E4%B8%89%E3%80%81%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82%E2%80%94%E2%80%94%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9D%97.assets/image-20250121152010148.png)

### 1.2 主要功能

> Java 中的反射虽然功能强大，但对大多数开发人员来说，写出高质量的反射代码还是 有一定难度的。MyBatis 中专门提供了反射模块，该模块对 Java 原生的反射进行了良好的封装，提了更加**简洁易用的 API**，方便上层使调用，并且对**反射操作进行了一系列优化**，例如缓存了类的元数据，提高了反射操作的性能。



## 二、相关内容

### 2.1 Reflector

Reflector类(反射器)位于`org.apache.ibatis.reflection.Reflector`包下,个 Reflector 对应一个类。Reflector 会**缓存**反射操作需要的类的信息，例如：构造方法、属性名、setting / getting 方法等等。

#### 1.属性/成员变量

```java

// ……
private static final MethodHandle isRecordMethodHandle = getIsRecordMethodHandle();

// 每个Reflector对象对应的类的类对象
private final Class<?> type;

// 可读属性集合
private final String[] readablePropertyNames;

//可写属性集合
private final String[] writablePropertyNames;

/**
* 属性对应的 setting 方法的映射。
*
* key 为属性名称
* value 为 Invoker 对象
*/
private final Map<String, Invoker> setMethods = new HashMap<>();

/**
* 属性对应的 getting 方法的映射。
*
* key 为属性名称
* value 为 Invoker 对象
*/
private final Map<String, Invoker> getMethods = new HashMap<>();

 /**
* 属性对应的 setting 方法的方法参数类型的映射。{@link #setMethods}
*
* key 为属性名称
* value 为方法参数类型
*/
private final Map<String, Class<?>> setTypes = new HashMap<>();

/**
* 属性对应的 getting 方法的返回值类型的映射。{@link #getMethods}
*
* key 为属性名称
* value 为返回值的类型
*/
private final Map<String, Class<?>> getTypes = new HashMap<>();

/**
* 默认构造方法（默认为无参构造方法）
*/
private Constructor<?> defaultConstructor;

/**
* 不区分大小写的属性集合
*/
private final Map<String, String> caseInsensitivePropertyMap = new HashMap<>();
```



#### 2.构造函数

```java
public Reflector(Class<?> clazz) {
    // 设置对应的类对象
    type = clazz;
    // <1> 初始化defualtConstructor
    addDefaultConstructor(clazz);
    // <2> 获取当前类对象的方法
    Method[] classMethods = getClassMethods(clazz);
    
    // jdk 高版本的record内容，先不了解
    if (isRecord(type)) {
        addRecordGetMethods(classMethods);
    } else {
        // <3> 初始化 getMethods 和 getTypes
        addGetMethods(classMethods);
        // <4> 初始化 setMethods 和 setTypes 
        addSetMethods(classMethods);
        // <5> 初始化 getMethods + getTypes 和 setMethods + setTypes
        addFields(clazz);
    }
    // <6> 初始化 readablePropertyNames、writeablePropertyNames、caseInsensitivePropertyMap 属性 
    readablePropertyNames = getMethods.keySet().toArray(new String[0]);
    writablePropertyNames = setMethods.keySet().toArray(new String[0]);
    for (String propName : readablePropertyNames) {
        caseInsensitivePropertyMap.put(propName.toUpperCase(Locale.ENGLISH), propName);
    }
    for (String propName : writablePropertyNames) {
        caseInsensitivePropertyMap.put(propName.toUpperCase(Locale.ENGLISH), propName);
    }
}
```



<1> 初始化defualtConstructor

addDefaultConstructor方法查找默认的午餐构造器，并将其赋值给defaultConstructor对象

```java
private void addDefaultConstructor(Class<?> clazz) {
    // 获取所有构造方法
    Constructor<?>[] constructors = clazz.getDeclaredConstructors();
    Arrays.stream(constructors).filter(
        // 获取无参构造方法
        constructor -> constructor.getParameterTypes().length == 0)
        // 找到一个
        .findAny()
        // 如果存在，就赋值给defaultConstructor
        .ifPresent(constructor -> this.defaultConstructor = constructor);
}
```

<2> 获取当前类对象的方法

```java
/**
* This method returns an array containing all methods declared in this class and any superclass. We use this method,
* instead of the simpler <code>Class.getMethods()</code>, because we want to look for private methods as well.
* 此方法返回一个数组，其中包含在该类和任何超类中声明的所有方法，我们使用这个方法，而不是更简单的Class.getMethods()，因为我们也想寻找私有方法
* @param clazz
*          The class
*
* @return An array containing all methods in this class
*/
private Method[] getClassMethods(Class<?> clazz) {
    Map<String, Method> uniqueMethods = new HashMap<>();
    Class<?> currentClass = clazz;
    while (currentClass != null && currentClass != Object.class) {
        addUniqueMethods(uniqueMethods, currentClass.getDeclaredMethods());

        // we also need to look for interface methods -
        // because the class may be abstract
        Class<?>[] interfaces = currentClass.getInterfaces();
        for (Class<?> anInterface : interfaces) {
            addUniqueMethods(uniqueMethods, anInterface.getMethods());
        }

        currentClass = currentClass.getSuperclass();
    }

    Collection<Method> methods = uniqueMethods.values();

    return methods.toArray(new Method[0]);
}


private void addUniqueMethods(Map<String, Method> uniqueMethods, Method[] methods) {
    for (Method currentMethod : methods) {
      if (!currentMethod.isBridge()) {
        String signature = getSignature(currentMethod);
        // check to see if the method is already known
        // if it is known, then an extended class must have
        // overridden a method
        if (!uniqueMethods.containsKey(signature)) {
          uniqueMethods.put(signature, currentMethod);
        }
      }
    }
  }
```



<2> 获取当前类对象的方法

```java
private Method[] getClassMethods(Class<?> clazz) {
    // 声明map映射对象
    // key：方法签名（指一个方法的唯一标识符，它通常包含方法的名称、参数类型、返回类型等信息）
    // value: Method对象
    Map<String, Method> uniqueMethods = new HashMap<>();
    // 将当前类对象赋值给currentClass
    Class<?> currentClass = clazz;
    // 遍历当前类及其父类（不包括Object类）
    while (currentClass != null && currentClass != Object.class) {
        // addUniqueMethods如下所示
        addUniqueMethods(uniqueMethods, currentClass.getDeclaredMethods());

        // we also need to look for interface methods -
        // because the class may be abstract
        Class<?>[] interfaces = currentClass.getInterfaces();
        for (Class<?> anInterface : interfaces) {
            addUniqueMethods(uniqueMethods, anInterface.getMethods());
        }

        currentClass = currentClass.getSuperclass();
    }

    Collection<Method> methods = uniqueMethods.values();

    return methods.toArray(new Method[0]);
}
```

addUniqueMethods方法如下所示：



> ### 桥接方法（Bridge Method）是什么？
>
> 在 Java 中，**桥接方法** 通常是由 Java 编译器自动生成的，用来支持 **泛型类型擦除**。当你使用泛型时，编译器会将泛型类型转换为原始类型（即擦除类型），并可能会生成桥接方法来保证继承关系和多态性。
>
> - **桥接方法**：是编译器为解决继承中的方法重载问题而生成的，尤其是在泛型类和继承的场景下。当子类覆盖了父类中的泛型方法时，编译器会生成一个桥接方法，使得泛型的类型擦除后，仍然能正确地调用子类的覆盖方法。
>
> ### 为什么使用 `isBridge()`？
>
> 在你的代码中，`if (!currentMethod.isBridge())` 这行代码的作用是 **排除桥接方法**。通常，桥接方法不是开发者手动编写的，而是编译器自动生成的，用于确保多态性和类型擦除的正确性。
>
> 如果你正在处理类的方法并且不希望重复处理编译器生成的桥接方法，那么使用 `isBridge()` 可以帮助你过滤掉这些方法，只保留实际由开发者编写或真正定义的核心方法。



```java
private void addUniqueMethods(Map<String, Method> uniqueMethods, Method[] methods) {
    // 遍历当前类的所有方法
    for (Method currentMethod : methods) {
      if (!currentMethod.isBridge()) {
          // 获取方法签名
        String signature = getSignature(currentMethod);
        // check to see if the method is already known
        // if it is known, then an extended class must have
        // overridden a method
        if (!uniqueMethods.containsKey(signature)) {
          uniqueMethods.put(signature, currentMethod);
        }
      }
    }
  }
```

