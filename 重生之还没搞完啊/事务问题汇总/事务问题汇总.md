## @Transactional事务问题汇总

### 一、文章推荐

一些讲解@Transactional比较好的文章：

- https://blog.csdn.net/minghao0508/article/details/124374637
- https://blog.csdn.net/Li_WenZhang/article/details/141854713

### 二、一些常见问题汇总

demo中都是通过mp框架完成对数据库的操作来进行演示，对一些常见的事务问题进行演示和整理。

#### 1、场景一：在try-catch的捕捉异常处理中发生异常是否会回滚

结论：在try-catch的捕捉异常处理中发生异常会发生回滚，知道@Transactional的原理后其实不难解释，因为是AOP对目标方法的前后实现增强，对增强方法执行过程中出现的异常进行捕获，并进行数据的回滚。

实体类：

```java
@Data
@EqualsAndHashCode(callSuper = true)
public class Demo extends Model<Demo> {
    
    @TableId(value = "id", type= IdType.ASSIGN_ID)
    private Integer id;

    private String name;
}
```

业务逻辑层：

```java
@Service
public class DemoServiceImpl extends ServiceImpl<DemoMapper, Demo> implements DemoService {

    @Transactional(rollbackFor = Exception.class)
    public void methodA() throws Exception {
        try {

            // 添加demo数据
            Demo demo = new Demo();
            demo.setId(1);
            demo.setName("张三");
            updateById(demo);

            // 手动抛出异常
            throw new Exception();
        } catch (Exception ex) {
            log.error("发生异常！");
            // 模拟catch中发送异常
            throw new Exception();
        }
    }

}
```

测试类：

```java
@SpringBootTest
class DemoApplicationTests {

    @Test
    void contextLoads() {
    }


    @Resource
    private DemoService demoService;

    @Test
    void test() throws Exception {
        demoService.methodA();
    }
    
}
```

原始数据：

![image-20250301220526699](%E4%BA%8B%E5%8A%A1%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB.assets/image-20250301220526699.png)

运行结果：

执行对应方法后，对demo表中对id=1数据的更新操作回滚。



#### 2、场景二：不同线程处理事务

结论：不同线程的事务相互独立

实体类：增加逻辑删除delFlag字段

```java
@Data
@EqualsAndHashCode(callSuper = true)
public class Demo extends Model<Demo> {
    
    @TableId(value = "id", type= IdType.ASSIGN_ID)
    private Integer id;

    private String name;

    @TableLogic
    private String delFlag;
}
```

业务逻辑层:

```java
@Service
public class DemoServiceImpl extends ServiceImpl<DemoMapper, Demo> implements DemoService, ApplicationContextAware {

    private ApplicationContext applicationContext;

    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
    }

    @Transactional(rollbackFor = Exception.class)
    public void methodA() throws Exception {
	
        Demo demo = baseMapper.selectById(1);
        System.out.println("methodA查询demo数据结果：" + demo);
        
        baseMapper.deleteById(1);

        new Thread(() -> {
            try {
                // 这里一定要这么去获取代理对象，而不是使用this去调用methodB方法
                DemoServiceImpl bean = applicationContext.getBean(DemoServiceImpl.class);
                bean.methodB();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }).start();

        Thread.sleep(5000);

    }

    @Transactional(rollbackFor = Exception.class)
    public void methodB() throws Exception {

        Demo demo = baseMapper.selectById(1);
        System.out.println("methodB查询demo数据结果：" + demo);

        Demo demo1 = new Demo();
        demo1.setId(2);
        demo1.setName("张三");
        save(demo);

        // 保证methodB执行必然发生异常（运行时异常）
        int i = 1 / 0;

    }


}
```

测试类：

```java
@SpringBootTest
class DemoApplicationTests {

    @Test
    void contextLoads() {
    }

    @Resource
    private DemoService demoService;

    @Test
    void test() throws Exception {
        demoService.methodA();
    }

}
```

原始数据：

![image-20250302214405594](%E4%BA%8B%E5%8A%A1%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB.assets/image-20250302214405594.png)

执行结果：

```
methodA查询demo数据结果：Demo(id=1, name=张三, delFlag=0)
methodB查询demo数据结果：Demo(id=1, name=张三, delFlag=0)
```

![image-20250302214450053](%E4%BA%8B%E5%8A%A1%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB.assets/image-20250302214450053.png)

首先methodA和methodB都通过@Transactional(rollbackFor = Exception.class)注解声明事务，其使用的默认传播方式为：REQUIRED（如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。这是默认值）

从结果可以看到，如果methodB和methodA在同一个事务中执行，那么在methodA中奖id=1的数据删除后，methodB就不应该再将其查出来，以及methodB出现异常后，methodA应该将id=1数据删除也回滚。通过上述两个证明，可以看出不同线程的事务是独立的。





#### 3、场景三

```java
// method1 和 method2位于不同的类
@Component
public class A{
    @Rerouse
    private B b;
    
 	@Transactional(rollbackFor = Exception.class)
    public void method() {
         try {
            // 其他业务逻辑……
            // 更新A表的状态： 1 -> 2 
            // 其他业务逻辑……
             b.method();
        } catch (Exception ex) {
            // 将异常信息写入A表
             throw new BizException();
        }
    }   
}


@Component
public class B{
    
 	@Transactional(rollbackFor = Exception.class)
    public void method() {
         try {
            // 其他业务逻辑……
            // 更新A表的状态： 1 -> 2 
            // 其他业务逻辑……
        } catch (Exception ex) {
            // 将异常信息写入A表
             throw new BizException();
        }
    }   
}


```

本意是只想B报错后，其中B的method方法中所做的操作回滚，但是由于默认隔离级别，B发生异常后，也会导致A中对A表中进行的操作回滚。





```java
// method1 和 method2位于不同的类
@Component
public class A{
    @Rerouse
    private B b;
    
 	@Transactional(rollbackFor = Exception.class)
    public void method() {
         try {
            // 其他业务逻辑……
            // 更新A表的状态： 1 -> 2 
            // 其他业务逻辑……
        } catch (Exception ex) {
            // 将异常信息写入A表
             throw new BizException();
        }
        
        try {
            b.method();
        } catch (Exception ex) {
            
        }
    }   
}


@Component
public class B{
    
 	@Transactional(rollbackFor = Exception.class)
    public void method() {
         try {
            // 其他业务逻辑……
            // 更新A表的状态： 1 -> 2 
            // 其他业务逻辑……
        } catch (Exception ex) {
            // 将异常信息写入A表
             throw new BizException();
        }
    }   
}


```

如果这样呢，不让B的异常在A中抛出，只是传递？

会报：Transaction rolled back because it has been marked as rollback-only

详情见：https://blog.csdn.net/qq_42706375/article/details/125476493



```java
// method1 和 method2位于不同的类
@Component
public class A{
    @Rerouse
    private B b;
    
 	@Transactional(rollbackFor = Exception.class)
    public void method() {
         try {
            // 其他业务逻辑……
            // 更新A表的状态： 1 -> 2 
            // 其他业务逻辑……
        } catch (Exception ex) {
            // 将异常信息写入A表
             throw new BizException();
        }
        
        try {
            b.method();
        } catch (Exception ex) {
            
        }
    }   
}


@Component
public class B{
    
 	@Transactional(rollbackFor = Exception.class, read)
    public void method() {
         try {
            // 其他业务逻辑……
            // 更新A表的状态： 1 -> 2 
            // 其他业务逻辑……
        } catch (Exception ex) {
            // 将异常信息写入A表
             throw new BizException();
        }
    }   
}


```

修改隔离级别，会因为不同事物出现对锁的竞争，导致数据库超时。