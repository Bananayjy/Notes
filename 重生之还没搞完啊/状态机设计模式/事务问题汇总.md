## 事务问题汇总

### 一、状态机设计模式下遇到的事务问题

#### 1.业务场景描述

下述将我方系统统称为SA进行描述，业务表统称为A表，补偿表统称为C表

C表将状态字段分为4个，作为状态机扭转的依据、保存当前状态异常信息以及后续的补偿任务：

- 初始状态（0）：数据推过来后，将请求信息落库到C表中，初始化推送数据到C表中
- 主档落库完成（1）：在完成主档数据落库到A表后，修改C表中的状态
- 详情信息获取完成（2）：在完成对主档数据的详情信息获取（通过调用第三方接口获取）后，修改C表中的状态
- 钉钉通知完成/业务完成（3）: 完成对应主档数据中联系人的钉钉消息推送，修改C表中的状态

业务下,SA通过对外提供api供第三方服务调用来进行业务主档数据的推送，SA在接受到第三方服务的主档数据后，首先会将推送记录初始化到C表中，此时C表中该数据的状态为0；之后将主档信息落库到A表中，修改C表状态（0 -> 1）；后需要调用第三方服务的api接口去获取详情信息，并将详情信息更新到A表中，并修改C表状态（1 -> 2）；后对主档数据中的联系人进行钉钉消息通知，成功后修改C表状态（2 -> 3）；

具体的状态机模式（State Machine Pattern）应用和代码实现这里不就过多说明了，本章只要讨论遇到的事务问题，在下面会对该块业务中主要内容进行简单抽取，整理为一个demo，并进行测试。

#### 2.demo

将上述业务中的主要内容简单抽取，具体代码demo如下所示：

```java
@Component
public class ConcreteStateA{
    
 	@Transactional(rollbackFor = Exception.class)
    public void method() {
         try {
            // 其他业务逻辑，对A表进行操作……
            // 更新C表的状态： 0 -> 1 
            // 其他业务逻辑，对A表进行操作……
             // 更新上下文的状态机实现类为下一个
        } catch (Exception ex) {
            // 将异常信息写入C表，回滚C表状态
             throw new BizException();
        }
    }   
}
```

这里对状态机模式做了简化，通过如下的UML图分析，ConcreteStateA的method方法对应ConcreteStateA中的handle方法，method方法调用在状态机设计模式下需要通过上下文去进行调度，先对上下文类中维护的State对象的实现类进行切换，再去调用不同State的实现类的handle方法，从而实现不同状态下业务内容的执行。

![5d1eb733381c5253d3d439c96302c79](%E4%BA%8B%E5%8A%A1%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB.assets/5d1eb733381c5253d3d439c96302c79.jpg)

事务问题主要出现在try-catch中对补偿表C表的状态更新和捕捉到异常后，将异常信息写入C表，并回滚这两个操作中，对C表的操作的demo代码如下

```java
@Component
public class CompensationService{
    
 	@Transactional(rollbackFor = Exception.class)
    public void nextStatus(C c) {
        c.setStatus(c.getStatus() + 1);
        updateById(c);
    }   
    
    @Override
    @Transactional(rollbackFor = Exception.class)
    public void recordExMsg(C c, Exception ex) {

        // 异常信息
        String exMsg = "异常！";

        if(ex instanceof BizException) {
            exMsg = ((BizException) ex).getDefaultMessage();
        } else {
            exMsg = ex.getMessage();
        }
        c.setException(exMsg);
        c.setTimes(c.getTimes() + 1);
        updateById(c);
    }
    
}
```

总结demo如下：

```java
@Component
public class ConcreteStateA{
    
    private CompensationService compensationService;
    
 	@Transactional(rollbackFor = Exception.class)
    public void method() {
         try {
            // 其他业务逻辑，对A表进行操作……
            // 更新C表的状态： 0 -> 1 
             compensationService.nextStatus(c);
            // 其他业务逻辑，对A表进行操作……
        } catch (Exception ex) {
            // 将异常信息写入C表，回滚C表状态
             compensationService.recordExMsg(c, ex);
             throw new BizException();
        }
    }   
}
```













## 1、场景一

```java
@Transactional(rollbackFor = Exception.class)
public void method() {
     try {
        // 其他业务逻辑……
     	// 更新A表的状态： 1 -> 2 
        // 其他业务逻辑……
    } catch (Exception ex) {
		// 将异常信息写入A表
         throw new BizException();
    }
}
```

愿意是想在try-catch中业务逻辑执行报错，进行报错日志的记录。

注意这里添加了事务，隔离级别默认。

此时将异常信息写入A表异常后，同样会将写入A表的数据回滚。因为事务是对整个方法的增强！



## 2、场景二

```java
// method1 和 method2位于不同的类
@Component
public class A{
    @Rerouse
    private B b;
    
 	@Transactional(rollbackFor = Exception.class)
    public void method() {
         try {
            // 其他业务逻辑……
            // 更新A表的状态： 1 -> 2 
            // 其他业务逻辑……
             b.method();
        } catch (Exception ex) {
            // 将异常信息写入A表
             throw new BizException();
        }
    }   
}


@Component
public class B{
    
 	@Transactional(rollbackFor = Exception.class)
    public void method() {
         try {
            // 其他业务逻辑……
            // 更新A表的状态： 1 -> 2 
            // 其他业务逻辑……
        } catch (Exception ex) {
            // 将异常信息写入A表
             throw new BizException();
        }
    }   
}


```

本意是只想B报错后，其中B的method方法中所做的操作回滚，但是由于默认隔离级别，B发生异常后，也会导致A中对A表中进行的操作回滚。



## 3、场景三

```java
// method1 和 method2位于不同的类
@Component
public class A{
    @Rerouse
    private B b;
    
 	@Transactional(rollbackFor = Exception.class)
    public void method() {
         try {
            // 其他业务逻辑……
            // 更新A表的状态： 1 -> 2 
            // 其他业务逻辑……
        } catch (Exception ex) {
            // 将异常信息写入A表
             throw new BizException();
        }
        
        try {
            b.method();
        } catch (Exception ex) {
            
        }
    }   
}


@Component
public class B{
    
 	@Transactional(rollbackFor = Exception.class)
    public void method() {
         try {
            // 其他业务逻辑……
            // 更新A表的状态： 1 -> 2 
            // 其他业务逻辑……
        } catch (Exception ex) {
            // 将异常信息写入A表
             throw new BizException();
        }
    }   
}


```

如果这样呢，不让B的异常在A中抛出，只是传递？

会报：Transaction rolled back because it has been marked as rollback-only

详情见：https://blog.csdn.net/qq_42706375/article/details/125476493



## 4、场景三

```java
// method1 和 method2位于不同的类
@Component
public class A{
    @Rerouse
    private B b;
    
 	@Transactional(rollbackFor = Exception.class)
    public void method() {
         try {
            // 其他业务逻辑……
            // 更新A表的状态： 1 -> 2 
            // 其他业务逻辑……
        } catch (Exception ex) {
            // 将异常信息写入A表
             throw new BizException();
        }
        
        try {
            b.method();
        } catch (Exception ex) {
            
        }
    }   
}


@Component
public class B{
    
 	@Transactional(rollbackFor = Exception.class, read)
    public void method() {
         try {
            // 其他业务逻辑……
            // 更新A表的状态： 1 -> 2 
            // 其他业务逻辑……
        } catch (Exception ex) {
            // 将异常信息写入A表
             throw new BizException();
        }
    }   
}


```

修改隔离级别，会因为不同事物出现对锁的竞争，导致数据库超时。