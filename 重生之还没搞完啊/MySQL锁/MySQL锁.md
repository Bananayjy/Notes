# MySQL锁

## 一、前言

### 1.1 说明

锁是计算机协调多个进程或线程”并发访问某一资源 的机制。在程序开发中会存在多线程同步的问题，当多个线程并发访问某个数据的时候，尤其是针对一些敏感的数据(比如订单、金额等)，我们就需要保证这个数据在任何时刻最多只有一个线程在访问，保证数据的完整性和一致性。在开发过程中加锁是为了保证数据的一致性，这个思想在数据库领域中同样很重要。

在数据库中，除传统的计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供许多用户共享的资源。为保证数据的一致性，需要对 并发操作进行控制 ，因此产生了 锁 。同时 锁机制 也为实现MySQL的各个隔离级别提供了保证。 锁冲突 也是影响数据库 并发访问性能 的一个重要因素。所以锁对数据库而言显得尤其重要，也更加复杂。

MySQL中事务的隔离性就是由锁来实现的。

### 1.2 解决并发问题方案(针对读和写/写和读)

怎么解决脏读 、 不可重复读 、 幻读这些问题有两种可选的解决方案:

方案一：读操作利用多版本并发控制(MVCC)，写操作进行加锁

所谓的 MVCC，就是生成一个Readview，通过Readview找到符合条件的记录版本(历史版本由undo日志构建)。查询语句只能读 到在生成ReadView之前已提交事务所做的更改，在生成ReadView之前未提交的事务或者之后才开启的事务所做的更改是看不到的。而写操作 肯定针对的是最新版本的记录 ，读记录的历史版本和改动记录的最新版本本身并不冲突，也就是采用MVCC时，读-写操作并不冲突。

> 普通的SELECT语句在READCOMMITTED和REPEATABLEREAD隔离级别下会使用到MVCC读取记录。
>
> - 在READ COMMITTED隔离级别下，一个事务在执行过程中每次执行SELECT操作时都会生成一个ReadView，ReadView的存在本身就保证了事务不可以读取到未提交的事务所做的更改，也就是避免了脏读现象;
> - 在 REPEATABLE READ隔离级别下，一个事务在执行过程中只有第一次执行SELECT操作 才会生成一个ReadView，之后的SELECT操作都 复用 这个ReadView，这样也就避免了不可重复读和幻读的问题。

方案二：读、写操作都采用 加锁 的方式

如果我们的一些业务场景不允许读取记录的旧版本，而是每次都必须去 读取记录的最新版本。比如，在银行存款的事务中，你需要先把账户的余额读出来，然后将其加上本次存款的数额，最后再写到数据库中。在将账户余额读取出来后，就不想让别的事务再访问该余额，直到本次存款事务执行完成，其他事务才可以访问账户的余额。这样在读取记录的时候就需要对其进行 加锁 操作，这样也就意味着 读 操作和 写 操作也像 写-写 操作那样需要排队执行。
**脏读** 的产生是因为当前事务读取了另一个未提交事务写的一条记录，如果另一个事务在写记录的时候就给这条记录加锁，那么当前事务就无法继续读取该记录了，所以也就不会有脏读问题的产生了。
**不可重复读** 的产生是因为当前事务先读取一条记录，另外一个事务对该记录做了改动之后并提交之后，当前事务再次读取时会获得不同的值，如果在当前事务读取记录时就给该记录加锁，那么另一个事务就无法修改该记录，自然也不会发生不可重复读了。
**幻读** 问题的产生是因为当前事务读取了一个范围的记录，然后另外的事务向该范围内插入了新记录，当前事务再次读取该范围的记录时发现了新插入的新记录。采用加锁的方式解决幻读问题就有一些麻烦，因为当前事务在第一次读取记录时幻影记录并不存在，所以读取的时候加锁就有点尴尬(后续有间隙锁来实现)。

小结:

- 采用 MVCC 方式的话，读-写操作彼此并不冲突，性能更高。
- 采用 加锁 方式的话，读-写操作彼此需要 排队执行，影响性能。

般情况下我们当然愿意采用 MVCC 来解决读-写操作并发执行的问题，但是业务在某些特殊情况下，要求必须采用加锁的方式执行。



## 二、并发事务访问情况

并发事务访问可以分为三种情况：

### 2.1 先读后读

读-读情况，即并发事务相继读取相同的记录 。读取操作本身不会对记录有任何影响，并不会引起什么问题，所以允许这种情况的发生。

### 2.2 先写后写

写-写 情况，即并发事务相继对相同的记录做出改动。

在这种情况下会发生脏写的问题(有一条记录如1，A和B此时都读取到的记录为1，A对该记录进行修改为2并提交，此时B对该记录修改为3后回滚，对于A来说最终结果还是1，出现了脏写)，任何一种隔离级别都不允许这种问题的发生。所以在多个未提交事务相继对一条记录做改动时，需要让它们 排队执行 ，这个排队的过程其实是通过 锁 来实现的。这个所谓的锁其实是一个 内存中的结构 ，在事务执行前本来是没有锁的，也就是说一开始是没有 锁结构 和记录进行关联的，如图所示：

![image-20241203214516807](MySQL%E9%94%81.assets/image-20241203214516807.png)

当一个事务想对这条记录做改动时，首先会看看内存中有没有与这条记录关联的 锁结构 ，当没有的时候就会在内存中生成一个 锁结构 与之关联。比如，事务 T1 要对这条记录做改动，就需要生成一个 锁结构与之关联(如果有两个事物，就会有两个索结构，其是和事物相关的)：

![image-20241203214659978](MySQL%E9%94%81.assets/image-20241203214659978.png)

在锁结构里有很多信息，为了简化理解，只把两个比较重要的属性拿了出来:

- trx信息：代表这个锁结构是哪个事物生成的
- is_waiting:代表当前事务是否在等待

当事务 T1改动了这条记录后，就生成了一个 锁结构 与该记录关联，因为之前没有别的事务为这条记录加锁，所以 is_waiting属性就是 false，我们把这个场景就称之为 获取锁成功，或者加锁成功 ，然后就可以继续执行操作了。

在事务 T1提交之前，另一个事务 T2 也想对该记录做改动，那么先看看有没有 锁结构 与这条记录关联，发现有一个 锁结构 与之关联后，然后也生成了一个锁结构与这条记录关联，不过锁结构的is_waiting属性值为 true，表示当前事务需要等待，我们把这个场景就称之为 获取锁失败 ，或者加锁失败，图示:

![image-20241203215208597](MySQL%E9%94%81.assets/image-20241203215208597.png)

在事务T1提交之后，就会把该事务生成的 锁结构释放 掉，然后看看还有没有别的事务在等待获取锁，发现了事务T2还在等待获取锁，所以把事务T2对应的锁结构的 is_waiting 属性设置为 false，然后把该事务对应的线程唤醒，让它继续执行，此时事务T2就算获取到锁了。效果图就是这样:

![image-20241203215254499](MySQL%E9%94%81.assets/image-20241203215254499.png)

说明：

（1）不加锁

不需要在内存中生成对应的 锁结构，可以直接执行操作。

（2）获取锁成功，或者加锁成功

在内存中生成了对应的 锁结构，而且锁结构的 is_waiting 属性为 false，也就是事务可以继续执行操作。

（3）获取锁失败，或者加锁失败，或者没有获取到锁

在内存中生成了对应的 锁结构 ，不过锁结构的 is_waiting属性为 true，也就是事务需要等待，不可以继续执行操作。

### 2.3 先读后写/先写后读

读-写或写-读 ，即一个事务进行读取操作，另一个进行改动操作。这种情况下可能发生 脏读 、不可重复读、幻读的问题。

各个数据库厂商对 SQL标准 的支持都可能不一样。比如MySQL在 REPEATABLE READ 隔离级别上就已经解决了幻读 问题。



## 三、锁的分类

### 3.1 分类

**1. 根据数据操作类型划分**

- 读锁/共享锁
- 写锁/排他锁

**2. 根据锁粒度角度划分**

> 对一条记录加锁影响的是这条记录，该锁的粒度比较细;一个事务也可以在表级别进行加锁，称为表级锁或者表锁，对一个表加锁影响整个表中的记录，这个锁的粒度比较粗。锁的粒度主要可以分为表级锁、页级锁和行锁。

- 表级锁（table lock）
  - 表级别的S锁（共享锁）、X锁（排他锁）
  - 意向锁（intention lock）
  - 自增锁（AUTO-INC锁）
  - 元数据锁（MDL锁）
- 行级锁
  - 记录锁（Record Locks）
  - 间隙锁（Gap Locks）
  - 临键锁（Next-Key Locks）
  - 插入意向锁（Insert Intention Locks）
- 页级锁

**3. 对待锁的态度划分**

- 悲观锁（Pessimistic Locking）
- 乐观锁（Optimistic Locking）

**4. 加锁方式**

- 隐式锁
- 显示锁

**5. 其他**

- 全局锁
- 死锁



### 3.2 数据操作类型：读锁/共享锁、写锁/排他锁

对于数据库中并发事务的 读-读 情况并不会引起什么问题。对于 写-写、 读-写 或 写-读 这些情况可能会引起一些问题，需要使用 MVCC 或者加锁 的方式来解决它们。在使用 加锁 的方式解决问题时，由于既要允许 读-读 情况不受影响，又要使写-写、 读-写 或 写-读 情况中的操作 相互阻塞，所以MySQL实现一个由两种类型的锁组成的锁系统来解决。这两种类型的锁通常被称为 共享锁(Shared Lock，S Lock)和 排他锁(Exclusive Lock，X Lock)也叫读锁(readlock)和写锁(write lock)。

- 读锁:也称为 共享锁、英文用s表示。针对同一份数据，多个事务的读操作可以同时进行而不会互相影响相互不阻塞的。
- 写锁: 也称为 排他锁 、英文用x表示。当前写操作没有完成前，它会阻断其他写锁和读锁。这样就能确保在给定的时间里，只有一个事务能执行写入，并防止其他用户读取正在写入的同一资源。

需要注意的是对于 InnoDB 引擎来说，读锁和写锁可以加在表上，也可以加在行上。

举例(行级读写锁):如果一个事务 T1已经获得了某个行r的读锁，那么此时另外的一个事务 T2 是可以去获得这个行r的读锁的，因为读取操作并没有改变行r的数据;但是，如果某个事务 T3 想获得行r的写锁，则它必须等待事务 T1、T2 释放掉行r上的读锁才行。

总结:这里的兼容是指对同一张表或记录的锁的兼容性情况。

|      | X锁    | S锁    |
| ---- | ------ | ------ |
| X锁  | 不兼容 | 不兼容 |
| S锁  | 不兼容 | 兼容   |

#### 1.锁定读

在采用 加锁 方式解决 脏读 、 不可重复读 、 幻读 这些问题时，读取一条记录时需要获取该记录的 S锁，其实是不严谨的，有时候需要在读取记录时就获取记录的 X锁 （对于读也可以加上一个排他的行为，对于写锁明确是排他的，但对于读锁既可以是共享的 也可以是排他的），来禁止别的事务读写该记录，为此MySQL提出了两种比较特殊的 SELECT 语句格式:

- 对读取的记录加 S锁:

```mysql
SELECT ... LOCK IN SHARE MODE;
#或
SELECT ...FOR SHARE;#(8.0新增语法)
```

在普通的SELECT语句后边加LOCK IN SHARE MODE，如果当前事务执行了该语句，那么它会为读取到的记录加 S锁 ，这样允许别的事务继续获取这些记录的 S锁(比方说别的事务也使用 SELECT... LOCK IN SHAREMODE 语句来读取这些记录)，但是不能获取这些记录的X锁(比如使用 SELECT..· FOR UPDATE 语句来读取这些记录，或者直接修改这些记录)。如果别的事务想要获取这些记录的X锁，那么它们会阻塞，直到当前事务提交之后将这些记录上的 S锁 释放掉。

示例一：读读

```mysql
-- 客户端一（session1）：
begin;
select * from table lock in share mode; -- 获取S锁，可以查询到数据

-- 客户端二（session2）
begin;
select * from table lock in share mode; -- 获取S锁，可以查询到数据
```



- 对读取的记录加 X锁：

```mysql
SELECT ... FOR UPDATE;
```

在普通的SELECT语句后边加FOR UPDATE，如果当前事务执行了该语句，那么它会为读取到的记录加X锁，这样既不允许别的事务获取这些记录的 S锁(比方说别的事务使用 SELECT...LOCK IN SHARE MODE语句来读取这些记录)，也不允许获取这些记录的X锁(比如使用 SELECT ...FOR UPDATE 语句来读取这些记录，或者直接修改这些记录)。如果别的事务想要获取这些记录的S锁 或者 X锁 ，那么它们会阻塞，直到当前事务提交之后将这些记录上的 X锁 释放掉。

示例一：先读后写

```mysql
-- 客户端一（session1）：
begin;
select * from table lock in share mode; -- 获取S锁，可以查询到数据

-- 客户端二（session2）
begin;
select * from table lock in share mode; -- 获取S锁，可以查询到数据

-- 客户端三（session3）
begin;
select * from table for update; -- 获取X锁失败，无法对数据进行修改（只有当客户端一、二都commit后才可以成功查询出对应的数据）
```

示例二：先写后读

```mysql
-- 客户端一（session1）
begin;
select * from table for update; -- 获取X锁，可以修改

-- 客户端二（session2）
begin;
select * from table lock in share mode; -- 获取S锁失败，阻塞
```

示例三：先写后写

```mysql
-- 客户端一（session1）
begin;
select * from table for update; -- 获取X锁，可以修改

-- 客户端二（session2）
begin;
select * from table for update; -- 获取X锁失败，阻塞
```



不同版本对于获取不到锁的处理：

- 在5.7及之前的版本，SELECT... FOR UPDATE，如果获取不到锁，会一直等待，直到innodb_lock_wait_timeout 超时。

- 在8.0版本中，SELECT ... FOR UPDATE, SELECT ... FOR SHARE 添加NOWAIT、 SKIP LOCKED 语法，跳过锁等待，或者跳过锁定，通过添加NOWAIT、SKIP LOCKED语法，能够立即返回。如果查询的行已经加锁：

  - 那么NOWAIT会立即报错返回
  - 而SKIP LOCKED也会立即返回，只是返回的结果中不包含被锁定的行。

  示例：锁定所有行

  ```mysql
  -- 客户端一（session1）
  select * from account for update
  ```

  客户端二执行情况

  ![image-20241204232100395](MySQL%E9%94%81.assets/image-20241204232100395.png)



#### 2.写操作

对于读操作可以加排他锁和共享锁，但是对于写错做一定要加排他锁。

平常所用到的 写操作 无非是 DELETE、UPDATE、INSERT 这三种（对于DELETE、UPDATE会加排他锁即X锁，Insert在添加之前没有这条记录，所以无法加X锁，通过隐式锁去保证事务无法访问未提交的insert数据）：

- DELETE

对一条记录做DELETE操作的过程其实是先在 B+ 树中定位到这条记录的位置，然后获取这条记录的 X锁，再执行 delete mark 操作。我们也可以把这个定位待删除记录在B+树中位置的过程看成是一个获取 X锁 的 锁定读。

- UPDATE

在对一条记录做UPDATE操作时分为三种情况:

情况1:未修改该记录的键值，并且被更新的列占用的存储空间在修改前后未发生变化。则先在 B+ 树中定位到这条记录的位置，然后再获取一下记录的 X锁 ，最后在原记录的位置进行修改操作。我们也可以把这个定位待修改记录在 B+树中位置的过程看成是一个获取 X锁的 锁定读 。

情况2:未修改该记录的键值，并且至少有一个被更新的列占用的存储空间在修改前后发生变化。则先在 B+ 树中定位到这条记录的位置，然后获取一下记录的 X锁，将该记录彻底删除掉(就是把记录彻底移入垃圾链表)，最后再插入一条新记录。这个定位待修改记录在 B+ 树中位置的过程看成是一个获取X锁 的 锁定读 ，新插入的记录由 INSERT 操作提供的 隐式锁 进行保护，避免在没提交之前，被其他事务看到。（两个执行过程）

情况3:修改了该记录的键值，则相当于在原记录上做 DELETE 操作之后再来一次 INSERT操作，加锁操作就需要按照 DELETE 和 INSERT 的规则进行了（加锁过程如情况2一样）。

- INSERT

一般情况下，新插入一条记录的操作并不加锁，通过一种称之为 隐式锁 的结构来保护这条新插入的记录在本事务提交前不被别的事务访问。（其不用加锁的原因是，insert前都没有这个数据，不用担心被其他事务访问到，出现并发查询、修改的操作，因此不用加X锁，通过隐式锁去保证不被其他事务访问到）





### 3.3 锁粒度角度划分：表级锁、行级锁、页级锁

#### 1. 锁粒度的概念

为了尽可能提高数据库的并发度，每次锁定的数据范围越小越好，理论上每次只锁定当前操作的数据的方案会得到最大的并发度，但是管理锁是很`耗资源`的事情（涉及获取、检查、释放锁等动作)(越小消耗越大)。因此数据库系统需要在`高并响应`和`系统性能`两方面进行平衡。

#### 2. 表锁（table lock）

表锁会锁定整张表，是MySQL中最基本的锁策略，并不依赖于存储引擎(不管你是MySQL的什么存储引擎，
对于表锁的策略都是一样的)。表锁是`开销最小`的策略（因为粒度比较大)。由于表级锁一次会将整个表锁定，所以可以很好的避免死锁问题。当然，锁的粒度大所带来最大的负面影响就是出现锁资源争用的概率也会最高，导致并发率大打折扣。因此，表锁的特点就是开销小（不需要频繁加、放锁），但是并发能力差。

##### ①表级别的S锁、X锁（MYISAM）

表锁又可以分为共享锁（S锁）和排他锁（X锁），在系统变量`autocommit=0（InnoDB 会关闭自动提交模式），innodb_table_locks = 1（1为默认值，InnoDB 会使用表级锁。这意味着在对一个表进行操作时，整个表会被锁定，直到操作完成）`时，手动获取InnoDB存储引擎提供 的S锁或者X锁：

- InnoDB存储引擎加表级别的S锁

  ```mysql
  LOCK TABLES t READ
  ```

- InnoDB存储引擎加表级别的X锁

  ```mysql
  LOCK TABLES t WRITE
  ```

- 解锁命令（使用此命令解锁加锁的表）

  ```mysql
  unlock tables
  ```

对某个表执行SELECT、INSERT、DELETE、UPDATE语句（DML，数据操作语言）时，InnoDB存储引擎是不会为这个表添加表级别的`S锁`或者`X锁`的。在对某个表执行一些诸如`ALTER TABLE`、`DROP TABLE`这类的`DDL`语句时，其他事务对这个表并发执行诸如SELECT、INSERT、DELETE、UPDATE的语句会发生阻塞。同理，某个事务中对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，在其他会话中对这个表执行`DDL`语句也会发生阻塞。这个过程其实是通过在server层使用一种称之为`元数据锁`（英文名：`Metadata Locks`，简称`MDL`）结构来实现的。一般情况下，不会使用InnoDB存储引擎提供的`表级别`的`S锁`和`X锁`。只会在一些特殊情况下，比方说`崩溃恢复`过程中用到。

注意：不过尽量避免在使用InnoDB存储引擎的表上使用`LOCK TABLES`这样的手动锁表语句，它们并不会提供什么额外的保护，只是会降低并发能力而已。InnoDB的厉害之处还是实现了更细粒度的行锁，



要使用表级锁，我们先要关闭自动提交以及设置InnoDB使用表级锁

```mysql
-- 查看当前自动提交状态（默认为ON开启）
show variables like '%autocommit%';

-- SET autocommit = 0; 等价
SET @@autocommit = 0;
```

```mysql
-- 查看当前使用表级锁（默认为ON开启）
show variables like '%innodb_table_locks%';
-- 设置当前使用表级锁为ON（会话状态即可，不用全局）
SET innodb_table_locks = 1;
```

我们可以通过`show open tables`去查看所有表的状态，其列信息如下：

- **Database**: 表所在的数据库名。
- **Table**: 表的名称。
- **In_use**: 表的使用状态（通常是 0 或 1）。`1` 表示该表当前被某个连接使用，`0` 表示没有连接在使用该表。
- **Name_locked**: 表示该表是否被锁定，通常是 0 或 1。`1` 表示该表被锁定，`0` 表示未锁定。

```
+----------+--------------------+--------+-------------+
| Database | Table              | In_use | Name_locked |
+----------+--------------------+--------+-------------+
| mydb     | my_table           |      1 |           0 |
| mydb     | another_table      |      0 |           0 |
+----------+--------------------+--------+-------------+
```

- 通过命令`lock tables test read`给test表上表级别的S锁

通过命令`show open tables where in_use > 0;`查看上锁的表



**关于表级别所的使用示例（以MyISAM为例）：**

- 示例一（读锁）

```mysql
-- 客户端一（session1）给mytable上读表锁
lock tables mytable read

-- 客户端一（session1）查询当前表
select * from mytable   -- 可以查询出相关数据（自己可读）

-- 客户端一（session1）写当前表
update mytable set xxx = '123'  -- 不可修改/写数据（自己不可写）


-- 客户端一（session1）查询其他表
select * from mytable2  -- 不可访问操作其他表

-- 客户端二（session2）查询加锁表
select * from mytable   -- 可以查询出相关数据（他人可读）

-- 客户端二（session2）写加锁表
update mytable set xxx = '123'  -- 不可修改/写数据（他人不可写）

-- 当我们释放锁后上述不可的操作即可进行
unlock tables


```

- 示例二（写锁）

```mysql
-- 客户端一（session1）给mytable上写表锁
lock tables mytable write

-- 客户端一（session1）查询当前表
select * from mytable   -- 可以查询出相关数据（自己可读）

-- 客户端一（session1）写当前表
update mytable set xxx = '123'  -- 可修改/写数据（自己可写）

-- 客户端一（session1）查询其他表
select * from mytable2  -- 不可访问操作其他表

-- 客户端二（session2）查询加锁表
select * from mytable   -- 不可以查询出相关数据（他人不可读）

-- 客户端二（session2）写加锁表
update mytable set xxx = '123'  -- 不可修改/写数据（他人不可写）

-- 当我们释放锁后上述不可的操作即可进行
unlock tables

```



综上总结：

MyISAM在执行查询语句（SELECT）前，会给涉及的所有表加读锁，在执行增删改操作前，会给涉及的表加写锁。InnoDB存储引擎是不会为这个表添加表级别的`读锁`或者`写锁`的。（有行锁，谁TM用表锁啊）

MySQL的表级锁有两种模式：（以MyISAM表进行操作的演示）

- 表共享读锁（Table Read Lock）
- 表独占写锁（Table Write Lock）

| 锁类型 | 自己可读 | 自己可写 | 自己可操作其他表 | 他人可读 | 他人可写 |
| ------ | -------- | -------- | ---------------- | -------- | -------- |
| 读锁   | 是       | 否       | 否               | 是       | 否，等   |
| 写锁   | 是       | 是       | 否               | 否，等   | 否，等   |





##### ②意向锁（intention lock，MYISAM、Innodb都有）

InnoDB 支持 多粒度锁（multiple granularity locking） ，它允许 行级锁 与 表级锁 共存，而意向锁就是其中的一种 表锁 。

1. 意向锁的存在是为了协调行锁和表锁的关系，支持多粒度(表锁与行锁)的锁并存
2. 意向锁是一种 不与行级锁冲突表级锁 ，这一点非常重要（否则innoDB也退回成表级别的锁）
3. 表明“某个事务正在某些行持有了锁或该事务准备去持有锁”

意向锁分为两种：

- **意向共享锁**（intention shared lock, IS）：事务有意向对表中的某些行加**共享锁**（S锁），顺便会加上意向共享锁

```
-- 事务要获取某些行的 S 锁，必须先获得表的 IS 锁。
SELECT column FROM table ... LOCK IN SHARE MODE;
```

- **意向排他锁**（intention exclusive lock, IX）：事务有意向对表中的某些行加**排他锁**（X锁），顺便会加上意向排他锁

```
-- 事务要获取某些行的 X 锁，必须先获得表的 IX 锁。
SELECT column FROM table ... FOR UPDATE;
```

即：意向锁是由存储引擎 自己维护的 ，用户无法手动操作意向锁，在为数据行加共享 / 排他锁之前，InooDB 会先获取该数据行 所在数据表的对应意向锁 。



**1.关于意向锁要解决的问题**

现在有两个事务，分别是T1和T2，其中T2试图在该表级别上应用共享或排它锁，如果没有意向锁存在，那么T2就需要去检查各个页或行是否存在锁（如果是只有一条，那么这样去检查整个页的性能是很差的）;如果存在意向锁，那么此时就会受到由T1控制的 表级别意向锁的阻塞。T2在锁定该表前不必检查各个页或行锁，而只需检査表上的意向锁。简单来说就是给更大一级别的空间示意里面是否已经上过锁（行级锁 -> 页级锁 -> 表级锁）。

在数据表的场景中，如果我们给某一行数据加上了排它锁，数据库会自动给更大一级的空间，比如数据页或数据表加上意向锁，告诉其他人这个数据页或数据表已经有人上过排它锁了，这样当其他人想要获取数据表排它锁的时候，只需要了解是否有人已经获取了这个数据表的意向排他锁即可。

- 如果事务想要获得数据表中某些记录的共享锁（即加共享锁），就需要在数据表上添加意向共享锁，
- 如果事务想要获得数据表中某些记录的排他锁（即加排他锁），就需要在数据表上添加意向排他锁。

这时，意向锁会告诉其他事务已经有人锁定了表中的某些记录。



**2.举例**

示例一：

创建表

```mysql
create table `demo` (
	`id` int not null,
	`name` varchar(255) not null,
	primary key (`id`)
) ENGINE=Innodb DEFAULT CHARSET=utf8mb4
```

插入相关数据

```mysql
insert into demo values
(1, 'zhangshan'),
(2, 'lisi'),
(3, 'wangwu'),
(4, 'guagua'),
(5, 'niujiu'),
(6, 'wangba');
```

通过xshell模拟不同客户端，登录不同的mysql

```shell
docker exec -it mysql /bin/bash #因为是容器部署
mysql -uroot -p
```

在session1中查看表通过命令select @@transaction_isolation;查看当前隔离级别，为可重复度

![image-20241205214815929](MySQL%E9%94%81.assets/image-20241205214815929.png)

在session1中通过begin开启事务，对id=6的数据加上排他锁（X锁）

![image-20241205215103326](MySQL%E9%94%81.assets/image-20241205215103326.png)

在session2中通过begin开启事务，给表demo整个表加上一个表级的读锁（S锁），显而易见发生了阻塞

![image-20241205215258697](MySQL%E9%94%81.assets/image-20241205215258697.png)

即我们在表中加了一个X锁后，会给表自动加一个表级别的意向锁（IX），并且IX和S锁是不兼容的，导致我们在session2中给表加S锁的时候发生阻塞。



示例二：

session1中加排他锁，并且自动添加上IX锁

![image-20241205220308409](MySQL%E9%94%81.assets/image-20241205220308409.png)

session2中加排他锁（注意id不能和session1中一样，不让X锁和X锁相互之前会发生阻塞），并且自动添加上IX锁，并且不发生阻塞

![image-20241205220742344](MySQL%E9%94%81.assets/image-20241205220742344.png)

说明意向排他锁和意向排他锁之间不会阻塞。



**3.兼容性如下所示**

|                  | 意向共享锁（IS） | 意向排他锁（IX） |
| ---------------- | ---------------- | ---------------- |
| 意向共享锁（IS） | 兼容             | 兼容             |
| 意向排他锁（IX） | 兼容             | 兼容             |

即意向锁之间是互相兼容的，但是他会与普通的排他/共享锁互斥

|             | 意向共享锁（IS） | 意向排他锁（IX） |
| ----------- | ---------------- | ---------------- |
| 共享锁（S） | 兼容             | 互斥             |
| 排他锁（X） | 互斥             | 互斥             |



**4.结论**

1. InnoDB 支持 多粒度锁 ，特定场景下，行级锁可以与表级锁共存。
2. 意向锁之间互不排斥，但除了 IS 与 S 兼容外， 意向锁会与 共享锁 / 排他锁 互斥 。
3. IX，IS是表级锁，不会和行级的X，S锁发生冲突。只会和表级的X，S发生冲突。
4. 意向锁在保证并发性的前提下，实现了 行锁和表锁共存 且 满足事务隔离性 的要求。
5. 意向锁不会与行级的共享/排他锁互斥（意向锁一般是表级以上，因为加了行锁才有表级别意向锁）！正因为如此，意向锁并不会影响到多个事务对不同数据行加排他锁时的并发性。（不然我们直接用普通的表锁就行了）



##### ③自增锁（AUTO-INC锁，MYISAM、Innodb都有）

在使用MySQL过程中，我们可以为表的某个列添加AUTO_INCREMENT属性。举例：

```mysql
create table `demo` (
	`id` int not null AUTO_INCREMENT,
	`name` varchar(255) not null,
	primary key (`id`)
) ENGINE=Innodb DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci

```

由于这个表的id字段声明了AUTO_INCREMENT，意味着在书写插入语句时不需要为其赋值，SQL语句修改

如下所示。

```mysql
INSERTINTO`demo`(name) VALUES ('zhangsan'),('lisi');
```

上边的插入语句并没有为id列显式赋值，所以系统会自动为它赋上递增的值。

现在我们看到的上面插入数据只是一种简单的插入模式，所有插入数据的方式总共分为三类，分别是：Simple inserts、Bulk inserts、Mixed-mode inserts。

1、Simple inserts （简单插入）

可以从SQL语句中预先确定要插入的行数(当语句被初始处理时)的语句。包括没有嵌套子查询的单行和多行INSERT...VALUES()和 REPLACE 语句。比如我们上面举的例子就属于该类插入，已经确定要插入的行数。

2、Bulk inserts （批量插入）

事先不知道要插入的行数(和所需自动递增值的数量)的语句。比如 INSERT ... SELECT， REPLACE ……。SELECT和 LOAD DATA语句，但不包括纯INSERT。InnoDB在每处理一行，为AUTO_INCREMENT列分配一个新值。

3、Mixed-mode inserts （混合模式插入）

这些是“Simple inserts”语句但是指定部分新行的自动递增值。例如INSERT INT0 teacher(id,name) VALUES(1,'a')，(NULL,'b')，(5,'c')，(NULL,'d');只是指定了部分id的值。另一种类型的“混合模式插入”是INSERT ... ON DUPLICATE KEY UPDATE。



对于上面数据插入的案例，MySQL中采用了自增锁 的方式来实现，AUTO-INC锁是当向使用含有AUTO_INCREMENT列的表中插入数据时需要获取的一种特殊的表级锁，在执行插入语句时就在表级别加一个AUTO-INC锁，然后为每条待插入记录的AUTO_INCREMENT修饰的列分配递增的值，在该语句执行结束后，再把AUTO-INC锁释放掉。一个事务在持有AUTO-INC锁的过程中，其他事务的插入语句都要被阻塞，可以保证一个语句中分配的递增值是连续的。也正因为此，其并发性显然并不高，当我们向一个有AUTO_INCREMENT关键字的主键插入值的时候，每条语句都要对这个表锁进行竞争，这样的并发潜力其实是很低下的，所以innodb通过 innodb_autoinc_lock_mode的不同取值来提供不同的锁定机制，来显著提高SQL语句的可伸缩性和性能。

（1）innodb_autoinc_lock_mode=0(“传统”锁定模式)

在此锁定模式下，所有类型的insert语句都会获得一个特殊的表级AUTO-INC锁，用于插入具有AUTO_INCREMENT列的表。这种模式其实就如我们上面的例子，即每当执行insert的时候，都会得到一个表级锁(AUTO-INC锁)，使得语句中生成的auto_increment为顺序，且在binlog中重放的时候，可以保证master与slave中数据的auto_increment是相同的。因为是表级锁，当在同一时间多个事务中执行insert的时候，对于AUTO-INC锁的争夺会限制并发能力。

（2）innodb_autoinc_lock_mode=1(“连续”锁定模式)

在MySQL8.0之前，连续锁定模式是默认的。

在这个模式下，“bulk inserts”仍然使用AUTO-INC表级锁（批量插入，不知道插入的数量，需要表级锁去取进行控制），并保持到语句结束。这适用于所有INSERT...SELECT，REPLACE...SELECT和LOADDATA语句。同一时刻只有一个语句可以持有AUTO-INC锁。

对于“Simple inserts”（要插入的行数事先已知），则通过在mutex（轻量锁）的控制下获得所需数量的

自动递增值来避免表级AUTO-INC锁，它只在分配过程的持续时间内保持，而不是直到语句完成。不使用表级AUTO-INC锁，除非AUTO-INC锁由另一个事务保持。如果另一个事务保持AUTO-INC锁，则“Simple inserts”等待AUTO-INC锁，如同它是一个“bulk inserts”。

注意，对于Simple inserts也要握到AUTO-INC表级锁，其只不过相较于bulk inserts是很快就释放了而已，如果其他事务持有AUTO-INC表级锁的话，对于Simple inserts仍然会阻塞。

（3）innodb_autoinc_lock_mode=2(“交错”锁定模式)

从 MySOL 8.0 开始，交错锁模式是 默认 设置。
在这种锁模式下，所有类INSERT语句都不会使用表级AUTO-INC锁，并且可以同时执行多个语句。这是最快和最可扩展的锁定模式，当时当使用基于语句的复制或恢复方案时，从二进制日志重播SQL语句时，这是不安全的。
在此锁定模式下，自动递增值 保证 在所有并发执行的所有类型的insert语句中是 唯一且单调递增 的。但是，由于多个语句可以同时生成数字(即，跨语句交叉编号)，为任何给定语句插入的行生成的值可能不是连续的。
如果执行的语句是“simple inserts”，其中要插入的行数已提前知道，除了“Mixed-mode inserts”之外，为单个语句生成的数字不会有间隙。然而，当执行“bulk inserts”时，在由任何给定语句分配的自动递增值中可能存在间隙。



##### ④元数据锁（MDL锁，MYISAM、Innodb都有）

MySQL5.5引入了meta data lock，简称MDL锁，属于表锁范畴。MDL的作用是，保证读写的正确性。比如，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个 表结构做变更，增加了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。
因此，当对一个表做增删改查操作的时候，加 MDL读锁;当要对表做结构变更操作的时候，加 MDL 写锁。
读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性，解决了DML和DDL操作之间的一致性问题。不需要显式使用，在访问一个表的时候会被自动加上。

示例一：

session1

查询加一个读锁

![image-20241206000147342](MySQL%E9%94%81.assets/image-20241206000147342.png)

session2

发生阻塞

![image-20241206000212188](MySQL%E9%94%81.assets/image-20241206000212188.png)

session3

show processlist可以看到，当前session2修改表结构正在等待元数据锁

![image-20241206000521676](MySQL%E9%94%81.assets/image-20241206000521676.png)



示例二：

![image-20241205230047527](MySQL%E9%94%81.assets/image-20241205230047527.png)



#### 3.行锁

**概念**

行锁(Row Lock)也称为记录锁，顾名思义，就是锁住某一行(某条记录row)。需要的注意的是，MySQL服务器层并没有实现行锁机制，行级锁只在存储引擎层实现。

关于InnoDB与MyISAM的最大不同有两点：一是支持事务（TRANSACTION）；二是采用了行级锁； 

**优缺点**

优点：锁定力度小，发生 锁冲突概率低 ，可以实现的 并发度高。

缺点：对于锁的开销比较大，加锁会比较慢，容易出现 死锁 情况

**初始化**

表结构初始化

```mysql
CREATE TABLE `student` (
    `id` INT(11),
    `name` VARCHAR(30),
    `class` VARCHAR(30),
    PRIMARY KEY (`id`)
) ENGINE=INNODB CHARSET=utf8;
```

数据预处理

```mysql

INSERT INTO `student` VALUES
(1, "张三", "一班"),
(3, "李四", "一班"),
(8, "王五", "二班"),
(15, "赵六", "二班"),
(20, "钱七", "三班");

```

student表中的聚簇索引的简图如下所示

![image-20241207141536607](MySQL%E9%94%81.assets/image-20241207141536607.png)

这里把B+树的索引结构做了一个超级简化，只把索引中的记录给拿了出来。下面的行级锁都是通过该表进行演示。



##### ①记录锁（Record Locks）

记录锁也就是仅仅把一条记录锁上，官方的类型名称为： LOCK_REC_NOT_GAP 。比如我们把id值为8的

那条记录加一个记录锁的示意图如图所示。仅仅是锁住了id值为8的记录，对周围的数据没有影响。

![image-20241207141957487](MySQL%E9%94%81.assets/image-20241207141957487.png)

![image-20241207142044044](MySQL%E9%94%81.assets/image-20241207142044044.png)

记录锁是有S锁和X锁之分的，称之为 S型记录锁 和 X型记录锁 。

- 当一个事务获取了一条记录的S型记录锁后，其他事务也可以继续获取该记录的S型记录锁，但不可

  以继续获取X型记录锁；

- 当一个事务获取了一条记录的X型记录锁后，其他事务既不可以继续获取该记录的S型记录锁，也不

  可以继续获取X型记录锁。



##### ②间隙锁（Gap Locks）

MySQL 在 REPEATABLE READ 隔离级别下是可以解决幻读问题的，解决方案有两种，可以使用 MVCC 方案解决，也可以采用 加锁 方案解决。但是在使用加锁方案解决时有个大问题，就是事务在第一次执行读取操作时，那些幻影记录尚不存在，我们无法给这些 幻影记录 加上 记录锁 。InnoDB提出了一种称之为Gap Locks 的锁，官方的类型名称为： LOCK_GAP ，我们可以简称为 gap锁 。比如，把id值为8的那条记录加一个gap锁的示意图如下。

![image-20241207143855911](MySQL%E9%94%81.assets/image-20241207143855911.png)

图中id值为8的记录加了gap锁，意味着 不允许别的事务在id值为8的记录前边的间隙插入新记录 ，其实就是id列的值(3, 8)这个区间的新记录是不允许立即插入的。比如，有另外一个事务再想插入一条id值为4的新记录，它定位到该条新记录的下一条记录的id值为8，而这条记录上又有一个gap锁，所以就会阻塞插入操作，直到拥有这个gap锁的事务提交了之后，id列的值在区间(3, 8)中的新记录才可以被插入。

gap锁的提出仅仅是为了防止插入幻影记录而提出的。虽然有共享gap锁和 独占gap锁 这样的说法，但是它们起到的作用是相同的。而且如果对一条记录加了gap锁(不论是共享gap锁还是独占gap锁)，并不会限制其他事务对这条记录加记录锁或者继续加gap锁。

具体示例：

示例一：

session1中开启一个查询，并且加上S锁

![image-20241207144513294](MySQL%E9%94%81.assets/image-20241207144513294.png)

session2中同样对id=5的数据进行查询

![image-20241207144632722](MySQL%E9%94%81.assets/image-20241207144632722.png)

如上，两个都查询出来了，但是如果将id换成8，那么session2就会查询不出来，因为加的锁不一样（如果id=8的话，sesion2照样可以在3-8的范围内插入记录，因为innodb默认使用的是临界锁，对于主键或唯一索引的查询，InnoDB 不会在查询结果附近加锁范围中的空隙）。如果id=8，session1查询的时候加上一个S锁，而session2加上一个X锁，那么就会被阻塞。但是此时id=5的数据是没有的，加的是一个区间范围为（3,8）的间隙锁，对于共享gao锁和独占gap是不区分的，即lock in share mode 和 for update其是是一样的。因此间隙锁是可以多个去加的。

当我们通过session3去（3,8）区间范围内新增一条记录的时候就会被间隙锁阻塞

![image-20241207145124754](MySQL%E9%94%81.assets/image-20241207145124754.png)

示例二：给student表中id值为20的记录之后加间隙锁

当我们还行如下命令后会给20到正无穷的记录加上间隙锁，即（20，+无穷）都无法插入记录

```
select * from student where id = 25 lock in share mode
```

但是插入id=17的记录还是可以正常执行的，因为该区间中没有间隙锁。

其实现是通过数据页中的两条伪记录实现爱你的：

- Infimum记录，表示该页面中最小的记录
- Supremum记录，表示该页面中最大的记录

![image-20241207145817075](MySQL%E9%94%81.assets/image-20241207145817075.png)



示例三：死锁问题

![image-20241207145910130](MySQL%E9%94%81.assets/image-20241207145910130.png)

![image-20241207150410609](MySQL%E9%94%81.assets/image-20241207150410609.png)



##### ③ 临键锁（Next-Key Locks）

 有时候我们既想 锁住某条记录 ，又想 阻止 其他事务在该记录前边的 间隙插入新记录，所以InnoDB就提出了一种称之为 Next-Key Locks的锁，官方的类型名称为: LOCK_ORDINARY，我们也可以简称为next-key锁。Next-KeyLocks是在存储引擎 innodb 、事务级别在 可重复读 的情况下使用的数据库锁，innodb默认的锁就是Next-Kevlocks（所以上面的记录锁和间隙锁可以演示出来）。比如，我们把id值为8的那条记录加一个next-key锁的示意图如下：

![image-20241207153719716](MySQL%E9%94%81.assets/image-20241207153719716.png)

next-key锁 的本质就是一个 记录锁 和一个 gap锁 的合体，它既能保护该条记录，，又能阻止别的事务将新记录插入被保护记录前边的 间隙。

```mysql
select * from student where id <= 8 and id > 3 for update;
```

即8是记录锁，（3,8）为间隙锁

示例一：

session1

![image-20241207154454720](MySQL%E9%94%81.assets/image-20241207154454720.png)

session2查询id=8的数据，并加X锁阻塞

![image-20241207154629045](MySQL%E9%94%81.assets/image-20241207154629045.png)

session2查询id=8的数据，并加S锁同样阻塞（因为session1加的是X锁）

![image-20241207154907414](MySQL%E9%94%81.assets/image-20241207154907414.png)

session2在（3,8）插入数据同样阻塞

![image-20241207155002172](MySQL%E9%94%81.assets/image-20241207155002172.png)



##### ④插入意向锁（Insert Intention Locks）

我们说一个事务在 插入 一条记录时需要判断一下插入位置是不是被别的事务加了 gap锁 (next-key锁 也包含gap锁)，如果有的话，插入操作需要等待，直到拥有 gap锁 的那个事务提交。但是InnoDB规定事务在等待的时候也需要在内存中生成一个锁结构，表明有事务想在某个 间隙 中插入新记录，但是现在在等待。InnoDB就把这种类型的锁命名为 Insert Intention Locks，官方的类型名称为: LOCK_INSERT_INTENTION，我们称为 插入意向锁 。插入意向锁是一种 Gap锁，不是意向锁，在insert操作时产生。
插入意向锁是在插入一条记录行前，由 INSERT 操作产生的一种间隙锁。该锁用以表示插入意向，当多个事务在同一区间(gap)插入位置不同的多条数据时，事务之间不需要互相等待。假设存在两条值分别为4和7的记录，两个不同的事务分别试图插入值为5和6的两条记录，每个事务在获取插入行上独占的(排他)锁前，都会获取(4，7)之间的间隙锁，但是因为数据行之间并 不冲突，所以两个事务之间并不会产生冲突(阻塞等待，即都是在等待间隙锁，如果都获得就可以执行)。总结来说，插入意向锁的特性可以分成两部分:

(1)插入意向锁是一种 特殊的间隙锁 -- 间隙锁可以锁定开区间内的部分记录。
(2)插入意向锁之间互不排斥，所以即使多个事务在同一区间插入多条记录，只要记录本身(主键、唯一索引)不冲突，那么事务之间就不会出现冲突等待。

注意，虽然插入意向锁中含有意向锁三个字，但是它并不属于意向锁而属于间隙锁，因为意向锁是表锁而插入意向锁是 行锁 。

比如，把id值为8的那条记录加一个插入意向锁的示意图如下

![image-20241207160914003](MySQL%E9%94%81.assets/image-20241207160914003.png)

比如，现在T1为id值为8的记录加了一个gap锁，然后T2和T3分别想向student表中插入id值分别为4、5的两条记录，所以现在为id值为8的记录加的锁的示意图就如下所示:

![image-20241207160923611](MySQL%E9%94%81.assets/image-20241207160923611.png)

从图中可以看到，由于T1持有gap锁，所以T2和T3需要生成一个插入意向锁的锁结构并且处于等待状态。当T1提交后会把它获取到的锁都释放掉，这样T2和T3就能获取到对应的插入意向锁了(本质上就是把插入意向锁对应锁结构的is_waiting属性改为false)，T2和T3之间也并不会相互阻塞，它们可以同时获取到id值为8的插入意向锁然后执行插入操作。事实上插入意向锁并不会阻止别的事务继续获取该记录上任何类型的锁



#### 4.页锁

页锁就是在 页的粒度 上进行锁定，锁定的数据资源比行锁要多，因为一个页中可以有多个行记录。当我们使用页锁的时候，会出现数据浪费的现象，但这样的浪费最多也就是一个页上的数据行。**页锁的开销介于表锁和行锁之间，会出现死锁。锁定粒度介于表锁和行锁之间，并发度一般。**

每个层级的锁数量是有限制的，因为锁会占用内存空间， 锁空间的大小是有限的 。当某个层级的锁数量超过了这个层级的阈值时，就会进行 锁升级 。锁升级就是用更大粒度的锁替代多个更小粒度的锁，比如InnoDB 中行锁升级为表锁，这样做的好处是占用的锁空间降低了，但同时数据的并发度也下降了。



### 3.4 从对待锁的态度划分：乐观锁、悲观锁

从对待锁的态度来看锁的话，可以将锁分成乐观锁和悲观锁，从名字中也可以看出这两种锁是两种看待数据并发的思维方式 。需要注意的是，乐观锁和悲观锁并不是锁，而是锁的 设计思想 。

#### 1.悲观锁（Pessimistic Locking）

##### 1.概念

悲观锁是一种思想，顾名思义，就是很悲观，对数据被其他事务的修改持保守态度，会通过数据库自身的锁机制来实现，从而保证数据操作的排它性。
悲观锁总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会 阻塞 直到它拿到锁(共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程)。比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁，当其他线程想要访问数据时都需要阻塞挂起。Java中 synchronized 和 ReentrantLock 等独占锁就是悲观锁思想的实现。

##### 2.示例

![image-20241208204707126](MySQL%E9%94%81.assets/image-20241208204707126.png)

![image-20241208204726088](MySQL%E9%94%81.assets/image-20241208204726088.png)

![image-20241208204823774](MySQL%E9%94%81.assets/image-20241208204823774.png)



#### 2.乐观锁（**Optimistic Locking**）

乐观锁认为对同一数据的并发操作不会总发生，属于小概率事件，不用每次都对数据上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，也就是不采用数据库自身的锁机制，而是通过程序来实现。在程放序上，我们可以采用 版本号机制 或者 CAS机制 实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量。Java中 java.util.concurrent.atomic 包下的原子变量类就是使用了乐观锁的一种实现方式:CAS实现的

##### 1.乐观锁的版本号机制

在表中设计一个 版本字段 version ，第一次读的时候，会获取 version 字段的取值。然后对数据进行更新或删除操作时，会执行UPDATE...SET version=version+1 WHERE version=version。此时如果已经有事务对这条数据进行了更改，修改就不会成功。
这种方式类似我们熟悉的 SVN、CV 版本管理系统，当我们修改了代码进行提交时，首先会检査当前版本号与服务器上的版本号是否一致，如果一致就可以直接提交，如果不一致就需要更新服务器上的最新代码，然后再进行提交。

##### 2.乐观锁的时间戳机制

时间戳和版本号机制一样，也是在更新提交的时候，将当前数据的时间戳和更新之前取得的时间戳进行比较，如果两者一致则更新成功，否则就是版本冲突。
你能看到乐观锁就是程序员自己控制数据并发操作的权限，基本是通过给数据行增加一个戳(版本号或者时间戳)，从而证明当前拿到的数据是否最新。

##### 3.示例

![image-20241208210611684](MySQL%E9%94%81.assets/image-20241208210611684.png)

![image-20241208210651232](MySQL%E9%94%81.assets/image-20241208210651232.png)

#### 3.两种锁适用场景

从这两种锁的设计思想中，我们总结一下乐观锁和悲观锁的适用场景:

- 乐观锁 适合 读操作多 的场景，相对来说写的操作比较少。它的优点在于 程序实现 ， 不存在死锁 问题，不过适用场景也会相对乐观，因为它阻止不了除了程序以外的数据库操作。
- 悲观锁 适合 写操作多 的场景，因为写的操作具有 排它性。采用悲观锁的方式，可以在数据库层面阻止其他事务对该数据的操作权限，防止读-写和写-写 的冲突。

![image-20241208210927894](MySQL%E9%94%81.assets/image-20241208210927894.png)

### 3.5 按加锁的方式划分：显示锁、隐式锁

#### 1. 隐式锁

一个事务在执行 INSERT 操作时，如果即将插入的 间隙 已经被其他事务加了 gap锁，那么本次 INSERT 操作会阻塞，并且当前事务会在该间隙上加一个插入意向锁 ，否则一般情况下 INSERT操作是不加锁的。那如果一个事务首先插入了一条记录(此时并没有在内存生产与该记录关联的锁结构)，然后另一个事务:

- 立即使用 SELECT ... LOCK IN SHARE MODE 语句读取这条记录，也就是要获取这条记录的 S锁，或者使用SELECT ... FOR UPDATE 语句读取这条记录，也就是要获取这条记录的 X锁，怎么办?

  如果允许这种情况的发生，那么可能产生 脏读 问题。

- 立即修改这条记录，也就是要获取这条记录的 X锁 ，怎么办?
  如果允许这种情况的发生，那么可能产生 脏写 问题。

这时候我们前边提过的 事务id 又要起作用了。我们把聚簇索引和二级索引中的记录分开看一下

- 聚簇索引

对于聚簇索引记录来说，有一个 trx_id 隐藏列，该隐藏列记录着最后改动该记录的 事务id。那么如果在当前事务中新插入一条聚簇索引记录后，该记录的 trx_id 隐藏列代表的就是当前事务的 事务id，如果其他事务此时想对该记录添加 S锁 或者 X锁 时，首先会看一下该记录的 trx_id 隐藏列代表的事务是否是当前的活跃事务，如果是的话，那么就帮助当前事务创建一个 X锁(也就是为当前事务创建一个锁结构，然后自己进入等待状态(也就是为自己也创建一个锁结构，is_waiting 属is_waiting属性是false),性是 true)。

- 二级索引

对于二级索引记录来说，本身并没有 trx_id 隐藏列，但是在二级索引页面的 Page Header 部分有-个PAGE_MAX_TRX_ID 属性，该属性代表对该页面做改动的最大的 事务id，如果PAGE_MAX_TRX_ID 属性值小于当前最小的活跃 事务id ，那么说明对该页面做修改的事务都已经提交了，否则就需要在页面中定位到对应的二级索引记录，然后回表找到它对应的聚簇索引记录，然后再重复 情景一的做法。



即一个事务对新插入的记录可以不显式的加锁(生成一个锁结构)，但是由于 事务id 的存在，相当于加了一个隐式锁。别的事务在对这条记录加 S锁 或者 X锁 时，由于 隐式锁 的存在，会先帮助当前事务生成一个锁结构,然后自己再生成一个锁结构后进入等待状态。隐式锁是一种 延迟加锁 的机制，从而来减少加锁的数量。
隐武锁在实际内存对象中并不含有这个锁信息。只有当产生锁等待时,隐式锁转化为显式锁。
InnoDB 的 insert 操作，对插入的记录不加锁，但是此时如果另一个线程进行当前读，类似以下的用例，session2会锁等待 session 1，那么这是如何实现的呢?

![image-20241208215453741](MySQL%E9%94%81.assets/image-20241208215453741.png)

![image-20241208215518440](MySQL%E9%94%81.assets/image-20241208215518440.png)



#### 2.显示锁

![image-20241208215604401](MySQL%E9%94%81.assets/image-20241208215604401.png)

### 3.6 其他锁之：全局锁

全局锁就是对 整个数据库实例 加锁。当你需要让整个库处于 只读状态 的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞:数据更新语句(数据的增删改)、数据定义语句(包括建表、修改表结构等)和更新类事务的提交语句。全局锁的典型使用 场景 是:做全库逻辑备份。粒度最粗。

全局锁的命令:

```
Flush tables with read lock
```



### 3.7 其他锁之：死锁

#### 1.概念

死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环。

#### 2. 示例

示例一：

![image-20241208220100697](MySQL%E9%94%81.assets/image-20241208220100697.png)

这时候，事务1在等待事务2释放id=2的行锁，而事务2在等待事务1释放id=1的行锁。 事务1和事务2在互相等待对方的资源释放，就是进入了死锁状态。

示例二：

![image-20241208220133927](MySQL%E9%94%81.assets/image-20241208220133927.png)



#### 3.产生死锁的必要条件

- 两个或者两个以上事务
- 每个事务都已经持有锁并且申请新的锁
- 锁资源同时只能被同一个事务持有或者不兼容
- 事务之间因为持有锁和中请锁导致彼此循环等待

死锁的关键在于:两个(或以上)的session加锁的顺序不一致



#### 4. 处理死锁

##### 方式1

等待，直到超时(innodb_lock_wait_timeout=pos)即当两个事务互相等待时，当一个事务等待时间超过设置的阈值时，就将其 回滚，另外事务继续进行。这种方法简单有效，在innodb中，参数innodb_lock_wait_timeout 用来设置超时时间。缺点:对于在线服务来说，这个等待时间往往是无法接受的。那将此值修改短一些，比如1s，0.1s是否合适?不合适，容易误伤到普通的锁等待

##### 方式2

使用死锁检测进行死锁处理
方式1检测死锁太过被动，innodb还提供了 wait-for graph算法 来主动进行死锁检测，每当加锁请求无法立即满足需要并进入等待时，wait-for graph算法都会被触发。
这是一种较为`主动的死锁检测机制，要求数据库保存 锁的信息链表 和 事务等待链表 两部分信息。

![image-20241208220730891](MySQL%E9%94%81.assets/image-20241208220730891.png)![image-20241208220739391](MySQL%E9%94%81.assets/image-20241208220739391.png)



![image-20241208220755454](MySQL%E9%94%81.assets/image-20241208220755454.png)

![image-20241208220936762](MySQL%E9%94%81.assets/image-20241208220936762.png)



#### 5.如何避免死锁

- 合理设计索引使业务 SQL尽可能通过索引定位更少的行，减少锁竞争。
- 调整业务逻辑 SQL 执行顺序，避免 update/delete 长时间持有锁的 SQL 在事务前面.
- 避免大事务，尽量将大事务拆成多个小事务来处理，小事务缩短锁定资源的时间，发生锁冲突的几率也更小
- 在并发比较高的系统中，不要显式加锁，特别是在事务里显式加锁。如 select ...for update 语句，如果是在事务里运行了 start transaction 或设置了autocommit 等于0，那么就会锁定所査找到的记录。
- 降低隔离级别。如果业务允许，将隔离级别调低也是较好的选择，比如将隔离级别从RR调整为RC，可以避免掉很多因为gap锁造成的死锁。



### 3.8 锁的内存结构

##### 1.引出

我们前边说对一条记录加锁的本质就是在内存中创建一个 锁结构 与之关联

```mysql
# 事务T1
SELECT * FROM USer LOCK IN SHARE MODE
```

那么上述语句在一个事务对多条记录加锁，创建多个 锁结构会出现很多的情况，所以决定在对不同记录加锁时，如果符合下边这些条件的记录会放到一个 锁结构 中

- 在同一个事务中进行加锁操作
- 被加锁的记录在同一个页面中
- 加锁的类型是一样的
- 等待状态是一样的

##### 2.锁结构

Innodb存储引擎中的锁结果如下所示：

![image-20241208231531289](MySQL%E9%94%81.assets/image-20241208231531289.png)

结构解析：

- 锁所在事务的信息

不论是 表锁 还是 行锁 ，都是在事务执行过程中生成的，哪个事务生成了这个 锁结构，这里就记录这个事务的信息。
此 锁所在的事务信息 在内存结构中只是一个指针，通过指针可以找到内存中关于该事务的更多信息（而不是把所有的信息都放在锁结构中），比方说事务id等。

- 索引信息

对于行锁来说，需要记录一下加锁的记录是属于哪个索引的。这里也是维护一个指针，而不是维护具体的数据信息。

- 表锁/行锁信息

表锁：记载着是对哪个表加的锁，还有其他的一些信息。

行锁：记载三个重要信息

1. Space Id:记录所在表空间
2. Page Number：记录所在页号
3. n_bits:对于行锁来说，一条记录就对应着一个比特位，一个页面中包含很多记录，用不同的比特位来。区分到底是哪一条记录加了锁。为此在行锁结构的未尾放置了一堆比特位，这个n_bits属性代表使用了多少比特位。n_bits的值一般都比页面中记录条数多一些。主要是为了之后在页面中插入了新记录后也不至于重新分配锁结构(其只是记录锁的个数，具体的加锁对象通过后面的一堆比特位来表示)

- type_mode

![image-20241209000508306](MySQL%E9%94%81.assets/image-20241209000508306.png)

![image-20241209000526448](MySQL%E9%94%81.assets/image-20241209000526448.png)

![image-20241209000542125](MySQL%E9%94%81.assets/image-20241209000542125.png)

（7、8位没有使用）

![image-20241209000610178](MySQL%E9%94%81.assets/image-20241209000610178.png)

![image-20241209000639948](MySQL%E9%94%81.assets/image-20241209000639948.png)

- 其他信息

为了更好的管理系统运行过程中生成的各种锁结构而设计了各种哈希表和链表。

- 一堆比特位

如果是 行锁结构 的话，在该结构末尾还放置了一堆比特位，比特位的数量是由上边提到的n_bits 属性表示的,。InnoDB数据页中的每条记录在 记录头信息中都包含一个heap_no属性，伪记录 Infimum的 heap_no 值为8，Supremum 的 heap_no 值为1，之后每插入一条记录，heap_no 值就增1。锁结构最后的一堆比特位就对应着-个页面中的记录，一个比特位映射一个heap_no，即一个比特位映射到页内的一条记录。







## 四、锁监控









## 四、问题汇总

#### 3.1 select * from student where id = 8 和 select * from student where id = 8 lock in share mode 和 select * from student where id = 8 for update的区别

在 MySQL 中，`SELECT` 查询语句中的 `LOCK IN SHARE MODE` 和 `FOR UPDATE` 是用来控制对数据库表中数据的锁定行为的，尤其是在事务处理中。它们的主要区别在于锁定的粒度和目的。下面详细说明这三种查询的区别。

1. `SELECT * FROM student WHERE id = 8`

这个查询是最基本的 `SELECT` 查询，作用是查询 `student` 表中 `id` 为 8 的所有字段。它没有对数据进行任何锁定或特殊的事务控制。因此：

- **无锁定**：执行此查询时，MySQL 会返回符合条件的记录，但不会对这些记录加锁。其他事务可以同时对这些记录进行修改或删除，可能会导致数据一致性问题，尤其在并发环境下。
- **适用场景**：通常用于读取数据且不需要对数据进行更新或防止其他事务修改数据的场景。

2. `SELECT * FROM student WHERE id = 8 LOCK IN SHARE MODE`

此查询在 `SELECT` 查询基础上增加了 `LOCK IN SHARE MODE`，这意味着：

- **共享锁**：该查询会为符合条件的行（这里是 `id = 8` 的记录）添加一个共享锁。共享锁的作用是允许其他事务读取该记录，但不允许其他事务修改或删除该记录，直到当前事务提交。

- **适用场景**：当你只需要读取数据，并且想要确保在你读取数据的过程中其他事务不会修改这些数据，但允许其他事务也读取这些记录时使用。例如，在多个事务同时读取数据时，`LOCK IN SHARE MODE` 允许并发读取，但阻止并发写入。

  具体来说：

  - 其他事务可以执行 `SELECT` 查询并获取共享锁，但不能执行 `UPDATE` 或 `DELETE`，除非它们也使用 `LOCK IN SHARE MODE`。
  - 只有当前事务可以修改或删除该记录。

- **事务的行为**：使用 `LOCK IN SHARE MODE` 查询时，记录会被锁定在当前事务中，直到该事务提交。

3. `SELECT * FROM student WHERE id = 8 FOR UPDATE`

此查询在 `SELECT` 查询基础上增加了 `FOR UPDATE`，意味着：

- **排他锁**：该查询会对符合条件的记录（这里是 `id = 8` 的记录）添加排他锁（也叫独占锁）。排他锁会阻止其他事务对这些记录进行任何类型的访问，包括读取（除非也在事务中），修改或删除。只有当前事务可以修改该记录。

- **适用场景**：适用于需要对读取的数据进行修改的场景，尤其是在事务内进行数据更新时使用。例如，你想要读取数据并对其进行修改，但在你修改数据之前，你不希望其他事务修改或读取这些记录。

  具体来说：

  - 其他事务不能修改、删除或读取已经加锁的记录，直到当前事务提交。
  - 当前事务可以修改这些记录，因为排他锁会将记录独占。

- **事务的行为**：使用 `FOR UPDATE` 查询时，当前事务会锁住记录，其他事务只能等待，直到当前事务提交。

总结：

| 查询语句                                                | 锁类型         | 允许其他事务执行的操作                                     | 适用场景                                     |
| ------------------------------------------------------- | -------------- | ---------------------------------------------------------- | -------------------------------------------- |
| `SELECT * FROM student WHERE id = 8`                    | 无锁定         | 其他事务可以读取、修改或删除该记录。                       | 不需要锁定，只进行读取，且没有修改需求。     |
| `SELECT * FROM student WHERE id = 8 LOCK IN SHARE MODE` | 共享锁（读锁） | 其他事务可以读取，但不能修改或删除该记录。                 | 需要读取数据并防止修改，允许其他事务读取。   |
| `SELECT * FROM student WHERE id = 8 FOR UPDATE`         | 排他锁（写锁） | 其他事务不能读取、修改或删除该记录，只有当前事务可以修改。 | 需要读取并修改数据，防止其他事务读取或修改。 |

总结说明：

- **`LOCK IN SHARE MODE`**：适用于读取数据且希望防止其他事务修改数据的场景，但允许其他事务也读取数据。
- **`FOR UPDATE`**：适用于需要读取并修改数据的场景，锁定记录并阻止其他事务对这些记录进行任何操作，直到当前事务完成。

希望这些解释能帮助你更好地理解这三种 SQL 查询之间的区别！



#### 3.2 mysql中innodb默认使用的是临界锁，现在有一个表，里面有id=8的数据，我执行select * from student where id = 8 for update，会在8的前面加间隙锁吗

1. **如果 `id` 是主键或唯一索引**：
   - **不会加间隙锁**。当你执行 `SELECT ... FOR UPDATE` 查询时，InnoDB 会为符合条件的行加 **排他锁**（Exclusive Lock）。在这种情况下，`id = 8` 的行会被加上排他锁，其他事务不能修改或删除该行，但 **不会加间隙锁**。这是因为主键或唯一索引的查询通常可以直接定位到一行数据，InnoDB 不需要使用间隙锁。
2. **如果 `id` 不是主键或唯一索引**，而是一个普通的非唯一字段：
   - **可能加间隙锁**。如果查询条件 `WHERE id = 8` 是通过普通索引来查询的，InnoDB 可能会在该索引范围内加上间隙锁。例如，如果 `id` 是非唯一索引，InnoDB 可能会加锁 `id` 等于 8 的位置以及该位置的前后“间隙”，从而阻止其他事务插入相同的 `id` 或相邻的值。

为了理解是否会加间隙锁，首先需要明确两点：

- **查询的索引类型**：如果使用的是唯一索引，InnoDB 通常会直接加锁行数据，不会加间隙锁。
- **数据的存在性**：间隙锁通常用于防止插入冲突，尤其是在没有明确锁定单行数据时。对于主键或唯一索引的查询，InnoDB 不会在查询结果附近加锁范围中的空隙。

总结：

- 如果 `id` 是 **主键** 或 **唯一索引**，则 `SELECT ... FOR UPDATE` 查询 **不会** 在记录前面加间隙锁。
- 如果 `id` 是 **非唯一索引**，InnoDB 有可能会在 `id = 8` 的数据行的前后加上间隙锁，尤其是当查询条件涉及多个记录范围时。

通过理解这些机制，你可以控制 MySQL 锁的行为，确保在并发环境中数据的一致性和隔离性。如果你对锁的行为有进一步的疑问，或者在其他场景下有锁定需求，可以进一步讨论。



如果 `id` 是 **非唯一索引**的间隙锁添加示例：

初始化表：

```
CREATE TABLE student2 (
    id INT,
    name VARCHAR(50),
    class VARCHAR(50),
    INDEX idx_id (id) -- 创建一个非唯一索引
);


INSERT INTO student2 (id, name, class) VALUES
(1, '张三', '一班'),
(8, '李四', '二班'),
(8, '王五', '三班'),
(50, '赵六', '四班');
```

session1

![image-20241207161948457](MySQL%E9%94%81.assets/image-20241207161948457.png)

session2在1到8中间插入数据阻塞

![image-20241207162128890](MySQL%E9%94%81.assets/image-20241207162128890.png)

session2在8到50中间插入数据阻塞

![image-20241207162209430](MySQL%E9%94%81.assets/image-20241207162209430.png)

即表示当你查询的字段是 **非唯一索引** 字段时，InnoDB 可能会在查询范围内加 **间隙锁**，即上述在8两侧加间隙锁。

锁定行为：

- **由于 `id` 不是主键，也不是唯一索引**，这个查询将会扫描整个索引 `idx_id`，查找 `id = 8` 的记录。
- **间隙锁** 将在索引 `id = 8` 和 `id = 9` 之间的“空隙”上加锁。也就是说，InnoDB 会锁定从 `id = 8` 到 `id = 50 的“间隙”区域以及id=1到id=8的间隙区域。

锁定范围：

- **行级锁**：InnoDB 会对 `id = 8` 的所有记录加 **排他锁**（因为我们用了 `FOR UPDATE`），这意味着其他事务不能修改或删除这些记录。
- **间隙锁**：InnoDB 会在 `id = 8` 和 `id = 9` 之间以及id=1到id=8的之间加 **间隙锁**，防止其他事务在这个范围内插入记录。



如果id是唯一主键的间隙锁添加示例：

session1

![image-20241207162528075](MySQL%E9%94%81.assets/image-20241207162528075.png)

session2在大于8的间隙中插入数据，其没有间隙锁

![image-20241207162601635](MySQL%E9%94%81.assets/image-20241207162601635.png)

session2在小于8的间隙插入数据，其没有间隙锁

![image-20241207162636443](MySQL%E9%94%81.assets/image-20241207162636443.png)







#### 3.3 其他

问题：

- mysql中如下方式查询不到？

```
-- 1. 开始一个会话，确保没有未提交的事务
LOCK TABLES test WRITE;

-- 2. 查询数据
SELECT * FROM test;  -- 这里应该能返回数据

-- 3. 解锁
UNLOCK TABLES;
```

1.查询 √

通过命令`select * from test`查看表的信息

![image-20241016233018532](MySQL%E9%94%81.assets/image-20241016233018532.png)

2.更新、删除 ×

通过命令`update test set name = 'ww'`更新表信息

![image-20241016233125660](MySQL%E9%94%81.assets/image-20241016233125660.png)

通过命令`unlock tables;`解锁表的锁



- 通过命令`lock tables test write`给test表上表级别的X锁

通过命令`show open tables where in_use > 0;`查看上锁的表

![image-20241016232449234](MySQL%E9%94%81.assets/image-20241016232449234.png)

1.查询 ×

通过命令`select * from test`查看表的信息

无法查询到表中的数据



2.更新、删除 ×

通过命令`update test set name = 'ww'`更新表信息

![image-20241016233125660](MySQL%E9%94%81.assets/image-20241016233125660.png)

无法更新表中的数据

通过命令`unlock tables;`解锁表的锁











问题1：各个隔离级别下的实现，RR是通过临界锁（解决幻读） + MVCC来实现



#### 资料：

> https://blog.csdn.net/qq_45732909/article/details/140978690?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522a1c433e8c86d7a906ce6680587a8fa71%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=a1c433e8c86d7a906ce6680587a8fa71&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-2-140978690-null-null.142^v100^pc_search_result_base6&utm_term=Mysql%E5%9C%A8RR%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8B%E4%BD%BF%E7%94%A8%E7%9A%84%E9%94%81&spm=1018.2226.3001.4187
