# MySQL锁

## 一、前言

### 1.1 说明

锁是计算机协调多个进程或线程”并发访问某一资源 的机制。在程序开发中会存在多线程同步的问题，当多个线程并发访问某个数据的时候，尤其是针对一些敏感的数据(比如订单、金额等)，我们就需要保证这个数据在任何时刻最多只有一个线程在访问，保证数据的完整性和一致性。在开发过程中加锁是为了保证数据的一致性，这个思想在数据库领域中同样很重要。

在数据库中，除传统的计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供许多用户共享的资源。为保证数据的一致性，需要对 并发操作进行控制 ，因此产生了 锁 。同时 锁机制 也为实现MySQL的各个隔离级别提供了保证。 锁冲突 也是影响数据库 并发访问性能 的一个重要因素。所以锁对数据库而言显得尤其重要，也更加复杂。

MySQL中事务的隔离性就是由锁来实现的。

### 1.2 解决并发问题方案(针对读和写/写和读)

怎么解决脏读 、 不可重复读 、 幻读这些问题有两种可选的解决方案:

方案一：读操作利用多版本并发控制(MVCC)，写操作进行加锁

所谓的 MVCC，就是生成一个Readview，通过Readview找到符合条件的记录版本(历史版本由undo日志构建)。查询语句只能读 到在生成ReadView之前已提交事务所做的更改，在生成ReadView之前未提交的事务或者之后才开启的事务所做的更改是看不到的。而写操作 肯定针对的是最新版本的记录 ，读记录的历史版本和改动记录的最新版本本身并不冲突，也就是采用MVCC时，读-写操作并不冲突。

> 普通的SELECT语句在READCOMMITTED和REPEATABLEREAD隔离级别下会使用到MVCC读取记录。
>
> - 在READ COMMITTED隔离级别下，一个事务在执行过程中每次执行SELECT操作时都会生成一个ReadView，ReadView的存在本身就保证了事务不可以读取到未提交的事务所做的更改，也就是避免了脏读现象;
> - 在 REPEATABLE READ隔离级别下，一个事务在执行过程中只有第一次执行SELECT操作 才会生成一个ReadView，之后的SELECT操作都 复用 这个ReadView，这样也就避免了不可重复读和幻读的问题。

方案二：读、写操作都采用 加锁 的方式

如果我们的一些业务场景不允许读取记录的旧版本，而是每次都必须去 读取记录的最新版本。比如，在银行存款的事务中，你需要先把账户的余额读出来，然后将其加上本次存款的数额，最后再写到数据库中。在将账户余额读取出来后，就不想让别的事务再访问该余额，直到本次存款事务执行完成，其他事务才可以访问账户的余额。这样在读取记录的时候就需要对其进行 加锁 操作，这样也就意味着 读 操作和 写 操作也像 写-写 操作那样需要排队执行。
**脏读** 的产生是因为当前事务读取了另一个未提交事务写的一条记录，如果另一个事务在写记录的时候就给这条记录加锁，那么当前事务就无法继续读取该记录了，所以也就不会有脏读问题的产生了。
**不可重复读** 的产生是因为当前事务先读取一条记录，另外一个事务对该记录做了改动之后并提交之后，当前事务再次读取时会获得不同的值，如果在当前事务读取记录时就给该记录加锁，那么另一个事务就无法修改该记录，自然也不会发生不可重复读了。
**幻读** 问题的产生是因为当前事务读取了一个范围的记录，然后另外的事务向该范围内插入了新记录，当前事务再次读取该范围的记录时发现了新插入的新记录。采用加锁的方式解决幻读问题就有一些麻烦，因为当前事务在第一次读取记录时幻影记录并不存在，所以读取的时候加锁就有点尴尬(后续有间隙锁来实现)。

小结:

- 采用 MVCC 方式的话，读-写操作彼此并不冲突，性能更高。
- 采用 加锁 方式的话，读-写操作彼此需要 排队执行，影响性能。

般情况下我们当然愿意采用 MVCC 来解决读-写操作并发执行的问题，但是业务在某些特殊情况下，要求必须采用加锁的方式执行。



## 二、并发事务访问情况

并发事务访问可以分为三种情况：

### 2.1 先读后读

读-读情况，即并发事务相继读取相同的记录 。读取操作本身不会对记录有任何影响，并不会引起什么问题，所以允许这种情况的发生。

### 2.2 先写后写

写-写 情况，即并发事务相继对相同的记录做出改动。

在这种情况下会发生脏写的问题(有一条记录如1，A和B此时都读取到的记录为1，A对该记录进行修改为2并提交，此时B对该记录修改为3后回滚，对于A来说最终结果还是1，出现了脏写)，任何一种隔离级别都不允许这种问题的发生。所以在多个未提交事务相继对一条记录做改动时，需要让它们 排队执行 ，这个排队的过程其实是通过 锁 来实现的。这个所谓的锁其实是一个 内存中的结构 ，在事务执行前本来是没有锁的，也就是说一开始是没有 锁结构 和记录进行关联的，如图所示：

![image-20241203214516807](MySQL%E9%94%81.assets/image-20241203214516807.png)

当一个事务想对这条记录做改动时，首先会看看内存中有没有与这条记录关联的 锁结构 ，当没有的时候就会在内存中生成一个 锁结构 与之关联。比如，事务 T1 要对这条记录做改动，就需要生成一个 锁结构与之关联(如果有两个事物，就会有两个索结构，其是和事物相关的)：

![image-20241203214659978](MySQL%E9%94%81.assets/image-20241203214659978.png)

在锁结构里有很多信息，为了简化理解，只把两个比较重要的属性拿了出来:

- trx信息：代表这个锁结构是哪个事物生成的
- is_waiting:代表当前事务是否在等待

当事务 T1改动了这条记录后，就生成了一个 锁结构 与该记录关联，因为之前没有别的事务为这条记录加锁，所以 is_waiting属性就是 false，我们把这个场景就称之为 获取锁成功，或者加锁成功 ，然后就可以继续执行操作了。

在事务 T1提交之前，另一个事务 T2 也想对该记录做改动，那么先看看有没有 锁结构 与这条记录关联，发现有一个 锁结构 与之关联后，然后也生成了一个锁结构与这条记录关联，不过锁结构的is_waiting属性值为 true，表示当前事务需要等待，我们把这个场景就称之为 获取锁失败 ，或者加锁失败，图示:

![image-20241203215208597](MySQL%E9%94%81.assets/image-20241203215208597.png)

在事务T1提交之后，就会把该事务生成的 锁结构释放 掉，然后看看还有没有别的事务在等待获取锁，发现了事务T2还在等待获取锁，所以把事务T2对应的锁结构的 is_waiting 属性设置为 false，然后把该事务对应的线程唤醒，让它继续执行，此时事务T2就算获取到锁了。效果图就是这样:

![image-20241203215254499](MySQL%E9%94%81.assets/image-20241203215254499.png)

说明：

（1）不加锁

不需要在内存中生成对应的 锁结构，可以直接执行操作。

（2）获取锁成功，或者加锁成功

在内存中生成了对应的 锁结构，而且锁结构的 is_waiting 属性为 false，也就是事务可以继续执行操作。

（3）获取锁失败，或者加锁失败，或者没有获取到锁

在内存中生成了对应的 锁结构 ，不过锁结构的 is_waiting属性为 true，也就是事务需要等待，不可以继续执行操作。

### 2.3 先读后写/先写后读

读-写或写-读 ，即一个事务进行读取操作，另一个进行改动操作。这种情况下可能发生 脏读 、不可重复读、幻读的问题。

各个数据库厂商对 SQL标准 的支持都可能不一样。比如MySQL在 REPEATABLE READ 隔离级别上就已经解决了幻读 问题。



## 三、锁的分类

### 3.1 分类

**1. 根据数据操作类型划分**

- 读锁/共享锁
- 写锁/排他锁

**2. 根据锁粒度角度划分**

> 对一条记录加锁影响的是这条记录，该锁的粒度比较细;一个事务也可以在表级别进行加锁，称为表级锁或者表锁，对一个表加锁影响整个表中的记录，这个锁的粒度比较粗。锁的粒度主要可以分为表级锁、页级锁和行锁。

- 表级锁（table lock）
  - 表级别的S锁（共享锁）、X锁（排他锁）
  - 意向锁（intention lock）
  - 自增锁（AUTO-INC锁）
  - 元数据锁（MDL锁）
- 行级锁
  - 记录锁（Record Locks）
  - 间隙锁（Gap Locks）
  - 临键锁（Next-Key Locks）
  - 插入意向锁（Insert Intention Locks）
- 页级锁

**3. 对待锁的态度划分**

- 悲观锁（Pessimistic Locking）
- 乐观锁（Optimistic Locking）

**4. 加锁方式**

- 隐式锁
- 显示锁

**5. 其他**

- 全局锁
- 死锁



### 3.2 数据操作类型：读锁/共享锁、写锁/排他锁

对于数据库中并发事务的 读-读 情况并不会引起什么问题。对于 写-写、 读-写 或 写-读 这些情况可能会引起一些问题，需要使用 MVCC 或者加锁 的方式来解决它们。在使用 加锁 的方式解决问题时，由于既要允许 读-读 情况不受影响，又要使写-写、 读-写 或 写-读 情况中的操作 相互阻塞，所以MySQL实现一个由两种类型的锁组成的锁系统来解决。这两种类型的锁通常被称为 共享锁(Shared Lock，S Lock)和 排他锁(Exclusive Lock，X Lock)也叫读锁(readlock)和写锁(write lock)。

- 读锁:也称为 共享锁、英文用s表示。针对同一份数据，多个事务的读操作可以同时进行而不会互相影响相互不阻塞的。
- 写锁: 也称为 排他锁 、英文用x表示。当前写操作没有完成前，它会阻断其他写锁和读锁。这样就能确保在给定的时间里，只有一个事务能执行写入，并防止其他用户读取正在写入的同一资源。

需要注意的是对于 InnoDB 引擎来说，读锁和写锁可以加在表上，也可以加在行上。

举例(行级读写锁):如果一个事务 T1已经获得了某个行r的读锁，那么此时另外的一个事务 T2 是可以去获得这个行r的读锁的，因为读取操作并没有改变行r的数据;但是，如果某个事务 T3 想获得行r的写锁，则它必须等待事务 T1、T2 释放掉行r上的读锁才行。

总结:这里的兼容是指对同一张表或记录的锁的兼容性情况。

|      | X锁    | S锁    |
| ---- | ------ | ------ |
| X锁  | 不兼容 | 不兼容 |
| S锁  | 不兼容 | 兼容   |

#### 1.锁定读

在采用 加锁 方式解决 脏读 、 不可重复读 、 幻读 这些问题时，读取一条记录时需要获取该记录的 S锁，其实是不严谨的，有时候需要在读取记录时就获取记录的 X锁 （对于读也可以加上一个排他的行为，对于写锁明确是排他的，但对于读锁既可以是共享的 也可以是排他的），来禁止别的事务读写该记录，为此MySQL提出了两种比较特殊的 SELECT 语句格式:

- 对读取的记录加 S锁:

```mysql
SELECT ... LOCK IN SHARE MODE;
#或
SELECT ...FOR SHARE;#(8.0新增语法)
```

在普通的SELECT语句后边加LOCK IN SHARE MODE，如果当前事务执行了该语句，那么它会为读取到的记录加 S锁 ，这样允许别的事务继续获取这些记录的 S锁(比方说别的事务也使用 SELECT... LOCK IN SHAREMODE 语句来读取这些记录)，但是不能获取这些记录的X锁(比如使用 SELECT..· FOR UPDATE 语句来读取这些记录，或者直接修改这些记录)。如果别的事务想要获取这些记录的X锁，那么它们会阻塞，直到当前事务提交之后将这些记录上的 S锁 释放掉。

示例一：读读

```mysql
-- 客户端一（session1）：
begin;
select * from table lock in share mode; -- 获取S锁，可以查询到数据

-- 客户端二（session2）
begin;
select * from table lock in share mode; -- 获取S锁，可以查询到数据
```



- 对读取的记录加 X锁：

```mysql
SELECT ... FOR UPDATE;
```

在普通的SELECT语句后边加FOR UPDATE，如果当前事务执行了该语句，那么它会为读取到的记录加X锁，这样既不允许别的事务获取这些记录的 S锁(比方说别的事务使用 SELECT...LOCK IN SHARE MODE语句来读取这些记录)，也不允许获取这些记录的X锁(比如使用 SELECT ...FOR UPDATE 语句来读取这些记录，或者直接修改这些记录)。如果别的事务想要获取这些记录的S锁 或者 X锁 ，那么它们会阻塞，直到当前事务提交之后将这些记录上的 X锁 释放掉。

示例一：先读后写

```mysql
-- 客户端一（session1）：
begin;
select * from table lock in share mode; -- 获取S锁，可以查询到数据

-- 客户端二（session2）
begin;
select * from table lock in share mode; -- 获取S锁，可以查询到数据

-- 客户端三（session3）
begin;
select * from table for update; -- 获取X锁失败，无法对数据进行修改（只有当客户端一、二都commit后才可以成功查询出对应的数据）
```

示例二：先写后读

```mysql
-- 客户端一（session1）
begin;
select * from table for update; -- 获取X锁，可以修改

-- 客户端二（session2）
begin;
select * from table lock in share mode; -- 获取S锁失败，阻塞
```

示例三：先写后写

```mysql
-- 客户端一（session1）
begin;
select * from table for update; -- 获取X锁，可以修改

-- 客户端二（session2）
begin;
select * from table for update; -- 获取X锁失败，阻塞
```



不同版本对于获取不到锁的处理：

- 在5.7及之前的版本，SELECT... FOR UPDATE，如果获取不到锁，会一直等待，直到innodb_lock_wait_timeout 超时。

- 在8.0版本中，SELECT ... FOR UPDATE, SELECT ... FOR SHARE 添加NOWAIT、 SKIP LOCKED 语法，跳过锁等待，或者跳过锁定，通过添加NOWAIT、SKIP LOCKED语法，能够立即返回。如果查询的行已经加锁：

  - 那么NOWAIT会立即报错返回
  - 而SKIP LOCKED也会立即返回，只是返回的结果中不包含被锁定的行。

  示例：锁定所有行

  ```mysql
  -- 客户端一（session1）
  select * from account for update
  ```

  客户端二执行情况

  ![image-20241204232100395](MySQL%E9%94%81.assets/image-20241204232100395.png)



#### 2.写操作

对于读操作可以加排他锁和共享锁，但是对于写错做一定要加排他锁。

平常所用到的 写操作 无非是 DELETE、UPDATE、INSERT 这三种（对于DELETE、UPDATE会加排他锁即X锁，Insert在添加之前没有这条记录，所以无法加X锁，通过隐式锁去保证事务无法访问未提交的insert数据）：

- DELETE

对一条记录做DELETE操作的过程其实是先在 B+ 树中定位到这条记录的位置，然后获取这条记录的 X锁，再执行 delete mark 操作。我们也可以把这个定位待删除记录在B+树中位置的过程看成是一个获取 X锁 的 锁定读。

- UPDATE

在对一条记录做UPDATE操作时分为三种情况:

情况1:未修改该记录的键值，并且被更新的列占用的存储空间在修改前后未发生变化。则先在 B+ 树中定位到这条记录的位置，然后再获取一下记录的 X锁 ，最后在原记录的位置进行修改操作。我们也可以把这个定位待修改记录在 B+树中位置的过程看成是一个获取 X锁的 锁定读 。

情况2:未修改该记录的键值，并且至少有一个被更新的列占用的存储空间在修改前后发生变化。则先在 B+ 树中定位到这条记录的位置，然后获取一下记录的 X锁，将该记录彻底删除掉(就是把记录彻底移入垃圾链表)，最后再插入一条新记录。这个定位待修改记录在 B+ 树中位置的过程看成是一个获取X锁 的 锁定读 ，新插入的记录由 INSERT 操作提供的 隐式锁 进行保护，避免在没提交之前，被其他事务看到。（两个执行过程）

情况3:修改了该记录的键值，则相当于在原记录上做 DELETE 操作之后再来一次 INSERT操作，加锁操作就需要按照 DELETE 和 INSERT 的规则进行了（加锁过程如情况2一样）。

- INSERT

一般情况下，新插入一条记录的操作并不加锁，通过一种称之为 隐式锁 的结构来保护这条新插入的记录在本事务提交前不被别的事务访问。（其不用加锁的原因是，insert前都没有这个数据，不用担心被其他事务访问到，出现并发查询、修改的操作，因此不用加X锁，通过隐式锁去保证不被其他事务访问到）





### 3.3 锁粒度角度划分：表级锁、行级锁、页级锁

#### 1. 锁粒度的概念

为了尽可能提高数据库的并发度，每次锁定的数据范围越小越好，理论上每次只锁定当前操作的数据的方案会得到最大的并发度，但是管理锁是很`耗资源`的事情（涉及获取、检查、释放锁等动作)(越小消耗越大)。因此数据库系统需要在`高并响应`和`系统性能`两方面进行平衡。

#### 2. 表锁（table lock）

表锁会锁定整张表，是MySQL中最基本的锁策略，并不依赖于存储引擎(不管你是MySQL的什么存储引擎，
对于表锁的策略都是一样的)。表锁是`开销最小`的策略（因为粒度比较大)。由于表级锁一次会将整个表锁定，所以可以很好的避免死锁问题。当然，锁的粒度大所带来最大的负面影响就是出现锁资源争用的概率也会最高，导致并发率大打折扣。因此，表锁的特点就是开销小（不需要频繁加、放锁），但是并发能力差。

##### ①表级别的S锁、X锁（MYISAM）

表锁又可以分为共享锁（S锁）和排他锁（X锁），在系统变量`autocommit=0（InnoDB 会关闭自动提交模式），innodb_table_locks = 1（1为默认值，InnoDB 会使用表级锁。这意味着在对一个表进行操作时，整个表会被锁定，直到操作完成）`时，手动获取InnoDB存储引擎提供 的S锁或者X锁：

- InnoDB存储引擎加表级别的S锁

  ```mysql
  LOCK TABLES t READ
  ```

- InnoDB存储引擎加表级别的X锁

  ```mysql
  LOCK TABLES t WRITE
  ```

- 解锁命令（使用此命令解锁加锁的表）

  ```mysql
  unlock tables
  ```

对某个表执行SELECT、INSERT、DELETE、UPDATE语句（DML，数据操作语言）时，InnoDB存储引擎是不会为这个表添加表级别的`S锁`或者`X锁`的。在对某个表执行一些诸如`ALTER TABLE`、`DROP TABLE`这类的`DDL`语句时，其他事务对这个表并发执行诸如SELECT、INSERT、DELETE、UPDATE的语句会发生阻塞。同理，某个事务中对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，在其他会话中对这个表执行`DDL`语句也会发生阻塞。这个过程其实是通过在server层使用一种称之为`元数据锁`（英文名：`Metadata Locks`，简称`MDL`）结构来实现的。一般情况下，不会使用InnoDB存储引擎提供的`表级别`的`S锁`和`X锁`。只会在一些特殊情况下，比方说`崩溃恢复`过程中用到。

注意：不过尽量避免在使用InnoDB存储引擎的表上使用`LOCK TABLES`这样的手动锁表语句，它们并不会提供什么额外的保护，只是会降低并发能力而已。InnoDB的厉害之处还是实现了更细粒度的行锁，



要使用表级锁，我们先要关闭自动提交以及设置InnoDB使用表级锁

```mysql
-- 查看当前自动提交状态（默认为ON开启）
show variables like '%autocommit%';

-- SET autocommit = 0; 等价
SET @@autocommit = 0;
```

```mysql
-- 查看当前使用表级锁（默认为ON开启）
show variables like '%innodb_table_locks%';
-- 设置当前使用表级锁为ON（会话状态即可，不用全局）
SET innodb_table_locks = 1;
```

我们可以通过`show open tables`去查看所有表的状态，其列信息如下：

- **Database**: 表所在的数据库名。
- **Table**: 表的名称。
- **In_use**: 表的使用状态（通常是 0 或 1）。`1` 表示该表当前被某个连接使用，`0` 表示没有连接在使用该表。
- **Name_locked**: 表示该表是否被锁定，通常是 0 或 1。`1` 表示该表被锁定，`0` 表示未锁定。

```
+----------+--------------------+--------+-------------+
| Database | Table              | In_use | Name_locked |
+----------+--------------------+--------+-------------+
| mydb     | my_table           |      1 |           0 |
| mydb     | another_table      |      0 |           0 |
+----------+--------------------+--------+-------------+
```

- 通过命令`lock tables test read`给test表上表级别的S锁

通过命令`show open tables where in_use > 0;`查看上锁的表



**关于表级别所的使用示例（以MyISAM为例）：**

- 示例一（读锁）

```mysql
-- 客户端一（session1）给mytable上读表锁
lock tables mytable read

-- 客户端一（session1）查询当前表
select * from mytable   -- 可以查询出相关数据（自己可读）

-- 客户端一（session1）写当前表
update mytable set xxx = '123'  -- 不可修改/写数据（自己不可写）


-- 客户端一（session1）查询其他表
select * from mytable2  -- 不可访问操作其他表

-- 客户端二（session2）查询加锁表
select * from mytable   -- 可以查询出相关数据（他人可读）

-- 客户端二（session2）写加锁表
update mytable set xxx = '123'  -- 不可修改/写数据（他人不可写）

-- 当我们释放锁后上述不可的操作即可进行
unlock tables


```

- 示例二（写锁）

```mysql
-- 客户端一（session1）给mytable上写表锁
lock tables mytable write

-- 客户端一（session1）查询当前表
select * from mytable   -- 可以查询出相关数据（自己可读）

-- 客户端一（session1）写当前表
update mytable set xxx = '123'  -- 可修改/写数据（自己可写）

-- 客户端一（session1）查询其他表
select * from mytable2  -- 不可访问操作其他表

-- 客户端二（session2）查询加锁表
select * from mytable   -- 不可以查询出相关数据（他人不可读）

-- 客户端二（session2）写加锁表
update mytable set xxx = '123'  -- 不可修改/写数据（他人不可写）

-- 当我们释放锁后上述不可的操作即可进行
unlock tables

```



综上总结：

MyISAM在执行查询语句（SELECT）前，会给涉及的所有表加读锁，在执行增删改操作前，会给涉及的表加写锁。InnoDB存储引擎是不会为这个表添加表级别的`读锁`或者`写锁`的。（有行锁，谁TM用表锁啊）

MySQL的表级锁有两种模式：（以MyISAM表进行操作的演示）

- 表共享读锁（Table Read Lock）
- 表独占写锁（Table Write Lock）

| 锁类型 | 自己可读 | 自己可写 | 自己可操作其他表 | 他人可读 | 他人可写 |
| ------ | -------- | -------- | ---------------- | -------- | -------- |
| 读锁   | 是       | 否       | 否               | 是       | 否，等   |
| 写锁   | 是       | 是       | 否               | 否，等   | 否，等   |





##### ②意向锁（intention lock，MYISAM、Innodb都有）

InnoDB 支持 多粒度锁（multiple granularity locking） ，它允许 行级锁 与 表级锁 共存，而意向锁就是其中的一种 表锁 。

1. 意向锁的存在是为了协调行锁和表锁的关系，支持多粒度(表锁与行锁)的锁并存
2. 意向锁是一种 不与行级锁冲突表级锁 ，这一点非常重要（否则innoDB也退回成表级别的锁）
3. 表明“某个事务正在某些行持有了锁或该事务准备去持有锁”

意向锁分为两种：

- **意向共享锁**（intention shared lock, IS）：事务有意向对表中的某些行加**共享锁**（S锁），顺便会加上意向共享锁

```
-- 事务要获取某些行的 S 锁，必须先获得表的 IS 锁。
SELECT column FROM table ... LOCK IN SHARE MODE;
```

- **意向排他锁**（intention exclusive lock, IX）：事务有意向对表中的某些行加**排他锁**（X锁），顺便会加上意向排他锁

```
-- 事务要获取某些行的 X 锁，必须先获得表的 IX 锁。
SELECT column FROM table ... FOR UPDATE;
```

即：意向锁是由存储引擎 自己维护的 ，用户无法手动操作意向锁，在为数据行加共享 / 排他锁之前，InooDB 会先获取该数据行 所在数据表的对应意向锁 。



**1.关于意向锁要解决的问题**

现在有两个事务，分别是T1和T2，其中T2试图在该表级别上应用共享或排它锁，如果没有意向锁存在，那么T2就需要去检查各个页或行是否存在锁（如果是只有一条，那么这样去检查整个页的性能是很差的）;如果存在意向锁，那么此时就会受到由T1控制的 表级别意向锁的阻塞。T2在锁定该表前不必检查各个页或行锁，而只需检査表上的意向锁。简单来说就是给更大一级别的空间示意里面是否已经上过锁（行级锁 -> 页级锁 -> 表级锁）。

在数据表的场景中，如果我们给某一行数据加上了排它锁，数据库会自动给更大一级的空间，比如数据页或数据表加上意向锁，告诉其他人这个数据页或数据表已经有人上过排它锁了，这样当其他人想要获取数据表排它锁的时候，只需要了解是否有人已经获取了这个数据表的意向排他锁即可。

- 如果事务想要获得数据表中某些记录的共享锁（即加共享锁），就需要在数据表上添加意向共享锁，
- 如果事务想要获得数据表中某些记录的排他锁（即加排他锁），就需要在数据表上添加意向排他锁。

这时，意向锁会告诉其他事务已经有人锁定了表中的某些记录。



**2.举例**

示例一：

创建表

```mysql
create table `demo` (
	`id` int not null,
	`name` varchar(255) not null,
	primary key (`id`)
) ENGINE=Innodb DEFAULT CHARSET=utf8mb4
```

插入相关数据

```mysql
insert into demo values
(1, 'zhangshan'),
(2, 'lisi'),
(3, 'wangwu'),
(4, 'guagua'),
(5, 'niujiu'),
(6, 'wangba');
```

通过xshell模拟不同客户端，登录不同的mysql

```shell
docker exec -it mysql /bin/bash #因为是容器部署
mysql -uroot -p
```

在session1中查看表通过命令select @@transaction_isolation;查看当前隔离级别，为可重复度

![image-20241205214815929](MySQL%E9%94%81.assets/image-20241205214815929.png)

在session1中通过begin开启事务，对id=6的数据加上排他锁（X锁）

![image-20241205215103326](MySQL%E9%94%81.assets/image-20241205215103326.png)

在session2中通过begin开启事务，给表demo整个表加上一个表级的读锁（S锁），显而易见发生了阻塞

![image-20241205215258697](MySQL%E9%94%81.assets/image-20241205215258697.png)

即我们在表中加了一个X锁后，会给表自动加一个表级别的意向锁（IX），并且IX和S锁是不兼容的，导致我们在session2中给表加S锁的时候发生阻塞。



示例二：

session1中加排他锁，并且自动添加上IX锁

![image-20241205220308409](MySQL%E9%94%81.assets/image-20241205220308409.png)

session2中加排他锁（注意id不能和session1中一样，不让X锁和X锁相互之前会发生阻塞），并且自动添加上IX锁，并且不发生阻塞

![image-20241205220742344](MySQL%E9%94%81.assets/image-20241205220742344.png)

说明意向排他锁和意向排他锁之间不会阻塞。



**3.兼容性如下所示**

|                  | 意向共享锁（IS） | 意向排他锁（IX） |
| ---------------- | ---------------- | ---------------- |
| 意向共享锁（IS） | 兼容             | 兼容             |
| 意向排他锁（IX） | 兼容             | 兼容             |

即意向锁之间是互相兼容的，但是他会与普通的排他/共享锁互斥

|             | 意向共享锁（IS） | 意向排他锁（IX） |
| ----------- | ---------------- | ---------------- |
| 共享锁（S） | 兼容             | 互斥             |
| 排他锁（X） | 互斥             | 互斥             |



**4.结论**

1. InnoDB 支持 多粒度锁 ，特定场景下，行级锁可以与表级锁共存。
2. 意向锁之间互不排斥，但除了 IS 与 S 兼容外， 意向锁会与 共享锁 / 排他锁 互斥 。
3. IX，IS是表级锁，不会和行级的X，S锁发生冲突。只会和表级的X，S发生冲突。
4. 意向锁在保证并发性的前提下，实现了 行锁和表锁共存 且 满足事务隔离性 的要求。
5. 意向锁不会与行级的共享/排他锁互斥（意向锁一般是表级以上，因为加了行锁才有表级别意向锁）！正因为如此，意向锁并不会影响到多个事务对不同数据行加排他锁时的并发性。（不然我们直接用普通的表锁就行了）



##### ③自增锁（AUTO-INC锁，MYISAM、Innodb都有）

在使用MySQL过程中，我们可以为表的某个列添加AUTO_INCREMENT属性。举例：

```mysql
create table `demo` (
	`id` int not null AUTO_INCREMENT,
	`name` varchar(255) not null,
	primary key (`id`)
) ENGINE=Innodb DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci

```

由于这个表的id字段声明了AUTO_INCREMENT，意味着在书写插入语句时不需要为其赋值，SQL语句修改

如下所示。

```mysql
INSERTINTO`demo`(name) VALUES ('zhangsan'),('lisi');
```

上边的插入语句并没有为id列显式赋值，所以系统会自动为它赋上递增的值。

现在我们看到的上面插入数据只是一种简单的插入模式，所有插入数据的方式总共分为三类，分别是：Simple inserts、Bulk inserts、Mixed-mode inserts。

1、Simple inserts （简单插入）

可以从SQL语句中预先确定要插入的行数(当语句被初始处理时)的语句。包括没有嵌套子查询的单行和多行INSERT...VALUES()和 REPLACE 语句。比如我们上面举的例子就属于该类插入，已经确定要插入的行数。

2、Bulk inserts （批量插入）

事先不知道要插入的行数(和所需自动递增值的数量)的语句。比如 INSERT ... SELECT， REPLACE ……。SELECT和 LOAD DATA语句，但不包括纯INSERT。InnoDB在每处理一行，为AUTO_INCREMENT列分配一个新值。

3、Mixed-mode inserts （混合模式插入）

这些是“Simple inserts”语句但是指定部分新行的自动递增值。例如INSERT INT0 teacher(id,name) VALUES(1,'a')，(NULL,'b')，(5,'c')，(NULL,'d');只是指定了部分id的值。另一种类型的“混合模式插入”是INSERT ... ON DUPLICATE KEY UPDATE。



对于上面数据插入的案例，MySQL中采用了自增锁 的方式来实现，AUTO-INC锁是当向使用含有AUTO_INCREMENT列的表中插入数据时需要获取的一种特殊的表级锁，在执行插入语句时就在表级别加一个AUTO-INC锁，然后为每条待插入记录的AUTO_INCREMENT修饰的列分配递增的值，在该语句执行结束后，再把AUTO-INC锁释放掉。一个事务在持有AUTO-INC锁的过程中，其他事务的插入语句都要被阻塞，可以保证一个语句中分配的递增值是连续的。也正因为此，其并发性显然并不高，当我们向一个有AUTO_INCREMENT关键字的主键插入值的时候，每条语句都要对这个表锁进行竞争，这样的并发潜力其实是很低下的，所以innodb通过 innodb_autoinc_lock_mode的不同取值来提供不同的锁定机制，来显著提高SQL语句的可伸缩性和性能。

（1）innodb_autoinc_lock_mode=0(“传统”锁定模式)

在此锁定模式下，所有类型的insert语句都会获得一个特殊的表级AUTO-INC锁，用于插入具有AUTO_INCREMENT列的表。这种模式其实就如我们上面的例子，即每当执行insert的时候，都会得到一个表级锁(AUTO-INC锁)，使得语句中生成的auto_increment为顺序，且在binlog中重放的时候，可以保证master与slave中数据的auto_increment是相同的。因为是表级锁，当在同一时间多个事务中执行insert的时候，对于AUTO-INC锁的争夺会限制并发能力。

（2）innodb_autoinc_lock_mode=1(“连续”锁定模式)

在MySQL8.0之前，连续锁定模式是默认的。

在这个模式下，“bulk inserts”仍然使用AUTO-INC表级锁（批量插入，不知道插入的数量，需要表级锁去取进行控制），并保持到语句结束。这适用于所有INSERT...SELECT，REPLACE...SELECT和LOADDATA语句。同一时刻只有一个语句可以持有AUTO-INC锁。

对于“Simple inserts”（要插入的行数事先已知），则通过在mutex（轻量锁）的控制下获得所需数量的

自动递增值来避免表级AUTO-INC锁，它只在分配过程的持续时间内保持，而不是直到语句完成。不使用表级AUTO-INC锁，除非AUTO-INC锁由另一个事务保持。如果另一个事务保持AUTO-INC锁，则“Simple inserts”等待AUTO-INC锁，如同它是一个“bulk inserts”。

注意，对于Simple inserts也要握到AUTO-INC表级锁，其只不过相较于bulk inserts是很快就释放了而已，如果其他事务持有AUTO-INC表级锁的话，对于Simple inserts仍然会阻塞。

（3）innodb_autoinc_lock_mode=2(“交错”锁定模式)

从 MySOL 8.0 开始，交错锁模式是 默认 设置。
在这种锁模式下，所有类INSERT语句都不会使用表级AUTO-INC锁，并且可以同时执行多个语句。这是最快和最可扩展的锁定模式，当时当使用基于语句的复制或恢复方案时，从二进制日志重播SQL语句时，这是不安全的。
在此锁定模式下，自动递增值 保证 在所有并发执行的所有类型的insert语句中是 唯一且单调递增 的。但是，由于多个语句可以同时生成数字(即，跨语句交叉编号)，为任何给定语句插入的行生成的值可能不是连续的。
如果执行的语句是“simple inserts”，其中要插入的行数已提前知道，除了“Mixed-mode inserts”之外，为单个语句生成的数字不会有间隙。然而，当执行“bulk inserts”时，在由任何给定语句分配的自动递增值中可能存在间隙。



##### ④元数据锁（MDL锁，MYISAM、Innodb都有）

MySQL5.5引入了meta data lock，简称MDL锁，属于表锁范畴。MDL的作用是，保证读写的正确性。比如，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个 表结构做变更，增加了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。
因此，当对一个表做增删改查操作的时候，加 MDL读锁;当要对表做结构变更操作的时候，加 MDL 写锁。
读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性，解决了DML和DDL操作之间的一致性问题。不需要显式使用，在访问一个表的时候会被自动加上。

示例一：

session1

查询加一个读锁

![image-20241206000147342](MySQL%E9%94%81.assets/image-20241206000147342.png)

session2

发生阻塞

![image-20241206000212188](MySQL%E9%94%81.assets/image-20241206000212188.png)

session3

show processlist可以看到，当前session2修改表结构正在等待元数据锁

![image-20241206000521676](MySQL%E9%94%81.assets/image-20241206000521676.png)



示例二：

![image-20241205230047527](MySQL%E9%94%81.assets/image-20241205230047527.png)





















问题：

- mysql中如下方式查询不到？

```
-- 1. 开始一个会话，确保没有未提交的事务
LOCK TABLES test WRITE;

-- 2. 查询数据
SELECT * FROM test;  -- 这里应该能返回数据

-- 3. 解锁
UNLOCK TABLES;
```

1.查询 √

通过命令`select * from test`查看表的信息

![image-20241016233018532](MySQL%E9%94%81.assets/image-20241016233018532.png)

2.更新、删除 ×

通过命令`update test set name = 'ww'`更新表信息

![image-20241016233125660](MySQL%E9%94%81.assets/image-20241016233125660.png)

通过命令`unlock tables;`解锁表的锁



- 通过命令`lock tables test write`给test表上表级别的X锁

通过命令`show open tables where in_use > 0;`查看上锁的表

![image-20241016232449234](MySQL%E9%94%81.assets/image-20241016232449234.png)

1.查询 ×

通过命令`select * from test`查看表的信息

无法查询到表中的数据



2.更新、删除 ×

通过命令`update test set name = 'ww'`更新表信息

![image-20241016233125660](MySQL%E9%94%81.assets/image-20241016233125660.png)

无法更新表中的数据

通过命令`unlock tables;`解锁表的锁