# MySQL锁

## 一、前言

### 1.1 说明

锁是计算机协调多个进程或线程”并发访问某一资源 的机制。在程序开发中会存在多线程同步的问题，当多个线程并发访问某个数据的时候，尤其是针对一些敏感的数据(比如订单、金额等)，我们就需要保证这个数据在任何时刻最多只有一个线程在访问，保证数据的完整性和一致性。在开发过程中加锁是为了保证数据的一致性，这个思想在数据库领域中同样很重要。

在数据库中，除传统的计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供许多用户共享的资源。为保证数据的一致性，需要对 并发操作进行控制 ，因此产生了 锁 。同时 锁机制 也为实现MySQL的各个隔离级别提供了保证。 锁冲突 也是影响数据库 并发访问性能 的一个重要因素。所以锁对数据库而言显得尤其重要，也更加复杂。

MySQL中事务的隔离性就是由锁来实现的。

### 1.2 解决并发问题方案(针对读和写/写和读)

怎么解决脏读 、 不可重复读 、 幻读这些问题有两种可选的解决方案:

方案一：读操作利用多版本并发控制(MVCC)，写操作进行加锁

所谓的 MVCC，就是生成一个Readview，通过Readview找到符合条件的记录版本(历史版本由undo日志构建)。查询语句只能读 到在生成ReadView之前已提交事务所做的更改，在生成ReadView之前未提交的事务或者之后才开启的事务所做的更改是看不到的。而写操作 肯定针对的是最新版本的记录 ，读记录的历史版本和改动记录的最新版本本身并不冲突，也就是采用MVCC时，读-写操作并不冲突。

> 普通的SELECT语句在READCOMMITTED和REPEATABLEREAD隔离级别下会使用到MVCC读取记录。
>
> - 在READ COMMITTED隔离级别下，一个事务在执行过程中每次执行SELECT操作时都会生成一个ReadView，ReadView的存在本身就保证了事务不可以读取到未提交的事务所做的更改，也就是避免了脏读现象;
> - 在 REPEATABLE READ隔离级别下，一个事务在执行过程中只有第一次执行SELECT操作 才会生成一个ReadView，之后的SELECT操作都 复用 这个ReadView，这样也就避免了不可重复读和幻读的问题。

方案二：读、写操作都采用 加锁 的方式

如果我们的一些业务场景不允许读取记录的旧版本，而是每次都必须去 读取记录的最新版本。比如，在银行存款的事务中，你需要先把账户的余额读出来，然后将其加上本次存款的数额，最后再写到数据库中。在将账户余额读取出来后，就不想让别的事务再访问该余额，直到本次存款事务执行完成，其他事务才可以访问账户的余额。这样在读取记录的时候就需要对其进行 加锁 操作，这样也就意味着 读 操作和 写 操作也像 写-写 操作那样需要排队执行。
**脏读** 的产生是因为当前事务读取了另一个未提交事务写的一条记录，如果另一个事务在写记录的时候就给这条记录加锁，那么当前事务就无法继续读取该记录了，所以也就不会有脏读问题的产生了。
**不可重复读** 的产生是因为当前事务先读取一条记录，另外一个事务对该记录做了改动之后并提交之后，当前事务再次读取时会获得不同的值，如果在当前事务读取记录时就给该记录加锁，那么另一个事务就无法修改该记录，自然也不会发生不可重复读了。
**幻读** 问题的产生是因为当前事务读取了一个范围的记录，然后另外的事务向该范围内插入了新记录，当前事务再次读取该范围的记录时发现了新插入的新记录。采用加锁的方式解决幻读问题就有一些麻烦，因为当前事务在第一次读取记录时幻影记录并不存在，所以读取的时候加锁就有点尴尬(后续有间隙锁来实现)。

小结:

- 采用 MVCC 方式的话，读-写操作彼此并不冲突，性能更高。
- 采用 加锁 方式的话，读-写操作彼此需要 排队执行，影响性能。

般情况下我们当然愿意采用 MVCC 来解决读-写操作并发执行的问题，但是业务在某些特殊情况下，要求必须采用加锁的方式执行。



## 二、并发事务访问情况

并发事务访问可以分为三种情况：

### 2.1 先读后读

读-读情况，即并发事务相继读取相同的记录 。读取操作本身不会对记录有任何影响，并不会引起什么问题，所以允许这种情况的发生。

### 2.2 先写后写

写-写 情况，即并发事务相继对相同的记录做出改动。

在这种情况下会发生脏写的问题(有一条记录如1，A和B此时都读取到的记录为1，A对该记录进行修改为2并提交，此时B对该记录修改为3后回滚，对于A来说最终结果还是1，出现了脏写)，任何一种隔离级别都不允许这种问题的发生。所以在多个未提交事务相继对一条记录做改动时，需要让它们 排队执行 ，这个排队的过程其实是通过 锁 来实现的。这个所谓的锁其实是一个 内存中的结构 ，在事务执行前本来是没有锁的，也就是说一开始是没有 锁结构 和记录进行关联的，如图所示：

![image-20241203214516807](MySQL%E9%94%81.assets/image-20241203214516807.png)

当一个事务想对这条记录做改动时，首先会看看内存中有没有与这条记录关联的 锁结构 ，当没有的时候就会在内存中生成一个 锁结构 与之关联。比如，事务 T1 要对这条记录做改动，就需要生成一个 锁结构与之关联(如果有两个事物，就会有两个索结构，其是和事物相关的)：

![image-20241203214659978](MySQL%E9%94%81.assets/image-20241203214659978.png)

在锁结构里有很多信息，为了简化理解，只把两个比较重要的属性拿了出来:

- trx信息：代表这个锁结构是哪个事物生成的
- is_waiting:代表当前事务是否在等待

当事务 T1改动了这条记录后，就生成了一个 锁结构 与该记录关联，因为之前没有别的事务为这条记录加锁，所以 is_waiting属性就是 false，我们把这个场景就称之为 获取锁成功，或者加锁成功 ，然后就可以继续执行操作了。

在事务 T1提交之前，另一个事务 T2 也想对该记录做改动，那么先看看有没有 锁结构 与这条记录关联，发现有一个 锁结构 与之关联后，然后也生成了一个锁结构与这条记录关联，不过锁结构的is_waiting属性值为 true，表示当前事务需要等待，我们把这个场景就称之为 获取锁失败 ，或者加锁失败，图示:

![image-20241203215208597](MySQL%E9%94%81.assets/image-20241203215208597.png)

在事务T1提交之后，就会把该事务生成的 锁结构释放 掉，然后看看还有没有别的事务在等待获取锁，发现了事务T2还在等待获取锁，所以把事务T2对应的锁结构的 is_waiting 属性设置为 false，然后把该事务对应的线程唤醒，让它继续执行，此时事务T2就算获取到锁了。效果图就是这样:

![image-20241203215254499](MySQL%E9%94%81.assets/image-20241203215254499.png)

说明：

（1）不加锁

不需要在内存中生成对应的 锁结构，可以直接执行操作。

（2）获取锁成功，或者加锁成功

在内存中生成了对应的 锁结构，而且锁结构的 is_waiting 属性为 false，也就是事务可以继续执行操作。

（3）获取锁失败，或者加锁失败，或者没有获取到锁

在内存中生成了对应的 锁结构 ，不过锁结构的 is_waiting属性为 true，也就是事务需要等待，不可以继续执行操作。

### 2.3 先读后写/先写后读

读-写或写-读 ，即一个事务进行读取操作，另一个进行改动操作。这种情况下可能发生 脏读 、不可重复读、幻读的问题。

各个数据库厂商对 SQL标准 的支持都可能不一样。比如MySQL在 REPEATABLE READ 隔离级别上就已经解决了幻读 问题。



## 三、锁的分类

### 3.1 分类

**1. 根据数据操作类型划分**

- 读锁/共享锁
- 写锁/排他锁

**2. 根据锁粒度角度划分**

> 对一条记录加锁影响的是这条记录，该锁的粒度比较细;一个事务也可以在表级别进行加锁，称为表级锁或者表锁，对一个表加锁影响整个表中的记录，这个锁的粒度比较粗。锁的粒度主要可以分为表级锁、页级锁和行锁。

- 表级锁（table lock）
  - 表级别的S锁（共享锁）、X锁（排他锁）
  - 意向锁（intention lock）
  - 自增锁（AUTO-INC锁）
  - 元数据锁（MDL锁）
- 行级锁
  - 记录锁（Record Locks）
  - 间隙锁（Gap Locks）
  - 临键锁（Next-Key Locks）
  - 插入意向锁（Insert Intention Locks）
- 页级锁

**3. 对待锁的态度划分**

- 悲观锁（Pessimistic Locking）
- 乐观锁（Optimistic Locking）

**4. 加锁方式**

- 隐式锁
- 显示锁

**5. 其他**

- 全局锁
- 死锁



### 3.2 数据操作类型：读锁/共享锁、写锁/排他锁









### 3.3 锁粒度角度划分：表级锁、行级锁、页级锁

#### 1. 锁粒度的概念

为了尽可能提高数据库的并发度，每次锁定的数据范围越小越好，理论上每次只锁定当前操作的数据的方案会得到最大的并发度，但是管理锁是很`耗资源`的事情（涉及获取、检查、释放锁等动作)(越小消耗越大)。因此数据库系统需要在`高并响应`和`系统性能`两方面进行平衡。

#### 2. 表锁（table lock）

表锁会锁定整张表，是MySQL中最基本的锁策略，并不依赖于存储引擎(不管你是MySQL的什么存储引擎，
对于表锁的策略都是一样的)。表锁是`开销最小`的策略（因为粒度比较大)。由于表级锁一次会将整个表锁定，所以可以很好的避免死锁问题。当然，锁的粒度大所带来最大的负面影响就是出现锁资源争用的概率也会最高，导致并发率大打折扣。因此，表锁的特点就是开销小（不需要频繁加、放锁），但是并发能力差。

表锁又可以分为共享锁（S锁）和排他锁（X锁），在系统变量`autocommit=0（InnoDB 会关闭自动提交模式），innodb_table_locks = 1（1为默认值，InnoDB 会使用表级锁。这意味着在对一个表进行操作时，整个表会被锁定，直到操作完成）`时，手动获取InnoDB存储引擎提供 的S锁或者X锁：

- InnoDB存储引擎加表级别的S锁

  ```
  LOCK TABLES t READ
  ```

- InnoDB存储引擎加表级别的X锁

  ```
  LOCK TABLES t WRITE
  ```

对某个表执行SELECT、INSERT、DELETE、UPDATE语句（DML，数据操作语言）时，InnoDB存储引擎是不会为这个表添加表级别的`S锁`或者`X锁`的。在对某个表执行一些诸如`ALTER TABLE`、`DROP TABLE`这类的`DDL`语句时，其他事务对这个表并发执行诸如SELECT、INSERT、DELETE、UPDATE的语句会发生阻塞。同理，某个事务中对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，在其他会话中对这个表执行`DDL`语句也会发生阻塞。这个过程其实是通过在server层使用一种称之为`元数据锁`（英文名：`Metadata Locks`，简称`MDL`）结构来实现的。一般情况下，不会使用InnoDB存储引擎提供的`表级别`的`S锁`和`X锁`。只会在一些特殊情况下，比方说`崩溃恢复`过程中用到。

注意：不过尽量避免在使用InnoDB存储引擎的表上使用`LOCK TABLES`这样的手动锁表语句，它们并不会提供什么额外的保护，只是会降低并发能力而已。InnoDB的厉害之处还是实现了更细粒度的行锁，



##### 示例：

首先要使用表级锁，我们先要关闭自动提交以及设置InnoDB使用表级锁

```mysql
-- 查看当前自动提交状态（默认为ON开启）
show variables like '%autocommit%';

-- SET autocommit = 0; 等价
SET @@autocommit = 0;
```

```mysql
-- 查看当前使用表级锁（默认为ON开启）
show variables like '%innodb_table_locks%';
-- 设置当前使用表级锁为ON（会话状态即可，不用全局）
SET innodb_table_locks = 1;
```

我们可以通过`show open tables`去查看所有表的状态，其列信息如下：

- **Database**: 表所在的数据库名。
- **Table**: 表的名称。
- **In_use**: 表的使用状态（通常是 0 或 1）。`1` 表示该表当前被某个连接使用，`0` 表示没有连接在使用该表。
- **Name_locked**: 表示该表是否被锁定，通常是 0 或 1。`1` 表示该表被锁定，`0` 表示未锁定。

```
+----------+--------------------+--------+-------------+
| Database | Table              | In_use | Name_locked |
+----------+--------------------+--------+-------------+
| mydb     | my_table           |      1 |           0 |
| mydb     | another_table      |      0 |           0 |
+----------+--------------------+--------+-------------+
```



- 通过命令`lock tables test read`给test表上表级别的S锁

通过命令`show open tables where in_use > 0;`查看上锁的表







##### 综上总结：

MyISAM在执行查询语句（SELECT）前，会给涉及的所有表加读锁，在执行增删改操作前，会给涉及的表加写锁。InnoDB存储引擎是不会为这个表添加表级别的`读锁`或者`写锁`的。（有行锁，谁TM用表锁啊）

MySQL的表级锁有两种模式：（以MyISAM表进行操作的演示）

- 表共享读锁（Table Read Lock）
- 表独占写锁（Table Write Lock）

| 锁类型 | 自己可读 | 自己可写 | 自己可操作其他表 | 他人可读 | 他人可写 |
| ------ | -------- | -------- | ---------------- | -------- | -------- |
| 读锁   | 是       | 否       | 否               | 是       | 否，等   |
| 写锁   | 是       | 是       | 否               | 否，等   | 否，等   |







问题：

- mysql中如下方式查询不到？

```
-- 1. 开始一个会话，确保没有未提交的事务
LOCK TABLES test WRITE;

-- 2. 查询数据
SELECT * FROM test;  -- 这里应该能返回数据

-- 3. 解锁
UNLOCK TABLES;
```

1.查询 √

通过命令`select * from test`查看表的信息

![image-20241016233018532](MySQL%E9%94%81.assets/image-20241016233018532.png)

2.更新、删除 ×

通过命令`update test set name = 'ww'`更新表信息

![image-20241016233125660](MySQL%E9%94%81.assets/image-20241016233125660.png)

通过命令`unlock tables;`解锁表的锁



- 通过命令`lock tables test write`给test表上表级别的X锁

通过命令`show open tables where in_use > 0;`查看上锁的表

![image-20241016232449234](MySQL%E9%94%81.assets/image-20241016232449234.png)

1.查询 ×

通过命令`select * from test`查看表的信息

无法查询到表中的数据



2.更新、删除 ×

通过命令`update test set name = 'ww'`更新表信息

![image-20241016233125660](MySQL%E9%94%81.assets/image-20241016233125660.png)

无法更新表中的数据

通过命令`unlock tables;`解锁表的锁