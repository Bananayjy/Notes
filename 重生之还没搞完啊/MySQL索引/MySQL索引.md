# MySQL索引

## 一、索引

### 1.1 介绍

用**一句话概括**，索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。

用**比喻说明**，索引就相当于一本书的目录，在查字典的时候，如果没有目录，那我们就只能一页一页的去找我们需要查的那个字，速度很慢。如果有目录了，我们只需要先去目录里查找字的位置，然后直接翻到那一页就行了。

索引是一个单独的、存储在磁盘上的数据库结构，它们包含着对数据表里所有记录的引用指针。使用索引用于快速找出在某个或多个列中有一特定值的行，所有MySQL列类型都可以被索引，对相关列使用索引是提高查询操作速度的最佳途径。

实际上，索引也是一张“表”，该表保存了主键与索引字段，并指向实体表的记录，虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件，建立索引会占用磁盘空间的索引文件。说白了索引就是用来提高速度的，但是就需要维护索引造成资源的浪费，所以合理的创建索引是必要的。

**为什么要使用索引？**

索引是存储引擎用于快速找到数据记录的一种数据结构，就好比一本教课书的目录部分，通过目录中找到对应文章的页码，便可快速定位到需要的文章。MvSOL中也是一样的道理，进行数据查找时，首先查看查询条件是否命中某条索引，符合则通过索引査找相关数据，如果不符合则需要全表扫描（即需要一条一条地查找记录，直到找到与条件符合的记录）

![image-20241120230653691](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241120230653691.png)

如上图，在没有索引的情况下，我们现在要查询数据6，因为数据在磁盘中存储布局是离散的、随机的，分布在硬盘不同的位置上，读取数据时，摆臂需要不断前后摆动查找数据，很耗时，对于这种方式是十分不推荐的，犹如大海捞针。如果在磁盘中开辟一段连续的空间，使数据顺序摆放，那么也需要从1到6行按顺序读取，这样就相当于进行了6次I0操作，依旧非常耗时。如果我们不借助任何索引结构帮助我们快速定位数据的话，我们查找col2=89 这条记录，就要逐行去查找、去比较。从Col2=34开始，进行比较，发现不是，继续下一行。我们当前的表只有不到10行数据，但如果表很大的话，有上千万条数据，就意味着要做 很多很多次磁盘I/O 才能找到。现在要査找 col2=89 这条记录。CPU必须先去磁盘查找这条记录，找到之后加载到内存，再对数据进行处理。这个过程最耗时间的就是磁盘I/O (涉及到磁盘的旋转时间(速度较快)、磁头的寻道时间(速度慢、费时))

给数据使用 二叉树 这样的数据结构进行存储，如下图所示

![image-20241120230642288](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241120230642288.png)

对字段Col2 添加了索引，就相当于在硬盘上为Col2维护了一个索引的数据结构，即这个 二叉搜索树。二叉搜索树的每个结点存储的是(K，V)结构，key是col2，value 是该 key 所在行的文件指针(地址)。比如:该二叉搜索树的根节点就是:(34,0x87)。现在对 Col2添加了索引，这时再去査找 col2=89 这条记录的时候会先去查找该二叉搜索树(二叉树的遍历査找)。读 34 到内存，89>34;继续右侧数据，读 89 到内存，89 == 89;找到数据返回。找到之后就根据当前结点的value快速定位到要查找的记录对应的地址。我们可以发现，只需要 查找两次就可以定位到记录的地址，查询速度就提高了。
这就是我们为什么要建索引，目的就是为了 减少磁盘I/O的次数 （因为相较于算法上时间复杂度的提升，IO耗时来得更加明显，比如O（n^2） 用时2ms，优化算法后其时间复杂度到达到O（logn），其都是在内存中进行操作处理的，但是磁盘一次IO就要200ms），加快查询速率。

**定义：**

索引（Index）是帮助MySQL高效获取数据的数据结构。

**索引的本质：**

索引是数据结构。你可以简单理解为“排好序的快速査找数据结构”，满足特定査找算法。这些数据结构以某种方式指向数据，这样就可以在这些数据结构的基础上实现 高级査找算法。索引是在存储引擎中实现的，因此每种存储引擎的索引不一定完全相同，并且每种存储引擎不一定支持所有索引类型。同时，存储引擎可以定义每个表的 最大索引数 和最大索引长度。所有存储引擎支持每个表至少16个索引，总索引长度至少为256字节。有些存储引擎支持更多的索引数和更大的索引长度。



### 1.2 优缺点

**优点**

- 使用索引可以大大加快数据的检索速度（大大减少检索的数据量）, 减少 IO 次数，这也是创建索引的最主要的原因。
- 通过创建唯一索引，可以保证数据库表中每一行 数据的唯一性
- 在实现数据的参考完整性方面，可以加速表和表之间的连接。换句话说，对于有依赖关系的子表和父表联合查询时，可以提高查询速度。
- 在使用分组和排序子句进行数据查询时，可以显著 减少査询中分组和排序的时间 ，降低了CPU的消耗

**缺点**

- 创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。
- 索引需要使用物理文件存储，也会耗费一定空间。每一个索引还要占一定的物理空间，存储在磁盘上如果有大量的索引，索引文件就可能比数据文件更快达到最大文件尺寸。

建议：索引可以提高查询的速度，但是会影响插入记录的速度。这种情况下，最好的办法是先删除表中的索引，然后插入数据，插入完成后再创建索引。



### 1.3 MySQL 8.0 索引新特性

#### 1.降序索引

降序索引以降序存储键值。虽然在语法上，从MySQL4版本开始就已经支持降序索引的语法了，但实际上该DESC定义是被忽略的（即实际创建的还是升序索引，在遍历降序索引的时候，通过反向扫描的方式进行），直到MySQL8.x版本才开始真正支持降序索引(仅限于InnoDB存储引擎)。
MySQL在8.0版本之前创建的仍然是升序索引，使用时进行反向扫描，这大大降低了数据库的效率。在某些场景下，降序索引意义重大。例如，如果一个查询，需要对多个列进行排序（有的列需要升序，有的列需要降序），且顺序要求不一致，那么使用降序索引将会避免数据库使用额外的文件排序（Using filesort）操作，从而提高性能（使用降序索引可以帮助数据库在排序时更加高效）。

降序索引是指在某个列上创建的索引，使得该列的数据按照降序排列。当查询时，如果使用了这种降序索引，数据库可以直接利用索引中的顺序来返回结果，而不需要额外的文件排序操作（即“Using filesort”），从而提高查询性能。

举个例子，假设你有一个包含姓名、年龄和收入的表格，你想按照年龄升序、收入降序进行排序。如果在收入这一列上创建了降序索引，数据库在执行查询时就能更快地找到符合条件的记录，而不需要先将所有记录取出来再进行排序，从而减少了资源消耗和执行时间。

举例:分别在MySOL5.7版本和MySOL8.0版本中创建数据表ts1，结果如下:

```mysql
CREATE TABLE ts1(a int,b int,index idx_a_b(a,b desc));
```

在MySQL 5.7版本中查看数据表ts1的结构，结果如下，索引仍然是默认升序

![image-20241030222412520](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241030222412520.png)

在MySQL 8.0版本中查看数据表ts1的结构，，索引已经是降序了

![image-20241030222507466](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241030222507466.png)

在MySQL 5.7版本和MySQL 8.0版本的数据表ts1中插入800条随机数据，执行语句如下：

```mysql
DELIMITER //
CREATE PROCEDURE ts_insert()
BEGIN
    DECLARE i INT DEFAULT 1;
    WHILE i < 800
    DO
        insert into ts1 select rand()*80000,rand()*80000;
        SET i = i + 1;
    END WHILE;
    commit;
END //
DELIMITER ;

#调用
CALL ts_insert();
```

在MySQL 5.7版本中查看数据表ts1的执行计划，结果可以看出，执行计划中扫描数为799，而且使用了Using filesort，Using filesort是MySQL中一种速度比较慢的外部排序，能避免是最好的。多数情况下，管理员

可以通过优化索引来尽量避免出现Using filesort，从而提高数据库执行速度。

```mysql
EXPLAIN SELECT * FROM ts1 ORDER BY a,b DESC LIMIT 5;
```

![image-20241030223100810](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241030223100810.png)

在MySQL 8.0版本中查看数据表ts1的执行计划。从结果可以看出，执行计划中扫描数为5，而且没有使用

Using filesort。

![image-20241030223130703](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241030223130703.png)

注意：降序索引只对查询中特定的排序顺序有效，如果使用不当，反而查询效率更低。例如，上述

查询排序条件改为order by a desc, b desc（没有匹配索引的顺序），MySQL 5.7的执行计划要明显好于MySQL 8.0。

```mysql
EXPLAIN SELECT * FROM ts1 ORDER BY a DESC,b DESC LIMIT 5;
```

![image-20241030223233151](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241030223233151.png)

在MySQL 8.0版本中查看数据表ts1的执行计划。从结果可以看出，修改后MySQL 5.7的执行计划要明显好于MySQL 8.0

#### 2.隐藏索引

在MySQL 5.7版本及之前，只能通过显式的方式删除索引。此时，如果发现删除索引后出现错误，又只能通过显式创建索引的方式将删除的索引创建回来（如删除一个唯一索引后，若后续的插入操作会导致重复数据，与业务不符合）。如果数据表中的数据量非常大，或者数据表本身比较大，这种操作就会消耗系统过多的资源，操作成本非常高。

从MySQL 8.x开始支持 隐藏索引（invisible indexes） ，只需要将待删除的索引设置为隐藏索引，使查询优化器不再使用这个索引（即使使用force index（强制使用索引），优化器也不会使用该索引），确认将索引设置为隐藏索引后系统不受任何响应，就可以彻底删除索引。 这种通过先将索引设置为隐藏索引，再删除索引的方式就是软删除 。

如果需要验证某个索引删除之后的查询性能影响，就可以暂时应参该索引。

注意：主键不能被设置为隐藏索引。当表中没有显式主键时，表中第一个唯一非空索引会成为隐式主键，也不能设置为隐藏索引。

索引默认是可见的，在使用CREATETABLE，CREATEINDEX或者ALTER TABLE等语句时可以通过 VISIBLE 或者INVISIBLE 关键词设置索引的可见性，具体的做法如下所示

- **创建表时直接创建** 在MySQL中创建隐藏索引通过SQL语句INVISIBLE来实现，其语法形式如下

上述语句比普通索引多了一个关键字INVISIBLE，用来标记索引为不可见索引。

```mysql
CREATE TABLE tablename(
    propname1 type1[CONSTRAINT1],
    propname2 type2[CONSTRAINT2],
    ……
    propnamen typen,
    INDEX [indexname](propname1 [(length)]) INVISIBLE
);
```

- **在已经存在的表上创建**

可以为已经存在的表设置隐藏索引，其语法形式如下：

```mysql
CREATE INDEX indexname
ON tablename(propname[(length)]) INVISIBLE;
```

- **通过ALTER TABLE语句创建**

语法形式如下：

```mysql
ALTER TABLE tablename
ADD INDEX indexname (propname [(length)]) INVISIBLE;
```

- **切换索引可见状态** 

已存在的索引可通过如下语句切换可见状态

```mysql
ALTER TABLE tablename ALTER INDEX index_name INVISIBLE; #切换成隐藏索引
ALTER TABLE tablename ALTER INDEX index_name VISIBLE; #切换成非隐藏索引
```

注意：当索引被隐藏时，它的内容仍然是和正常索引一样实时更新的。如果一个索引需要长期被隐藏，那么可以将其删除，因为索引的存在会影响插入、更新和删除的性能。通过设置隐藏索引的可见性可以查看索引对调优的帮助。

- **使隐藏索引对查询优化器可见**

在MySQL 8.x版本中，为索引提供了一种新的测试方式，可以通过查询优化器的一个开（use_invisible_indexes）来打开某个设置，使隐藏索引对查询优化器可见。如果 use_invisible_indexes设置为off(默认)，优化器会忽略隐藏索引。如果设置为on，即使隐藏索引不可见，优化器在生成执行计划时仍会考虑使用隐藏索引。

（1）在MySQL命令行执行如下命令查看查询优化器的开关设置。

```
mysql> select @@optimizer_switch \G
```

在输出的结果信息中找到如下属性配置。

```
use_invisible_indexes=off
```

此属性配置值为off，说明隐藏索引默认对查询优化器不可见。

（2）使隐藏索引对查询优化器可见，需要在MySQL命令行执行如下命令：

```mysql
mysql> set session optimizer_switch="use_invisible_indexes=on";
Query OK, 0 rows affected (0.00 sec)
```

SQL语句执行成功，再次查看查询优化器的开关设置

```mysql
mysql> select @@optimizer_switch \G
*************************** 1. row ***************************
@@optimizer_switch:
index_merge=on,index_merge_union=on,index_merge_sort_union=on,index_merge_
intersection=on,engine_condition_pushdown=on,index_condition_pushdown=on,mrr=on,mrr_co
st_based=on,block_nested_loop=on,batched_key_access=off,materialization=on,semijoin=on
,loosescan=on,firstmatch=on,duplicateweedout=on,subquery_materialization_cost_based=on
,use_index_extensions=on,condition_fanout_filter=on,derived_merge=on,use_invisible_ind
exes=on,skip_scan=on,hash_join=on
1 row in set (0.00 sec)
```

此时，在输出结果中可以看到如下属性配置。

```mysql
use_invisible_indexes=on
```

use_invisible_indexes属性的值为on，说明此时隐藏索引对查询优化器可见。

（3）使用EXPLAIN查看以字段invisible_column作为查询条件时的索引使用情况。

```mysql
explain select * from classes where cname = '高一2班';
```

查询优化器会使用隐藏索引来查询数据。

（4）如果需要使隐藏索引对查询优化器不可见，则只需要执行如下命令即可。

```mysql
mysql> set session optimizer_switch="use_invisible_indexes=off";
Query OK, 0 rows affected (0.00 sec)
```

再次查看查询优化器的开关设置。

```mysql
mysql> select @@optimizer_switch \G
```

此时，use_invisible_indexes属性的值已经被设置为“off”。



#### 3.函数索引

从 MySQL 8.0.13 版本开始支持在索引中使用函数或者表达式的值，也就是在索引中可以包含函数或者表达式。



### 1.4 索引的演变（主流的innodb存储引擎）

####  1.没有索引时的查找过程

对于一个精确匹配的SQL语句

```mysql
SELECT [列名列表] FROM 表名 WHERE 列名 = xxx;
```

①**在一个页中的查找**

假设目前表中的记录比较少，所有的记录都可以被存放到一个页中，在查找记录的时候可以根据搜索条件的不同分为两种情况:

- 以主键（一般自增长，有序）为搜索条件

可以在页目录中使用 二分法 快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。（时间复杂度：O（logn））

- 以其他列作为搜索条件

因为在数据页中并没有对非主键列建立所谓的页目录，所以我们无法通过二分法快速定位相应的槽。这种情况下只能从 最小记录 开始 依次遍历 单链表中的每条记录，然后对比每条记录是不是符合搜索条件。很显然这种查找的效率是非常低的。（时间复杂度：O（n））



②**在很多页中查找**

大部分情况下我们表中存放的记录都是非常多的，需要好多的数据页来存储这些记录。比如我们要找一个其他列的值，由于其存储不是有序的，因此我们需要从头开始，遍历各个页中的数据去进行查找，在很多页中查找记录的话可以分为两个步骤

- 定位到记录所在的页
- 从所在的页内中查找相应的记录

在没有索引的情况下，不论是根据主键列或者其他列的值进行查找，由于我们并不能快速的定位到记录所在的页，所以只能 从第一个页 沿着 双向链表 一直往下找，在每一个页中根据我们上面的查找方式去查找指定的记录。因为要遍历所有的数据页，所以这种方式显然是 超级耗时 的。



#### 2. 设计索引

假设我们建了一张表，并且指定其行格式为Compact

```mysql
mysql> CREATE TABLE index_demo(
    -> c1 INT,
    -> c2 INT,
    -> c3 CHAR(1),
    -> PRIMARY KEY(c1)
    -> ) ROW_FORMAT = Compact;
```

这个新建的 index_demo 表中有2个INT类型的列，1个CHAR(1)类型的列，而且我们规定了c1列为主键，这个表使用 Compact 行格式来实际存储记录的。这里我们简化了index_demo表的行格式示意图：

![image-20241121232601505](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241121232601505.png)

内容：

- record_type ：记录头信息的一项属性，表示记录的类型， 0 表示普通记录、 2 表示最小记录、 3 表示最大记录、 1目录项记录
- next_record ：记录头信息的一项属性，表示下一条地址相对于本条记录的地址偏移量，我们用箭头来表明下一条记录是谁。(通过该属性保证各个记录之间在逻辑上是连续的，而不用保证在物理上是连续的)
- 各个列的值 ：这里只记录在 index_demo 表中的三个列，分别是 c1 、 c2 和 c3。
- 其他信息 ：除了上述3种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。

将记录格式示意图的其他信息项暂时去掉并把它竖起来的效果就是这样：

![image-20241121232828010](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241121232828010.png)

把一些记录放到页里的示意图就是：

![image-20241121234357931](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241121234357931.png)

我们在根据某个搜索条件查找一些记录时为什么要遍历所有的数据页呢？因为各个页中的记录并没有规律，我们并不知道我们的搜索条件匹配哪些页中的记录，所以不得不依次遍历所有的数据页。所以如果我们想快速的定位到需要查找的记录在哪些数据页中该咋办？我们可以为快速定位记录所在的数据页而建立一个目录，建这个目录必须完成下边这些事：

- 下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值

![image-20241121234539179](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241121234539179.png)

![image-20241121234551448](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241121234551448.png)

![image-20241121234634182](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241121234634182.png)

![image-20241121234703794](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241121234703794.png)

- 给所有的页建立一个目录项

![image-20241121235009684](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241121235009684.png)

此时只知道这些数据时按照主键递增的，如果要查询c1=20的数据，那我们还是要从页10开始查找，比如说先在页10中通过二分查找（比顺序遍历效率高）就行查找，如果此时c1=20比页10中的数据都大，然后再去下一个页中进行查找，直到找到对应的值。（效率差）

![image-20241121235223114](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241121235223114.png)

![image-20241121235236446](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241121235236446.png)

以页28为例，它对应目录项2，这个目录项中包含着该页的页号28以及该页中用户记录的最小主键值5。我们只需要把几个目录项在物理存储器上连续存储（比如：数组），就可以实现根据主键值快速查找某条记录的功能了。比如：查找主键值为20的记录，具体查找过程分两步：

1.先从目录项中根据二分法快速确定出主键值为20的记录在目录项3中（因为12<20<209），它对应的页是页9。

2.再根据前边说的在页中查找记录的方式去页9中定位具体的记录。至此，针对数据页做的简易目录就搞定了。这个目录有一个别名，称为索引。



#### 3.InnoDB中的索引方案

①迭代1次：目录项纪录的页

上边称为一个简易的索引方案，是因为我们为了在根据主键值进行査找时使用 二分法快速定位具体的目录项而假
设所有目录项都可以在物理存储器上连续存储（即物理上连续），但是这样做有几个问题:

- InnoDB是使用页来作为管理存储空间的基本单位，最多能保证 16KB的连续存储空间，而随着表中记录数量的增多，需要 非常大的连续的存储空间 才能把所有的目录项都放下，这对记录数量非常多的表是不现实的。
- 我们时常会对 记录进行增删，假设我们把,页28 中的记录都删除了，那意味着 目录项2 也就没有存在的必要了，这就需要把目录项2后的目录项都向前移动一下，这样牵一发而动全身的操作效率很差。

所以，我们需要一种可以 灵活管理所有目录项 的方式。我们发现目录项其实长得跟我们的用户记录（数据记录，即上面存数据的页）差不多，只不过目录项中的两个列是主键 和 页号而已，为了和用户记录做一下区分，我们把这些用来表示目录项的记录称为目录项记录。那InnoDB怎么区分一条记录是普通的用户记录 还是 目录项记录.呢?使用记录头信息里的record_type 属性，它的各个取值代表的意思如下:

- 0:普通的用户记录
- 1:目录项记录
- 2:最小记录
- 3:最大记录

我们把前边使用到的目录项放到数据页中的样子就是这样：

![image-20241122000404514](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241122000404514.png)

从图中可以看出来，我们新分配了一个编号为30的页来专门存储目录项记录。这里再次强调目录项记录

和普通的用户记录的**不同点**：

- 目录项记录的record_type值是1，而普通用户记录的record_type值是0
- 目录项记录只有主键值和页的编号两个列，而普通的用户记录的列是用户自己定义的，可能包含很多列，另外还有InnoDB自己添加的隐藏列
- 了解：记录头信息里还有一个叫min_rec_mask的属性，只有在存储目录项记录的页中的主键值最小的目录项记录的min_rec_mask值为1，其他别的记录的min_rec_mask值都是0

**相同点：**两者用的是一样的数据页，都会为主键值生成PageDirectory（页目录），从而在按照主键值进行查找时可以使用二分法来加快查询速度。

现在以查找主键为20的记录为例，根据某个主键值去查找记录的步骤就可以大致拆分成下边两步：

- 先到存储目录项记录的页，也就是页30中根据页目录通过二分法快速定位到对应目录项，因为12<20<209，所以定位到对应的记录所在的页就是页9。
- 再到存储用户记录的页9中根据二分法快速定位到主键值为20的用户记录。

（一共需要两次磁盘IO，分别加载页30和页9）



②迭代2次：多个目录项纪录的页

虽然说 目录项记录 中只存储主键值和对应的页号，比用户记录需要的存储空间小多了，但是不论怎么说一个页只有16KB 大小，能存放的目录项记录也是有限的，那如果表中的数据太多，以至于一个数据页不足以存放所有的目录项记录，如何处理呢?
这里我们假设一个存储目录项记录的页最多只能存放4条目录项记录，所以如果此时我们再向上图中插入一条主键值为 320 的用户记录的话，那就需要分配一个新的存储目录项记录的页:

![image-20241122001220766](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241122001220766.png)

从图中可以看出，我们插入了一条主键值为320的用户记录之后需要两个新的数据页：

- 为存储该用户记录而新生成了页31。
- 因为原先存储目录项记录的页30的容量已满（我们前边假设只能存储4条目录项记录），所以不得需要一个新的页32来存放页31对应的目录项

现在因为存储目录项记录的页不止一个，所以如果我们想根据主键值查找一条用户记录大致需要3个步骤，以查找主键值为20的记录为例：

- 确定目录项记录页

我们现在的存储目录项记录的页有两个，即页30和页32，又因为页30表示的目录项的主键值的范围是[1,320)，页32表示的目录项的主键值不小于320，所以主键值为20的记录对应的目录项记录在页30中。

- 通过目录项记录页确定用户记录真实所在的页

在一个存储目录项记录的页中通过主键值定位一条目录项记录的方式说过了

- 在真实存储用户记录的页中定位到具体的记录



③迭代3次：目录项记录页的目录页

问题来了，在这个查询步骤的第1步中我们需要定位存储目录项记录的页，但是这些 页是不连续的，如果我们表中的数据非常多则会 产生很多存储目录项记录的页 ，那我们怎么根据主键值快速定位一个存储目录项记录的页呢?那就为这些存储目录项记录的页再生成一个 更高级的目录，就像是一个多级目录一样，大目录里嵌套小目录，小目录里才早实际的数据，所以现在各个页的示意图就是这样子：

如图，我们生成了一个存储更高级目录项的页33，这个页中的两条记录分别代表页30和页32，如果用![image-20241122001552671](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241122001552671.png)

如图，我们生成了一个存储更高级目录项的页33，这个页中的两条记录分别代表页30和页32，如果用户记录的主键值在[1,320)之间，则到页30中查找更详细的目录项记录，如果主键值不小于320的话，就到页32中查找更详细的目录项记录。

随着表中记录的增加，这个目录的层级会继续增加，如果简化一下，我们可以用下边这个图来描述它：

![image-20241122001631686](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241122001631686.png)

这个数据结构，它的名称是B+树。



④B+Tree

不论是存放用户记录 的数据页，还是存放 目录项记录 的数据页，我们都把它们存放到B+树这个数据结构中了，所以我们也称这些数据页为 节点。从图中可以看出，我们的实际用户记录其实都存放在B+树的最底层的节点上，这些节点也被称为 叶子节点，其余用来存放 目录项 的节点称为 非叶子节点或者 内节点，其中B+树最上边的那个节点也称为 根节点。

一个B+树的节点其实可以分成好多层，规定最下边的那层，也就是存放我们用户记录的那层为第8层之后依次往上加。之前我们做了一个非常极端的假设:存放用户记录的页 最多存放3条记录 ，存放目录项记录的页 最多存放4条记录 。其实真实环境中一个页存放的记录数量是非常大的，假设所有存放用户记录的叶子节点代表的数据页可以存放 100条用户记录 ，所有存放目录项记录的内节点代表的数据页可以存放 1000条目录项记录，那么:

- 如果B+树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放100条记录。

- 如果B+树有2层，最多能存放1000×100=10,0000条记录。
- 如果B+树有3层，最多能存放1000×1000×100=1,0000,0000条记录
- 如果B+树有4层，最多能存放1000×1000×1000×100=1000,0000,0000条记录。相当多的记录！！！

你的表里能存放100000000000条记录吗？所以一般情况下，我们用到的B+树都不会超过4层，那我们通过主键值去查找某条记录最多只需要做4个页面内的查找（查找3个目录项页和一个用户记录页），又因为在每个页面内有所谓的PageDirectory（页目录），所以在页面内也可以通过二分法实现快速定位记录。



#### 4.常见索引概念

索引按照物理实现方式，索引可以分为 2 种：聚簇（聚集）和非聚簇（非聚集）索引。我们也把非聚集索引称为二级索引或者辅助索引。

##### （1）聚簇索引

聚簇索引并不是一种单独的索引类型，而是一种数据存储方式(所有的用户记录都存储在了叶子节点)也就是所谓的索引即数据，数据即索引。（B+树的底层存储数据方式就是这样的，通过idb文件保存数据和索引，即所有的用户记录都存在了叶子节点，数据即索引，索引即数据。而MyISAM是通过myd和myc分别存储数据和索引）

术语“聚簇"表示数据行和相邻的键值聚簇的存储在一起。

**特点：**

1.使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：

- 数据存储在叶子节点中

- 页内 的记录是按照主键的大小顺序排成一个 单向链表

![image-20241123103439347](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241123103439347.png)

- 各个存放 用户记录的页 也是根据页中用户记录的主键大小顺序排成一个 双向链表

![image-20241123103828733](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241123103828733.png)

- 存放 目录项记录的页 分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个 双向链表 。当目录项超过一个后，会在上层继续生成一个目录项。

![image-20241123103917675](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241123103917675.png)

2.B+树的 叶子节点 存储的是完整的用户记录。

所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。

我们把具有这两种特性的B+树称为 聚簇索引，所有完整的用户记录都存放在这个 聚簇索引的叶子节点处。这种聚簇索引并不需要我们在MySQL语句中显式的使用 INDEX语句去创建， InnoD8 存储引擎会 自动 的为我们创建聚簇索引。

**优点：**

- 数据访问更快 ，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快。
- 聚簇索引对于主键的 排序查找 和 范围查找 速度非常快
- 按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多个数据块中提取数据，所以 节省了大量的io操作 。（如果数据都在一个页中，一次IO就可以了，但如果跨页了，还是要进行IO操作的）



**缺点：**

- 插入速度严重依赖于插入顺序 ，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列为主键
- 更新主键的代价很高 ，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义主键为不可更新

- 二级索引访问需要两次索引查找 ，第一次找到主键值，第二次根据主键值找到行数据



**限制：**

- 对于MySQL数据库目前只有InnoDB数据引擎支持聚簇索引，而MyISAM并不支持聚簇索引
- 由于数据物理存储排序方式只能有一种，所以每个MySQL的 表只能有一个聚簇索引。一般情况下就是该表的主键。
- 如果没有定义主键，Innodb会选择 非空的唯一索引代替。如果没有这样的索引，Iinnodb会隐式的定义一个主键来作为聚簇索引。
- 为了充分利用聚簇索引的聚簇的特性，所以innodb表的主键列尽量 选用有序的顺序id，而不建议用无序的id比如UUID、MD5、HASH、字符串列作为主键无法保证数据的顺序增长。



##### （2）非聚簇索引（二级索引、辅助索引）

上边介绍的 聚簇索引 只能在搜索条件是 主键值 时才能发挥作用，因为B+树中的数据都是按照主键进行排序的。那如果我们想以别的列作为搜索条件该怎么办呢?肯定不能是从头到尾沿着链表依次遍历记录一遍。
答案:我们可以 多建几棵B+树 ，不同的B+树中的数据采用不同的排序规则。比方说我们用 c2 列的大小作为数据页、页中记录的排序规则，再建一棵B+树，效果如下图所示:

![image-20241123105551817](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241123105551817.png)

**概念：回表** 我们根据这个以c2列大小排序的B+树只能确定我们要查找记录的主键值，所以如果我们想根据c2列的值查找到完整的用户记录的话，仍然需要到 聚簇索引 中再查一遍，这个过程称为 回表 。也就是根据c2列的值查询一条完整的用户记录需要使用到 2 棵B+树！

**问题：**为什么我们还需要一次 回表 操作呢？直接把完整的用户记录放到叶子节点不OK吗？

如果把完整的用户记录放到叶子节点是可以不用回表。但是 太占地方 了，相当于每建立一棵B+树都需要把所有的用户记录再都拷贝一遍，这就有点太浪费存储空间了、
因为这种按照 非主键列 建立的B+树需要一次回表操作才可以定位到完整的用户记录，所以这种B+树也被称为 二级索引(英文名 secondary index)，或者 辅助索引。由于我们使用的是c2列的大小作为B+树的排序规则，所以我们也称这个B+树是为c2列建立的索引。
非聚簇索引的存在不影响数据在聚簇索引中的组织，所以一张表可以有多个非聚簇索引。

![image-20241123105924314](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241123105924314.png)

小结: 聚簇索引与非聚簇索引的原理不同，在使用上也有一些区别:

1、聚簇索引的 叶子节点 存储的就是我们的 数据记录 ，非聚簇索引的叶子节点存储的是 数据位置。非聚簇索引不
会影响数据表的物理存储顺序。
2、一个表只能有一个聚簇索引，因为只能有一种排序存储的方式，但可以有 多个非聚簇索引，也就是多个索引目录提供数据检索。
3、使用聚簇索引的时候，数据的 査询效率高 但如果对数据进行插入，删除，更新等操作，效率会比非聚簇索引低。



##### （3）联合索引

我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让B+树按照 c2和c3列 的大小进行排序，这个包含两层含义：

- 先把各个记录和页按照c2列进行排序。

- 在记录的c2列相同的情况下，采用c3列进行排序

为c2和c3列建立的索引的示意图如下：

![image-20241123110113311](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241123110113311.png)

如图所示，我们需要注意以下几点:

- 每条 目录项记录 都由 c2、c3、页号 这三个部分组成，各条记录先按照c2列的值进行排序，如果记录的c2列相同，则按照c3列的值进行排序。
- B+树 叶子节点 处的用户记录由 c2、c3和主键c1列 组成。

注意一点，以c2和c3列的大小为排序规则建立的B+树称为 联合索引，本质上也是一个二级索引。它的意思与分别为c2和c3列分别建立索引的表述是不同的，不同点如下:

- 建立 联合索引 只会建立如上图一样的1棵B+树。
- 为c2和c3列分别建立索引会分别以c2和c3列的大小为排序规则建立2棵B+树。



#### 5.InnoDB的B+树索引的注意事项

##### （1）根页面位置万年不动

我们前边介绍B+树索引的时候，为了大家理解上的方便，先把存储用户记录的叶子节点都画出来，然后接着画存储目录项记录的内节点，实际上B+树的形成过程是这样的:

- 每当为某个表创建一个B+树索引(聚簇索引不是人为创建的，默认就有)的时候，都会为这个索引创建一个根节点页面。最开始表中没有数据的时候，每个B+树索引对应的 根节点中既没有用户记录，也没有目录项记录。

- 随后向表中插入用户记录时，先把用户记录存储到这个 根节点 中。

- 当根节点中的可用 空间用完时 继续插入记录，此时会将根节点中的所有记录复制到一个新分配的页，比如 页a中，然后对这个新页进行 页分裂的操作，得到另一个新页，比如页b。这时新插入的记录根据键值(也就是聚簇索引中的主键值，二级索引中对应的索引列的值)的大小就会被分配到 页a 或者 页b 中，而 根节点 便升级为存储目录项记录的页（非叶子节点）。

- 当随着插入用户记录越来越多，当目录项记录的页满之后，同理会将该目录项进行复制到一个新分配的页，然后对该新页进行页分类操作

  ![image-20241124154709020](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241124154709020.png)

这个过程特别注意的是:一个B+树索引的根节点自诞生之日起，便不会再移动。这样只要我们对某个表建立一个索引，那么它的根节点的页号便会被记录到某个地方，然后凡是 InnoDB 存储引擎需要用到这个索引的时候，都会从那个固定的地方取出根节点的页号，从而来访问这个索引。



##### （2）内节点中目录项记录的唯一性

我们知道B+树索引的内节点中目录项记录的内容是 索引列 +页号 的搭配，但是这个搭配对于二级索引来说有点儿不严谨。还拿 index_demo 表为例，假设这个表中的数据是这样的:

![image-20241124155024637](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241124155024637.png)如果二级索引中目录项记录的内容只是索引列 + 页号 的搭配的话，那么为 c2 列建立索引后的B+树应该长这样：

![image-20241124155052759](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241124155052759.png)

如果我们想新插入一行记录，其中c1、c2、c3的值分别是:9、1、'c'，那么在修改这个为c2列建立的级索引对应的B+树时便碰到了个大问题:由于 页3 中存储的目录项记录是由 c2列 + 页号 的值构成的，页3 中的两条目录项记录对应的c2列的值都是1，而我们 新插入的这条记录 的c2列的值也是1，那我们这条新插入的记录到底应该放到 页4 中，还是应该放到页5 中就不能确定了。

为了让新插入记录能找到自己在那个页里，我们需要保证在B+树的同一层内节点的目录项记录除页号这个字段以外是唯一的。所以对于二级索引的内节点的目录项记录的内容实际上是由三个部分构成的（本质上就是加上主键值后使其保证唯一）:

- 索引列的值
- 主键值
- 页号

也就是我们把 主键值 也添加到二级索引内节点中的目录项记录了，这样就能保证B+树每一层节点中各条目录项记录除页号这个字段外是唯一的，所以我们为c2列建立二级索引后的示意图实际上应该是这样子的:

![image-20241124155552428](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241124155552428.png)

这样我们再插入记录(9，1，'c')时，由于页3 中存储的目录项记录是由 c2列 + 主键 + 页号 的值构成的，可以先把新记录的 c2 列的值和 页3 中各目录项记录的 c2列的值作比较，如果 c2 列的值相同的话，可以接着比较主键值，因为B+树同一层中不同目录项记录的 c2列 + 主键 的值肯定是不一样的，所以最后肯定能定位唯一的一条目录项记录，在本例中最后确定新记录应该被插入到页5中。

##### （3）一个页面最少存储2条记录

一个B+树只需要很少的层级就可以轻松存储数亿条记录，查询速度相当不错!这是因为B+树本质上就是一个大的多层级目录，每经过一个目录时都会过滤掉许多无效的子目录，直到最后访问到存储真实数据的目录。那如果一个大的目录中只存放一个子目录是个啥效果呢?那就是目录层级非常非常非常多，而且最后的那个存放真实数据的目录中只能存放一条记录。费了半天劲只能存放一条真实的用户记录?所以InnoDB的一个数据页至少可以存放两条记录。或者说白了，至少要是一棵二叉树吧。

### 1.5 MyISAM中的索引方案

#### 1.存储引擎方案

| 索引/存储引擎        | **MyISAM** | **InnoDB** | **Memory** |
| -------------------- | ---------- | ---------- | ---------- |
| B-Tree索引（即B+树） | 支持       | 支持       | 支持       |

即使多个存储引擎支持同一种类型的索引，但是他们的实现原理也是不同的。Innodb和MyISAM默认的索引是Btree索引；而Memory默认的索引是Hash索引。

与Innodb的区别：

- MyISAM引擎使用B+Tree作为索引结构，叶子节点的data域存放的是数据记录的地址。

- Innodb的索引和数据都在.ibd文件中，MyISAM中通过.MYD存储数据，.MYI存储表索引，是分开的。



#### 2. MyISAM索引原理

我们知道 InnoDB中索引即数据，也就是聚簇索引的那棵B+树的叶子节点中已经把所有完整的用户记录都包含了而 MyISAM 的索引方案虽然也使用树形结构，但是却 将索引和数据分开存储:

- 将表中的记录 按照记录的插入顺序 单独存储在一个文件中，称之为数据文件。这个文件并不划分为若干个数据页，有多少记录就往这个文件中塞多少记录就成了。由于在插入数据的时候并 没有刻意按照主键大小排序，所以我们并不能在这些数据上使用二分法进行查找。
- 使用 MyISAM 存储引擎的表会把索引信息另外存储到一个称为 索引文件 的另一个文件中。 MISAM 会单独为表的主键创建一个索引，只不过在索引的叶子节点中存储的不是完整的用户记录，而是 主键值 + 数据记录地址的组合。

![image-20241124164628182](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241124164628182.png)

这里设表一共有三列，假设我们以col1为主键，上图是一个MyISAM表的主索引(Primary key)示意。可以看出*MyISAM的索引文件仅仅保存数据记录的地址*。在MyISAM中，主键索引和二级索引(Secondary key)在结构上没有任何区别，只是主键索引要求key是唯一的，而二级索引的key可以重复。如果我们在Col2上建立一个二级索引，则此索引的结构如下图所示:

![image-20241124164838391](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241124164838391.png)

同样也是一棵B+Tree，data域保存数据记录的地址。因此，MyISAM中索引检索的算法为:首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域 的值为地址，读取相应数据记录。





#### 3.MyISAM与InnoDB对比

**MyISAM**的索引方式都是“非聚簇”的，与**InnoDB**包含1个聚簇索引是不同的。

①在InnoDB存储引擎中，我们只需要根据主键值对聚簇索引进行一次查找就能找到对应的记录，而在MyISAM中却需要进行一次回表操作，意味着MyISAM中建立的索引相当于全部都是二级索引。

②InnoDB的数据文件本身就是索引文件，而MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。

③InnoDB的非聚簇索引data域存储相应记录主键的值，而MyISAM索引记录的是地址。换句话说，InnoDB的所有非聚簇索引都引用主键作为data域。

④MyISAM的回表操作是十分快速的，因为是拿着地址偏移量直接到文件中取数据的，反观InnoDB是通过获取主键之后再去聚簇索引里找记录，虽然说也不慢，但还是比不上直接用地址去访问。

⑤InnoDB要求表必须有主键（MyISAM可以没有，其不需要聚簇索引，所以无所谓）。如果没有显式指定，则MySQL系统会自动选择一个可以非空且唯一标识数据记录的列作为主键。如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整型。

小结：

了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助。比如
举例1:知道了InnoDB的索引实现后，就很容易明白 为什么不建议使用过长的字段作为主键，因为所有二级索引都引用主键索引，过长的主键索引会令二级索引变得过大。
举例2:用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一棵B+Tree，非单调的主键会造成在插入新记录时，数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。

![image-20241124171507363](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241124171507363.png)

### 1.6 索引代价

索引是个好东西，可不能乱建，它在空间和时间上都会有消耗：

- 空间上

每建立一个索引都要为它建立一棵B+树，每一棵B+树的每一个节点都是一个数据页，一个页默认会占用16KB的存储空间，一棵很大的B+树由许多数据页组成，那就是很大的一片存储空间。

- 时间上

每次对表中的数据进行增、删、改操作时，都需要去修改各个B+树索引。而且我们讲过，B+树每层节点都是按照索引列的值从小到大的顺序排序而组成了双向链表。不论是叶子节点中的记录，还是内节点中的记录（也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需要额外的时间进行一些记录移位，页面分裂、页面回收等操作来维护好节点和记录的排序。如果我们建了许多索引，每个索引对应的B+树都要进行相关的维护操作，会给性能拖后腿。

总结：一个表上索引建的越多，就会占用越多的存储空间，在增删改记录的时候性能就越差。为了能建立又好又少的索引，我们得学学这些索引在哪些条件下起作用的。



### 1.7 MySQL数据结构的选择

从MySQL的角度讲，不得不考虑一个现实问题就是磁盘IO（相较于算法层面上的时间复杂度，如O（n）、O（logn），内存中运行的速度很快，相差不大）。如果我们能让索引的数据结构尽量减少硬盘的 IO 操作，所消耗的时间也就越小。可以说，磁盘的I/O 操作次数 对索引的使用效率至关重要。
查找都是索引操作，一般来说索引非常大，尤其是关系型数据库，当数据量比较大的时候，索引的大小有可能几个G甚至更多，为了减少索引在内存的占用，数据库索引是存储在外部磁盘上的。当我们利用索引查询的时候，不可能把整个索引全部加载到内存，只能 逐一加载，那么MySQL衡量查询效率的标准就是磁盘IO次数。

#### 1. 全表扫描/遍历

先将索引加载到内存中，然后按照顺序对各个数据页中的数据进行遍历，直到找到对应的目标数据，需要经历大量的IO操作。

#### 2.Hash结构

**实现：**

Hash 本身是一个函数，又被称为散列函数，它可以帮助我们大幅提升检索数据的效率。

Hash 算法是通过某种确定性的算法(比如 MD5、SHA1、SHA2、SHA3)将输入转变为输出。 相同的输入永远可以得到相同的输出，假设输入内容有微小偏差，在输出中通常会有不同的结果。

举例:如果你想要验证两个文件是否相同，那么你不需要把两份文件直接拿来比对，只需要让对方把 Hash 函数计算得到的结果告诉你即可，然后在本地同样对文件进行 Hash 函数的运算，最后通过比较这两个 Hash 函数的结果是否相同，就可以知道这两个文件是否相同。



**加速查找速度的数据结构，常见的有两类：**

- 树，例如平衡二叉搜索树，查询/插入/修改/删除的平均时间复杂度都是O(log2N);
- 哈希，例如HashMap，查询/插入/修改/删除的平均时间复杂度都是O(1);

![image-20241124211750494](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241124211750494.png)

采用 Hash 进行检索效率非常高，基本上一次检索就可以找到数据，而 B+ 树需要自顶向下依次查找，多次访问节
点才能找到数据，中间需要多次I/O操作，从效率来说 Hash 比 B+ 树更快。
在哈希的方式下，一个元素k处于h(k)中，即利用哈希函数h，根据关键字k计算出槽的位置。函数h将关键字域映射到哈希表T[0...m-1]的槽位上。

![image-20241124211930470](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241124211930470.png)

上图中哈希函数h有可能将两个不同的关键字映射到相同的位置，这叫做 碰撞 ，在数据库中一般采用 链接法 来解决。在链接法中，将散列到同一槽位的元素放在一个链表中，如下图所示：

![image-20241124211942954](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241124211942954.png)



**Hash弊端（结构效率高，为什么索引结构不优先选择）：**

- Hash 索引仅能满足(=)(<>)和 IN 查询。如果进行 范围査询，哈希型的索引，时间复杂度会退化为O(n);而树型的“有序”特性，依然能够保持O(log2N) 的高效率
- Hash 索引还有一个缺陷，数据的存储是 没有顺序的，在 ORDER BY的情况下，使用 Hash 索引还需要对数据重新排序。
- 对于联合索引的情况，Hash 值是将联合索引键合并后一起来计算的，无法对单独的一个键或者几个索引键进行查询。
- 对于等值查询来说，通常 Hash 索引的效率更高，不过也存在一种情况，就是 索引列的重复值如果很多，效率就会降低 。这是因为遇到 Hash 冲突时，需要遍历桶中的行指针来进行比较，找到查询的关键字，非常耗时。所，Hash 索引通常不会用到重复值多的列上，比如列为性别、年龄的情况等。



**Hash索引适用存储引擎如表所示：**

| **索引** **/** **存储引擎** | **MyISAM** | **InnoDB** | **Memory** |
| --------------------------- | ---------- | ---------- | ---------- |
| HASH索引                    | 不支持     | 不支持     | 支持       |



**Hash索引的适用性：**

Hash 索引存在着很多限制，相比之下在数据库中 B+ 树索引的使用面会更广，不过也有一些场景采用 Hash 索引效率更高，比如在键值型(Key-Value)数据库中，Redis 存储的核心就是 Hash 表。
MySQL 中的 Memory 存储引擎支持 Hash 存储，如果我们需要用到査询的临时表时，就可以选择 Memory 存储引擎，把某个字段设置为 Hash 索引，比如字符串类型的字段，进行 Hash 计算之后长度可以缩短到几个字节。当字段的重复度低，而且经常需要进行 等值查询的时候，采用 Hash 索引是个不错的选择。
另外，InnoDB本身不支持Hash索引，但是提供自适应 Hash 索引(Adaptive Hash Index)。什么情况下才会使用自适应 Hash 索引呢?如果某个数据经常被访问，当满足一定条件的时候，就会将这个数据页的地址存放到Hash 表中。这样下次査询的时候，就可以直接找到这个页面的所在位置。这样让 B+ 树也具备了 Hash 索引的优点。

![image-20241124212711598](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241124212711598.png)

采用自适应 Hash 索引目的是方便根据 SQL 的查询条件加速定位到叶子节点，特别是当 B+ 树比较深的时候，通过自适应 Hash 索引可以明显提高数据的检索效率。

我们可以通过 innodb_adaptive_hash_index 变量来查看是否开启了自适应 Hash，比如：

```mysql
mysql> show variables like '%adaptive_hash_index';
```

![image-20241124212740576](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241124212740576.png)



#### 3.二叉搜索树

**特点**

- 一个节点只能有两个子节点，也就是一个节点度不能超过2
- 左子节点<本节点   右子节点 >= 本节点，比我大的向右，比我小的向左



**查找规则**

我们先来看下最基础的二叉搜索树(Binary Search Tree)，搜索某个节点和插入节点的规则一样，我们假设搜索插入的数值为 key:

- 如果 key 大于根节点，则在右子树中进行查找;

- 如果 key 小于根节点，则在左子树中进行查找;
- 如果 key 等于根节点，也就是找到了这个节点，返回根节点即可;

举个例子，我们对数列(34，22，89，5，23，77，91)创造出来的二分查找树如下图所示:

![image-20241124213732608](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241124213732608.png)

但是存在特殊的情况，就是有时候二叉树的深度非常大。比如我们给出的数据顺序是(5,22,23,34,77,89,91)，创造出来的二分搜索树如下图所示:

![image-20241124213751206](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241124213751206.png)

上面第二棵树也属于二分查找树，但是性能上已经退化成了一条链表，查找数据的时间复杂度变成了O(n)。你能看出来第一个树的深度是3，也就是说最多只需3次比较，就可以找到节点，而第二个树的深度是7，最多需要7次比较才能找到节点。
为了提高查询效率，就需要 减少磁盘IO数 。为了减少磁盘IO的次数，就需要尽量 降低树的高度，需要把原来“瘦高”的树结构变的“矮胖”，树的每层的分又越多越好。



#### 4.平衡二叉树（AVL树）

为了解决上面二叉查找树退化成链表的问题，人们提出了平衡二叉搜索树(Balanced Binary Tree)，又称为AVL树(有别于AVL算法)，它在二叉搜索树的基础上增加了约束，具有以下性质:
它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。
这里说一下，常见的平衡二叉树有很多种，包括了平衡二叉搜索树、 红黑树 、数堆、伸展树。平衡二叉搜索树是最早提出来的自平衡二叉搜索树，当我们提到平衡二叉树时一般指的就是平衡二叉搜索树。事实上，第一棵树就属于平衡二叉搜索树，搜索时间复杂度就是O(log2n)。
数据查询的时间主要依赖于磁盘IO的次数，如果我们采用二叉树的形式，即使通过平衡二叉搜索树进行了改进，树的深度也是 O(log2n)，当n比较大时，深度也是比较高的，比如下图的情况:

![image-20241124214219841](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241124214219841.png)

每访问一次节点就需要进行一次磁盘 I/O操作 ，对于上面的树来说，我们需要进行5次 IO 操作。虽然平衡二叉树的效率高，但是树的深度也同样高，这就意味着磁盘 IO操作次数多，会影响整体数据査询的效率。针对同样的数据，如果我们把二又树改成 M 又树 (M>2)呢?当 M=3 时，同样的 31个节点可以由下面的三叉树来进行存储:

![image-20241124214311715](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241124214311715.png)

你能看到此时树的高度降低了，当数据量 N大的时候，以及树的分叉数 M 大的时候，M 叉树的高度会远小于二叉树的高度(M>2)。所以，我们需要把 树从“瘦高"变“矮胖”。



#### 5.B-Tree

B 树的英文是 Balance Tree，也就是 多路平衡査找树。简写为B-Tree (注意横杠表示这两个单词连起来的意思，不是减号)。它的高度远小于平衡二叉树的高度。（每一个结点存储多个数据，相较于B+树，非叶子节点页存储数据）

B 树的结构如下图所示：

图示1：

![image-20241124215437883](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241124215437883.png)

图示2：

如小于17的都放在磁盘块2中，在17和35中间的，放在磁盘块3中，比35打的放在磁盘块4中。

![image-20241124214503397](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241124214503397.png)

B树作为多路平衡査找树，它的每一个节点最多可以包括 M个子节点，M 称为 8 树的阶。每个磁盘块中包括了关键字 和 子节点的指针。如果一个磁盘块中包括了x个关键字，那么指针数就是 x+1。对于一个 100 阶的 B树来说，如果有3层的话最多可以存储约 100万的索引数据。对于大量的索引数据来说，采用B树的结构是非常适合的，因为树的高度要远小于二叉树的高度。



**一个 M 阶的 B 树（M>2）有以下的特性：**

- 根节点的儿子数的范围是 [2,M]

- 每个中间节点包含 k-1 个关键字和 k 个孩子，孩子的数量 = 关键字的数量 +1，k 的取值范围为[ceil(M/2), M]。

- 叶子节点包括 k-1 个关键字（叶子节点没有孩子），k 的取值范围为 [ceil(M/2), M]

- 假设中间节点节点的关键字为：Key[1], Key[2], …, Key[k-1]，且关键字按照升序排序，即 Key[i]

  <Key[i+1]。此时 k-1 个关键字相当于划分了 k 个范围，也就是对应着 k 个指针，即为：P[1], P[2], …,

  P[k]，其中 P[1] 指向关键字小于 Key[1] 的子树，P[i] 指向关键字属于 (Key[i-1], Key[i]) 的子树，P[k]

  指向关键字大于 Key[k-1] 的子树。

- 所有叶子节点位于同一层

上面那张图所表示的 B 树就是一棵 3 阶的 B 树。我们可以看下磁盘块 2，里面的关键字为（8，12），它有 3 个孩子 (3，5)，(9，10) 和 (13，15)，你能看到 (3，5) 小于 8，(9，10) 在 8 和 12 之间，而 (13，15)大于 12，刚好符合刚才我们给出的特征。

然后我们来看下如何用 B 树进行查找。假设我们想要 查找的关键字是 9 ，那么步骤可以分为以下几步：

- 我们与根节点的关键字 (17，35）进行比较，9 小于 17 那么得到指针 P1；
- 按照指针 P1 找到磁盘块 2，关键字为（8，12），因为 9 在 8 和 12 之间，所以我们得到指针 P2；
- 按照指针 P2 找到磁盘块 6，关键字为（9，10），然后我们找到了关键字 9；

你能看出来在 B 树的搜索过程中，我们比较的次数并不少，但如果把数据读取出来然后在内存中进行比较，这个时间就是可以忽略不计的。而读取磁盘块本身需要进行 I/O 操作，消耗的时间比在内存中进行比较所需要的时间要多，是数据查找用时的重要因素。 B 树相比于平衡二叉树来说磁盘 I/O 操作要少 ，在数据查询中比平衡二叉树效率要高。所以 只要树的高度足够低，IO次数足够少，就可以提高查询性能 。



**总结：**

- B树在插入和删除节点的时候如果导致树不平衡，就通过自动调整节点的位置来保持树的自平衡。
- 关键字集合分布在整棵树中,即叶子节点和非叶子节点都存放数据。搜索有可能在非叶子节点结束
- 其搜索性能等价于在关键字全集内做一次二分查找。





#### 6.B+Tree

B+树也是一种多路搜索树，基于B树做出了改进，主流的DBMS都支持B+树的索引方式，比如MySQL。相比于B-Tree，B+Tree适合文件索引系统。

![image-20241124215637529](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241124215637529.png)



**B+** **树和** **B** **树的差异：**

- B+树中有 k 个孩子的节点就有 k 个关键字。也就是孩子数量 = 关键字数，而 B 树中，孩子数量 = 关键字数+1。

- B+树中非叶子节点的关键字会同时存在在子节点中，并且是在子节点中所有关键字的最大（或最小）。B树的则不会

  ![image-20241124220009261](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241124220009261.png)

- B+树非叶子节点仅用于索引，不保存数据记录，跟记录有关的信息都放在叶子节点中。而 B 树中， 非叶子节点既保存索引，也保存数据记录 。

- B+树的所有关键字都在叶子节点出现，叶子节点构成一个有序链表，而且叶子节点本身按照关键字的大小从小到大顺序链接。B树的部分关键字是存放在非叶子节点中的，而不是都在叶子结点中。



**示例：**

下图就是一棵 B+ 树，阶数为 3，根节点中的关键字 1、18、35 分别是子节点(1，8，14)，(18，24，31)和(35，41，53)中的最小值。每一层父节点的关键字都会出现在下一层的子节点的关键字中，因此在叶子节点中包括了所有的关键字信息，并且每一个叶子节点都有一个指向下一个节点的指针，这样就形成了一个链表。

![image-20241124220302913](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241124220302913.png)

比如，我们想要查找关键字 16，B+树会自顶向下逐层进行查找:

- 与根节点的关键字(1，18，35)进行比较，16在1和18 之间，得到指针 P1(指向磁盘块 2)
- 找到磁盘块 2，关键字为(1，8，14)，因为 16 大于 14，所以得到指针P3(指向磁盘块 7)
- 找到磁盘块 7，关键字为(14，16，17)，然后我们找到了关键字 16，所以可以找到关键字 16 所对应的数据。

![image-20241124220351897](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241124220351897.png)

![image-20241124220417183](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241124220417183.png)

B 树和 B+ 树都可以作为索引的数据结构，在 MySQL 中采用的是 B+ 树。但B树和B+树各有自己的应用场景，不能说B+树完全比B树好，反之亦然。



#### 7. R树

R-Tree在MySQL很少使用，仅支持 geometry数据类型 ，支持该类型的存储引擎只有myisam、bdb、innodb、ndb、archive几种。举个R树在现实领域中能够解决的例子：查找20英里以内所有的餐厅。如果没有R树你会怎么解决？一般情况下我们会把餐厅的坐标(x,y)分为两个字段存放在数据库中，一个字段记录经度，另一个字段记录纬度。这样的话我们就需要遍历所有的餐厅获取其位置信息，然后计算是否满足要求。如果一个地区有100家餐厅的话，我们就要进行100次位置计算操作了，如果应用到谷歌、百度地图这种超大数据库中，这种方法便必定不可行了。R树就很好的 解决了这种高维空间搜索问题 。它把B树的思想很好的扩展到了多维空间，采用了B树分割空间的思想，并在添加、删除操作时采用合并、分解结点的方法，保证树的平衡性。因此，R树就是一棵用来 存储高维数据的平衡树 。相对于B-Tree，R-Tree的优势在于范围查找。

![image-20241124223041571](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241124223041571.png)



#### 8.其他思考

（1）为了减少IO，索引树会一次性加载吗？

- 数据库索引是存储在磁盘上的，如果数据量很大，必然导致索引的大小也会很大，超过几个G
- 当我们利用索引查询时候，是不可能将全部几个G的索引都加载进内存的，我们能做的只能是:逐一加载每一个磁盘页，因为磁盘页对应着索引树的节点。、

（2）B+树的存储能力如何？为何说一般查找行记录，最多只需1~3次磁盘IO

InnoDB 存储引擎中页的大小为 16KB，一般表的主键类型为INT(占用4个字节)或 BIGINT(占用8个字节)，指针类型也一般为4或8个字节，也就是说一个页(B+Tree 中的一个节点)中大概存储16KB/(8B+8B)=1K 个键值(因为是估值，为方便计算，这里的K取值为 10^3。也就是说一个深度为3的B+Tree 索引可以维护 10^3×10^3×10^3=10 亿条记录（叶子节点的数据数量等于非叶子节点数量和，三层的情况下，所以梳理计算如上所示）。(这里假定一个数据页也存储10^3条行记录数据了）
实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree的高度一般都在 2~4 层。MySQL 的InnoDB 存储引擎在设计时是将根节点常驻内存的（因为根页面位置万年不动），也就是说查找某一键值的行记录时最多只需要 1~3 次磁盘I/O操作。

（3）B+树比B-树更适合实际应用中操作系统的文件索引和数据库索引

- B+树的磁盘读写代价更低B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。
- B+树的查询效率更加稳定
  由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。

（4）Hash 索引与 B+ 树索引的区别

![image-20241124222748421](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241124222748421.png)

（5）Hash索引与*B+ 树索引是在建索引的时候手动指定的吗

![image-20241124222830188](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241124222830188.png)



#### 9.算法时间复杂度

![image-20241124223113416](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241124223113416.png)



## 二、索引分类

### 2.1 按照功能分类

按照功能分类，可以将索引分为主键索引、唯一索引、普通索引、全文索引、组合索引以及空间索引：

- 主键索引（Primary Key Index）

  列值唯一，且不可以为NULL值。

  由于InnoDB是基于聚簇索引存储，因此它需要一个主键标识符来组织数据。如果建表的时候没有显示地指定主键，则会使用第一非空的唯一索引（注：唯一索引是可以有null值，但是其他非null的值必须唯一，不重复，这里需要满足两个条件一个是非空，即不为null，另一个是唯一索引即值唯一，正是主键索引的特点）作为主键，如果表中没有主键也没有唯一的非空索引列，则会创建一个6字节的自增隐藏主键，即row_id作为主键，该隐藏注解无法被用户直接访问。

- 唯一索引（Unique Index）

  索引列的值必须唯一，但允许有空值（null值）。若是组合索引，则列值的组合必须唯一。主键索引是一种特殊的唯一索引，不允许有空值。

- 普通索引（Normal/Non-Unique Index）

  基本索引类型，允许在定义索引的列中插入重复值和空值。

- 全文索引（Fulltext Index）

  对文本的内容进行分词后，进行搜索。目前只有 `CHAR`、`VARCHAR` ，`TEXT` 列上可以创建全文索引，允许在这些索引列中插入重复值和空值。一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch等搜索引擎代替。

- 组合索引/联合索引（Composite Index）

  组合索引指在表的多个字段组成的索引，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用（即遵循最左前缀集合）。专门用于组合搜索，其效率大于索引合并（查询时能够使用多个单列索引（而不是组合索引）的组合来优化查询）

- 空间索引（SPATIAL）

  空间索引是对空间数据类型的字段建立的索引，MySQL中的空间数据类型有4种，分别是GEOMETRY、POINT、LINESTRING和POLYGON。MySQL使用SPATIAL关键字进行扩展，使得能够用于创建正规索引类似的语法创建空间索引。创建空间索引的列必须声明为NOT NULL。目前只有MyISAM存储引擎支持空间检索，而且索引的字段不能为空值

### 2.2 按照物理实现分类

按照物理实现分类，可以将索引分为聚簇索引和非聚簇索引两种：

- 聚簇索引

  聚簇索引将数据行的物理顺序与索引的顺序相同，即数据存储本身就是按照索引的顺序排列。这意味着一个表只能有一个聚簇索引，因为数据行只能按照一种顺序存储。在InnoDB存储引擎中，主键默认是聚簇索引。如果没有显式定义主键，InnoDB会选择一个唯一非空索引作为聚簇索引。索引结构和数据一起存放的索引，InnoDB 中的主键索引就属于聚簇索引

- 非聚簇索引

  非聚簇索引创建一个单独的索引结构，该结构存储索引列的值和指向实际数据行的指针（通常是行ID，即主键id）。数据行的物理顺序与索引顺序无关。一个表可以有多个非聚簇索引，因为数据行的存储顺序不受影响。非聚簇索引在查找时需要访问两次：第一次查找索引，第二次通过指针访问数据行（即回表，去聚簇索引上进行查找）。对于某些查询（尤其是只需访问非索引列的查询，需要回表，无法索引覆盖），可能效率较低。索引结构和数据分开存放的索引，二级索引(辅助索引)就属于非聚簇索引。MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引。

### 2.3 按照作用字段个数分类

按照物理实现分类，可以将索引分为单列索引和联合/组合索引两种：

- 单列索引

  一个列作为一个索引。

- 组合索引

  多个列构成一个索引。

### 2.4 按照数据结构分类

- BTree 索引：MySQL 里默认和最常用的索引类型。只有叶子节点存储 value，非叶子节点只有指针和 key。存储引擎 MyISAM 和 InnoDB 实现 BTree 索引都是使用 B+Tree，但二者实现方式不一样（前面已经介绍了）。
- 哈希索引：类似键值对的形式，一次即可定位。
- RTree 索引：一般不会使用，仅支持 geometry 数据类型，优势在于范围查找，效率较低，通常使用搜索引擎如 ElasticSearch 代替。
- 全文索引：对文本的内容进行分词，进行搜索。目前只有 `CHAR`、`VARCHAR` ，`TEXT` 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替。

对于不同存储引擎支持的索引类型不一样，如下所示

- InnoDB： 支持 B-tree、Full-text 等索引，不支持 Hash索引；

- MyISAM ： 支持 B-tree、Full-text 等索引，不支持 Hash 索引； 

- Memory ： 支持 B-tree、Hash 等索引，不支持 Full-text 索引；

- NDB ： 支持 Hash 索引，不支持 B-tree、Full-text 等索引； 

- Archive ： 不支持 B-tree、Hash、Full-text 等索引；



## 三、索引操作

在创建表的定义语句`CREATE TABLE`中指定索引列，使用`ALTER TABLE`语句在存在的表上创建索引，或者使用`CREATE INDEX`语句在已存在的表上添加索引。

### 3.1 创建表时创建索引

#### 1. 隐式方式创建索引（约束）

使用CREATE TABLE创建表时，除了可以定义列的数据类型外，还可以定义主键约束、外键约束或者唯一性约束，而不论创建哪种约束，在定义约束的同时相当于在指定列上创建了一个索引。

示例：

```mysql
CREATE TABLE dept(
dept_id INT PRIMARY KEY AUTO_INCREMENT,	# 主键约束创建唯一索引
dept_name VARCHAR( 20 )
);

CREATE TABLE emp(
emp_id INT PRIMARY KEY AUTO_INCREMENT,	# 主键约束创建唯一索引
emp_name VARCHAR( 20 ) UNIQUE,	# 唯一约束创建唯一索引（字段名即为索引名称）
dept_id INT,
CONSTRAINT emp_dept_id_fk FOREIGN KEY(dept_id) REFERENCES dept(dept_id)	# 外键约束创建普通索引
);
```

#### 2.显示方式创建索引

##### （1）显示声明语句：

```mysql
CREATE TABLE table_name [col_name data_type]
[UNIQUE | FULLTEXT | SPATIAL][INDEX |KEY][index_name] (col_name [length]) [ASC | DESC]
```

参数说明：

- UNIQUE、FULLTEXT和SPATIAL为可选参数，分别表示唯一索引、全文索引和空间索引；
- INDEX与KEY为同义词，两者的作用相同，用来指定创建索引；
- index_name指定索引的名称，为可选参数，如果不指定，那么MySQL默认col_name为索引名；
- col_name为需要创建索引的字段列，该列必须从数据表中定义的多个列中选择；
- length为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度；
- ASC或DESC指定升序或者降序的索引值存储。

##### （2）查看索引

除了通过UI的方式查看创建的索引外，我们还可以通过如下命令的方式查看

```mysql
# 方式1
show  create table [tableName] \G
# 方式2
show index from [tableName];
```

##### （3）创建普通索引

```mysql
CREATE TABLE book (
    book_id INT ,
    book_name VARCHAR (100) ,
    AUTHORS VARCHAR (100) ,
    info VARCHAR(100) ,
    COMMENT VARCHAR (100) ,
    year_publication YEAR,
    #声明索引
	INDEX idx_bname (book_name));
```

##### （5）主键索引

主键可以直接在列定义中定义，也可以通过表约束的方式定义

设定为主键后数据库会自动建立索引（innodb为聚簇索引）

方式一

```mysql
CREATE TABLE emp (
    emp_id INT NOT NULL PRIMARY KEY,  -- 在列定义中直接指定主键
    emp_name VARCHAR(20) UNIQUE,
    dept_id INT
);
```

方式二

```mysql
CREATE TABLE emp (
    emp_id INT NOT NULL,
    emp_name VARCHAR(20) UNIQUE,
    dept_id INT,
    PRIMARY KEY (emp_id)  -- 使用表约束定义主键
);
```

如果需要删除主键索引，可以使用如下命令

```mysql
ALTER TABLE [tableName] drop PRIMARY KEY ;
```

修改主键索引：必须先删除掉(drop)原索引，再新建(add)索引

##### （6）组合/联合索引

```mysql
# 创建唯一索引
CREATE TABLE book (
    book_id INT ,
    book_name VARCHAR (100) ,
    author VARCHAR (100) ,
    #声明索引
	INDEX union_key_ba (book_name,author))
;
```

##### （7）全文索引

方式一

在表中的info字段上建立全文索引

```mysql
CREATE TABLE test4(
    id INT NOT NULL,
    name CHAR(30) NOT NULL,
    age INT NOT NULL,
    info VARCHAR(255),
    FULLTEXT INDEX futxt_idx_info(info)
) ENGINE=MyISAM;	#在MySQL5.7及之后版本中可以不指定最后的ENGINE了，因为在此版本中InnoDB支持全文索引。
```

方式二

创建了一个给title和body字段添加全文索引的表（省略索引名，默认名称的格式一般为 `table_name_column_name1_column_name2`）。

```mysql
CREATE TABLE articles (
    id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    title VARCHAR (200),
    body TEXT,
    FULLTEXT index (title, body)
) ENGINE = INNODB ;
```

方式三

```mysql
CREATE TABLE `papers` (
    `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
    `title` varchar(200) DEFAULT NULL,
    `content` text,
    PRIMARY KEY (`id`),
    FULLTEXT KEY `title` (`title`,`content`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;
```



全文索引检索的方式不同于like查询

```
SELECT * FROM papers WHERE content LIKE ‘%查询字符串%’;
```

而是通过match+against方式进行查询

```
SELECT * FROM papers WHERE MATCH(title,content) AGAINST (‘查询字符串’);
```

注意：

1. 使用全文索引前，搞清楚版本支持情况；
2. 全文索引比 like + % 快 N 倍，但是可能存在精度问题；
3. 如果需要全文索引的是大量数据，建议先添加数据，再创建索引（避免建立索引结构后，对数据修改后，频繁修改索引结构）。

##### （8）空间索引

空间索引创建中，要求空间类型的字段必须为 非空 。

创建表test5，在空间类型为GEOMETRY的字段上创建空间索引，SQL语句如下：

```mysql
CREATE TABLE test5(
    geo GEOMETRY NOT NULL,
    SPATIAL INDEX spa_idx_geo(geo)
) ENGINE=MyISAM;
```



### 3.2 在已经存在的表上创建索引

在已经存在的表中创建索引可以使用ALTER TABLE语句或者CREATE INDEX语句。

#### 1.使用ALTER TABLE语句创建索引

```mysql
ALTER TABLE table_name ADD [UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY]
[index_name] (col_name[length],...) [ASC | DESC]
```

#### 2.使用CREATE INDEX创建索引

```mysql
CREATE [UNIQUE | FULLTEXT | SPATIAL] INDEX index_name
ON table_name (col_name[length],...) [ASC | DESC]
```



### 3.3 删除索引

#### 1.使用ALTER TABLE删除索引

```mysql
ALTER TABLE table_name DROP INDEX index_name;
```

#### 2.使用DROP INDEX语句删除索引

```mysql
DROP INDEX index_name ON table_name;
```

注意：删除表中的列时，如果要删除的列为索引的组成部分，则该列也会从索引中删除。如果组成索引的所有列都被删除，则整个索引将被删除。



## 四、索引设计原则

### 4.1 索引适用情况

#### 1、字段的数值有唯一性限制/约束

索引本身可以起到约束的作用（唯一索引：优化查询性能，确保唯一性；唯一约束：确保表中的数据唯一，不重复），如唯一索引、主键索引都是可以起到唯一性约束的，因此在数据表中如果为有唯一性限制的字段创建唯一性索引或者主键索引，除了保证数据唯一的情况下，还可以更快速地通过该索引来确定某条记录。

alibaba规范中提到：业务上具有唯一特性的字段，即是是组合字段也必须建成唯一索引。即是建立唯一索引后，在维护过程中可能会影响insert速度，但是这个速度损耗可以忽略，但其塔高查找速度是很明显的（如在B+树上搜索的时候只需要定位一条即可，不用去前后查找相同数据，因为其是唯一的）



#### 2、频繁作为Where查询条件的字段

某个字段在SELECT语句的 WHERE 条件中经常被使用到，那么就需要给这个字段创建索引了。尤其是在数据量大的情况下，创建普通索引就可以大幅提升数据查询的效率。



#### 3、使用Group by 和 order by的列

索引会让数据按照某种顺序进行存储或检索，因此当使用 GROUP BY 对数据进行分组查询（加了索引，相同的数据都在一块），或者使用 ORDER BY 对数据进行排序的时候（加了索引数据都是有序的），就需要对分组或者排序的字段进行索引 。如果待排序的列有多个，那么可以在这些列上建立组合索引 。

特殊例子：

当同时存在group by 和order by的情况（以下sql需要设置sql_mode，去掉ONLY_FULL_GROUP_BY），如下

```mysql
select student_id, count(*) from table
group by student_id
order by create_time desc
limit 100
```

创建索引的方式

① 分别为student_id 和 create_time  创建索引

```mysql
alter table table add index idx_student_id(student_id)
alter table table add index idx_create_time(create_time)
```

实际使用的是student_id对应的索引，因为执行顺序是先group by再order by。

② 为student_id 和 create_time 创建联合索引

创建方式一

```mysql
 alter table student_info
 add index idx_sid_cre_time(student_id, create_time desc)
 # desc 在8.0有效，5.7版本无效，可见一种的mysql新特性
```

实际使用的是该联合索引，性能相较于①更快

创建方式二：顺序修改

```mysql
 alter table student_info
 add index idx_sid_cre_time(create_time desc, student_id)
```

如果在方式一的前提下，又加了一个方式二的联合索引，使用的还是方式一的，因为select执行顺序是先group by再order by。并且如果只有方式二索引，和①中的索引条件下，会优先使用idx_student_id索引，还是和执行顺序有关，先执行group by student_id的时候，去看有没有对应的索引，即找到了idx_student_id索引。

综上，如果既有group by 和order by，建议场景联合索引，把group by的字段写在联合索引前，order by的字段写在联合索引后，其效率是以最高的。



#### 4、UPDATE、DELETE的Where条件列

对数据按照某个条件进行查询后再进行 UPDATE 或 DELETE 的操作，如果对 WHERE 字段创建了索引，就

能大幅提升效率。原理是因为我们需要先根据 WHERE 条件列检索出来这条记录，然后再对它进行更新或

删除。如果进行更新的时候，更新的字段是非索引字段，提升的效率会更明显，这是因为非索引字段更

新不需要对索引进行维护。



#### 5、为DISTINCT字段创建索引

有时候我们需要对某个字段进行去重，使用 DISTINCT，那么对这个字段创建索引，也会提升查询效率。因

为索引会对数据按照某种顺序进行排序，所以在去重的时候也会快很多



#### 6、多表join连接操作

- 连接表的数量尽量不要超过 3 张 ，因为每增加一张表就相当于增加了一次嵌套的循环，数量级增

长会非常快，严重影响查询的效率。

-  对 WHERE 条件创建索引 ，因为 WHERE 才是对数据条件的过滤。如果在数据量非常大的情况下，

没有 WHERE 条件过滤是非常可怕的（通过索引去过滤数据，而不是全表扫描）

- 对用于连接的字段创建索引 ，并且该字段在多张表中的 类型必须一致 。比如 course_id 在

student_info 表和 course 表中都为 int(11) 类型，而不能一个为 int 另一个为 varchar 类型（其中会设计到隐式转换，即函数调用，从而造成索引失效）



#### 7、使用列类型效的字段创建索引

这里的类型大小指的就是该类型表示的数据范围大小。

数据类型越小，在查询时进行的比较操作越快；数据类型越小，索引占用的存储空间就越小，在一个数据页内就可以放下更多记录，从而减少磁盘I/O带来的性能损耗，也就意味着可以把更多的数据页缓存在内存页中，从而加快读锁页效率。对于表的主键更加适用，因为不仅是聚簇索引索引中会存储主键值，其他所有的二级索引的叶子节点处都会存储一份记录的主键值，如果主键使用更小的数据类型，也就意味节省更多的存储空间和更高效的I/O。



#### 8、使用字符串前缀创建索引

如果一个字段是字符串类型，并且字符串的长度很长，那么存储一个字符串就需要占用很大的存储空间。如果我们需要在字符串列建立索引，在对应的B+树中会存在两个问题：

- B+树索引中的记录如果把该字符串列的完整字符串存储起来，构建时十分费时，并且字符串越长，在索引中占用的存储空间就越大（二级索引中，无论是叶子节点还是中间节点都会涉及到该索引值的存储，需要占用更多的空间，并且如果是主键的话，那就聚簇索引和二级索引都会占用空间）
- 如果B+树索引中索引列存储的字符串很长，那在做字符串比较时就会占用更多的时间（因为字符串的比较在相同长度的情况下，会从头到尾比较）

针对上述问题，可以通过截取字段的前面一部分内容建立索引，这被称为前缀索引。这样在查找记录时虽然不能精确的定位到记录的位置，但是能定位到相应前缀所在的位置，然后根据前缀相同的记录的主键值回表查询完整的字符串值。即节约了空间，又减少了字符串的比较时间。

那么又有一个问题，截取多少合适？截取多了，达不到节省索引存储空间的目的，截取的少了，重复内容太多，字段的散列度（选择性）会降低，会增加更大的回表操作，增加IO操作次数。

计算选择性的公式如下所示

```mysql
select count(distinct left(列名，索引长度)) / count(*)
```

通过不同长度去计算，与全表的选择性对比,竟可能让选择性接近1，例如

```mysql
select count(distinct left(address,10)) / count(*) as sub10, -- 截取前10个字符的选择度
count(distinct left(address,15)) / count(*) as sub11, -- 截取前15个字符的选择度
count(distinct left(address,20)) / count(*) as sub12, -- 截取前20个字符的选择度
count(distinct left(address,25)) / count(*) as sub13 -- 截取前25个字符的选择度
```

引申另一个问题：索引列前缀对排序的影响

如果使用了索引列前缀，比方说前边只把address列的 前12个字符 放到了二级索引中，下边这个查询可能就有点儿尴尬了:

```
SELECT * FROM shop
ORDER BY address
LIMIT 12;
```

因为二级索引中不包含完整的address列信息，所以无法对前12个字符相同，后边的字符不同的记录进行排序，也就是使用索引列前缀的方式 无法支持使用索引排序 ，只能使用文件排序。

拓展：Alibaba《Java开发手册》

【强制】在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度。
说明:索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为20的索引，区分度会 高达 98%以可以使用 count(distinct left(列名,索引长度))/count(*)的区分度来确定。



#### 9、区分度高（散列性高）的列适合作为索引

列的基数指的是某一列中不重复数据的个数，比方说某个列包含值2，5，8，2，5，8，2，5，8，虽然有9条记录，但该列的基数却是3。也就是说，在记录行数一定的情况下，列的基数越大，该列中的值越分散;列的基数越小，该列中的值越集中。这个列的基数指标非常重要，直接影响我们是否能有效的利用索引。最好为列的基数大的列建立索引，为基数太小列的建立索引效果可能不好。 ǐ
可以使用公式 select count(distinct a)/count(*)from t1 计算区分度，越接近1越好，，一般超过 33%就算是比较高效的索引了
**拓展:** 联合索引把区分度高(散列性高)的列放在前面

**原因：**因为当存在大量重复数据且数据分布均匀的字段在创建索引后，需要进行大量的回表操作，并且回表读的页面并不相连，是随机IO，所以此时不如直接去聚簇索引中执行全表扫描。



#### 10、使用频繁的列放到联合索引的左侧



#### 11、**在多个字段都要创建索引的情况下，联合索引优于单值索引**

可以较少的建立一些索引。同时，由于"最左前缀原则"，可以增加联合索引的使用率（即一个字段也可以被联合索引覆盖，前提是遵循最左前缀原则）



#### 12、限制索引数目

在实际工作中，我们也需要注意平衡，索引的数目不是越多越好。我们需要限制每张表上的索引数量，建议单张表索引数量 不超过6个。原因:
① 每个索引都需要占用 磁盘空间，索引越多，需要的磁盘空间就越大。
② 索引会影响 INSERT、DELETE、UPDATE等语句的性能，因为表中的数据更改的同时，索引也会进行调整和更新，会造成负担。
③ 优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的 索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，会增加MySQL优化器生成执行计划时间，降低查询性能。



### 4.2 不适用索引的情况

#### 1、在where、order by、group by中用不到的字段，不需要设置索引

#### 2、数据量小的表不用使用索引

在数据量不打的情况下，索引就发挥不出作用了。如，在数据表中的数据行数比较少的情况下，比如不到 1000 行，是不需要创建索引的

#### 3、有大量重复数据（选择性低）的列上不建议创建索引

要在 100 万行数据中查找其中的 50 万行（比如性别为男的数据），一旦创建了索引，你需要先访问 50 万次索引，然后再访问 50 万次数据表（回表），这样加起来的开销比不使用索引可能还要大。

假设有一个学生表，学生总数为 100 万人，男性只有 10 个人，也就是占总人口的 10 万分之 1。学生表 student_gender 结构如下。其中数据表中的 student_gender 字段取值为 0 或 1，0 代表女性，1 代表男性。那么可以使用索引。

结论：当数据重复度大，比如 高于 10% 的时候，也不需要对这个字段使用索引。

#### 4、避免对经常需要新增、更新、删除操作的表建立过多的索引

维护也需要成本

#### 5、不建议使用无序的值作为索引

身份证、UUID(在索引比较时需要转为ASCII，并且插入时可能造成页分裂)、MD5、HASH、无序长字符串等。

#### 6、删除不再使用或者很少使用的索引

维护需要成本

#### 7、不要定义容易或重复的索引

①冗余索引

如联合索引定义了a、b、c字段，有定义了一个a的普通索引，重复。

②重复索引

设置字段A为PRIMARY KEY 主键约束，又给它定义为一个唯一索引，还给它定义了一个普通索引，可是主键本身就会生成聚簇索引，所以定义的唯一索引和普通索引是重复的，这种情况要避免。



## 五、索引失效

### 5.1 优先考虑全值匹配

两个索引，A对a字段创立索引，B对a、b、c字段创立索引

当我们使用如下查询

```mysql
select * from table where a = 1 and b = 2
```

优先会使用B索引，并且B索引的效率会把A索引高，因为在A的索引中，匹配到a = 1后，叶子结点中就没有b的相关信息了，需要回表继续查询，而B索引仍旧有b索引信息，因此其查找的效率会更高（相当于更加精确定位，多列索引的范围会比单列的范围更小）。



### 5.2 最佳左前缀法则

在MySQL建立联合索引时会遵守最佳左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹
配。一个索引可以包括16个字段。对于多列索引，过滤条件要使用索引必须按照索引建立时的顺序，依次满足，一旦跳过某个字段，索引后面的字段都无法被使用。如果查询条件中没有使用这些字段中第1个字段时，多列(或联合)索引不会被使用。

具体示例：

A为字段a，b，c创建联合索引

对于如下可以用到索引A，但是由于其没有b，索引只用到了A索引中的a字段

```java
select * from table where a = 5 and c = 6
```

对于如下可以用到索引A，SQL优化器会对顺序进行优化，以符合最左前缀原则

```mysql
select * from table where c = 1 and a = 3 and b = 4
```

对于如下不可用到索引A

```mysql
select * from table where c = 1
```



### 5.3 主键插入顺序

![image-20241104000355464](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241104000355464.png)

这个数据页已经满了，再插进来需要把当前 页面分裂成两个页面，把本页中的一些记录移动到新创建的这个页中。页面分裂和记录移位意味着 性能损耗 ！所以如果我们想尽量避免这样无谓的性能损耗，最好让插入的记录的 主键值依次递增 ，这样就不会发生这样的性能损耗了。所以我们建议：让主键具有 AUTO_INCREMENT ，让存储引擎自己为表生成主键，而不是我们手动插入 ，我们自定义的主键列 id 拥有 AUTO_INCREMENT 属性，在插入记录时存储引擎会自动为我们填入自增的主键值。这样的主键占用空间小，顺序写入，减少页分裂。



### 5.4 计算、函数、类型转换(自动手动，显示隐式）导致索引失效

在使用计算、函数、类型转化的时候，其结果对于前者是不可见的，因此走不了索引，并且索引是按照列值的原始顺序组织和存储的。当对列应用函数时（如数学运算、字符串操作或日期函数等），函数会改变原始数据的值或格式，使得数据库无法直接定位到这些经过函数转换后的值。因此，数据库不得不执行全表扫描，以确保能够评估所有行上的函数操作，这导致查询性能下降。

示例1：函数

```mysql
select * from table a like 'abc%' #可以走索引
select * from table LEFT(a, 3) = 'abc' #不可走索引，结果abc对于函数不可见，需要一个个获取数据，然后调用函数，然后与abc进行比较
```

示例2：计算

```mysql
select * from table a  = 123 #可以
select * from table a + 1 = 123 + 1 #不可以
```

示例3：隐式转换

```mysql
select * from table a  = 123 # a是字符串类型，不可以走索引
select * from table a  = '123' # a是字符串类型，可以走索引
```



### 5.5 范围条件右边列索引失效

这里的右边是针对于联合索引中的字段顺序来说的，因为where条件后的字段顺序（and连接）会被SQL优化器优化。

如有一个联合索引，其中字段a、b、c，那么对于以下查询都可以完整地使用该联合索引

```mysql
EXPLAIN SELECT SQL_NO_CACHE * FROM table
WHERE a=30 AND b>20 AND c = 'abc' ;
EXPLAIN SELECT SQL_NO_CACHE * FROM table
WHERE a=30 AND c = 'abc' AND b>20;
```

如果联合索引创建字段的顺序是a、b、c，那么如下查询不能完整使用该联合索引

```mysql
EXPLAIN SELECT SQL_NO_CACHE * FROM table
WHERE a=30 AND b>20 AND c = 'abc' ;
EXPLAIN SELECT SQL_NO_CACHE * FROM table
WHERE a=30 AND c = 'abc' AND b>20;
```



#### 5.6 不等于!= 或者<>索引失效

如下索引会出现失效的情况

```mysql
CREATE INDEX idx name oN student(NAME);
EXPLAIN SELECT SOL NO CACHE * FROM student WHERE student.name <> 'abc'
EXPLAIN SELECT SQL NO CACHE * FROM student WHERE student.name != 'abc' ;
```

原因：

- 不等式条件的选择性较低，优化器可能认为使用索引并不比全表扫描更高效，因此选择忽略索引，选择全表扫描而不是使用索引
- 无法从单个点出发寻找数据，即查找过程是从树根往下查找的，找到叶子节点后去回表找数据，但在某一个结点可能是不等于，但是其叶子结点可能是等于的



#### 5.7 is null可以使用索引，is not null无法索引

IS NULL` 使用索引的原因

- **明确性**：使用 `IS NULL` 查询时，数据库优化器可以明确地知道要查找哪些记录，因为它只需要查找那些在索引中被标记为 `NULL` 的条目。
- **索引存储**：许多数据库系统在索引结构中存储了 `NULL` 值，因此可以直接利用索引来快速定位这些值。

 `IS NOT NULL` 无法使用索引的原因

- **不确定性**：当使用 `IS NOT NULL` 条件时，数据库需要检查所有记录，以确认哪些记录的值不是 `NULL`。这意味着索引并不能有效缩小搜索范围，因为大部分记录可能都有非 `NULL` 值。
- **索引的可用性**：在大多数情况下，索引不会存储 `NULL` 的条目（具体行为取决于数据库系统），因此优化器无法利用索引来快速查找非 `NULL` 值的记录。



结论：最好在设计数据表的时候就将 字段设置为 NOT NULL 约束 ，比如你可以将 INT 类型的字段，默认值设置为 0。将字符类型的默认值设置为空字符串(“)。
拓展:同理，在查询中使用 not like 也无法使用索引，导致全表扫描。



#### 5.8 like以通配符%开头索引失效

java开发手册中提到：页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。

其原因同理，无法从单个点出发寻找数据，即查找过程是从树根往下查找的，找到叶子节点后去回表找数据，但在某一个结点可能是不等于，但是其叶子结点可能是等于的。



#### 5.9 **OR** 前后存在非索引的列，索引失效

在字段a、b上创建联合索引，对于如下查询会出现索引失效问题

```mysql
EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE a = 10 OR c = 100;
```

因为or表示符合两个条件的数据都需要，此时a可以走索引，c不可以走索引，一个走索引一个全表扫描，不如干脆直接全表扫描



#### 5.10 数据库和表的字符集统一使用utf8mb4

防止在比较过程中进行字符集的转换，从而导致索引失效



#### 总结：

- 对于单列索引，尽量选择针对当前查询过滤性更好的索引
- 在选择组合索引的时候，当前query中过滤性最好的字段在索引字段顺序中，位置越靠前越好。
- 在选择组合索引的时候，尽量选择能够包含当前query中的where子句中更多字段的索引。
- 在选择组合索引的时候，如果某个字段可能出现范围查询时，尽量把这个字段放在索引次序的最后面。



## 六、InnoDB数据存储结构

### 6.1 数据库存储结构

索引结构给我们提供了高效的索引方式，不过索引信息以及数据记录都是保存在文件上的，确切说是存储在页结构中。另一方面，索引是在存储引擎中实现的，MySQL服务器上的**存储引擎**负责对表中数据的读取和写入工作。不同存储引擎中**存放的格式**一般是不同的，甚至有的存储引擎比如Memory都不用磁盘来存储数据。

### 6.2 磁盘与内存交互基本单位：页

InnoDB将数据划分为若干个页，InnoDB中页的大小默认为 **16KB**

以`页`作为磁盘和内存之间交互的`基本单位`，也就是一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中。也就是说，**在数据库中，不论读一行，还是读多行，都是将这些行所在的页进行加载。也就是说，数据库管理存储空间的基本单位是页(Page)，数据库I/O操作的最小单位是页。**一个页中可以存储多个行记录。（记录是按照行来存储的，但是数据库的读取并不以行为单位，以页为单位，否则一次读取（也就是一次I/O操作)只能处理一行数据，效率会非常低。）

![image-20241124235606941](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241124235606941.png)

### 6.3 页结构概述

页a、页b、页c …页n这些页可以不`在物理结构上相连`，只要通过`双向链表`相关联即可。每个数据页中的记录会按照主键值从小到大的顺序组成一个`单向链表`，每个数据页都会为存储在它里边的记录生成一个`页目录`，在通过主键查找某条记录的时候可以在页目录`中使用二分法`快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。

### 6.4 页的大小

不同的数据库管理系统（简称DBMS）的页大小不同。比如在MySQL的InnoDB存储引擎中，默认页的大小是**16KB**，可以通过下面的命令来进行查看:

```bash
show variables like '%innodb_page_size%';
/*
+------------------+-------+
| Variable_name    | Value |
+------------------+-------+
| innodb_page_size | 16384 |
+------------------+-------+
*/
```

SQL Server中页的大小为 `8KB`，而在oracle中用术语''`块`’’(Block)来代表"页”，Oralce支持的块大小为2KB，4KB，8KB，16K8，32KB和64KB。

### 6.5 页的上层结构

另外在数据库中，还存在区（Extent)、段(Segment)和表空间（Tablespace)的概念。行、页、区、段、表空间的关系如下图所示:

![image-20241125000618011](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241125000618011.png)

- 区(Extent)是比页大一级的存储结构，在InnoDB存储引擎中，一个区会分配`64个连续的页`。因为InnoDB中的页大小默认是16KB，所以一个区的大小是64*16KB= 1MB。

- 段(Segment)由一个或多个区组成，区在文件系统是一个连续分配的空间（在InnoDB中是连续的64个页)，不过在段中不要求区与区之间是相邻的。`段是数据库中的分配单位，不同类型的数据库对象以不同的段形式存在。` 当创建数据表、索引的时候，就会相应创建对应的段，比如创建一张表时会创建一个表段，创建一个索引时会创建一个索引段。

- 表空间（Tablespace)是一个逻辑容器，表空间存储的对象是段，在一个表空间中可以有一个或多个段，但是一个段只能属于一个表空间。数据库由一个或多个表空间组成，表空间从管理上可以划分为系统表空间，`用户表空间`、`撤销表空间`、`临时表空间`等。



### 6.6 页的内部结构

页如果按类型划分的话，常见的有 数据页（保存B+树节点，包括目录页/非叶子节点页和数据页/叶子节点页） 、 系统页 、 Undo页 和 事务数据页 等。数据页是我们最常使用的页。

数据页的 16KB 大小的存储空间被划分为七个部分，分别是文件头(File Header)、页头(Page Header)、最大最小记录(Infimum+supremum)、用户记录(User Records)、空闲空间(Free Space)、页目录(Page Directory)和文件尾(File Tailer) 。

页结构的示意图如下所示:

![image-20241125123542352](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241125123542352.png)

这7个部分作用分别如下，简单梳理如下表所示:

| 名称             | 占用大小 | 说明                                 |
| ---------------- | -------- | ------------------------------------ |
| File Header      | 38字节   | 文件头，描述页的信息                 |
| Page Header      | 56字节   | 页头,页的状态信息                    |
| lnfimum-Supremum | 26字节   | 最大和最小记录，这是两个虚拟的行记录 |
| User Records     | 不确定   | 用户记录，存储行记录内容             |
| Free Space       | 不确定   | 空闲记录，页中还没有被使用的空间     |
| Page Directory   | 不确定   | 页目录，存储用户记录的相对位置       |
| File Trailer     | 8字节    | 文件尾,校验页是否完整                |

我们可以把这7个结构分成3个部分：①File Header（文件头部）和 File Trailer（文件尾部） ② User Records（用户记录）、最大最小记录、Free Space（空闲空间） ③ Page Directory（页目录）、Page Header（页面头部）

思维导图：

![image-20241125223444179](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241125223444179.png)

#### ①File Header（文件头部）和 File Trailer（文件尾部）

##### （1）File Header（文件头部）

作用：描述各种页的通用信息（比如页的编号、其上一页、下一页是谁等）

大小：38字节

构成：

![image-20241125225503017](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241125225503017.png)

- FIL_PAGE_OFFSET(4字节)

每一个页都有一个单独的页号，就跟你的身份证号码一样，InnoDB通过页号可以唯一定位一个页。

![image-20241125232324975](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241125232324975.png)

-  FIL_PAGE_TYPE（2字节）

代表当前页的类型，通过不同的值表示不同的类型，如下所示

![image-20241125232427689](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241125232427689.png)

- FIL_PAGE_PREV（4字节）FIL_PAGE_NEXT（4字节）

InnoDB都是以页为单位存放数据的，如果数据分散到多个不连续的页中存储的话需要把这些页关联起来，FIL PAGE PREV和FIL PAGE NEXT就分别代表本页的上一个和下一个页的页号。这样通过建立一个双向链表把许许多多的页就都串联起来了，保证这些页之间不需要是物理上的连续，而是逻辑上的连续。

![image-20241125232754634](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241125232754634.png)

- FIL_PAGE_SPACE OR_CHKSUM（4字节）

代表当前页面的校验和(checksum)

什么是校验和?
就是对于一个很长的字节串来说，我们会通过某种算法来计算一个比较短的值来代表这个很长的字节串，这个比较短的值就称为校验和。在比较两个很长的字节串之前，先比较这两个长字节串的校验和，如果校验和都不一样，则两个长字节串肯定是不同的，所以省去了直接比较两个比较长的字节串的时间损耗。（类似于Hash算法）

文件头部和文件尾部都有属性:FILPAGE SPACE_OR_CHKSUM

作用：

InnoDB存储引擎以页为单位把数据加载到内存中处理，如果该页中的数据在内存中被修改了，那么在修改后的某个时间需要把数据同步到磁盘中。但是在同步了一半的时候断电了，造成了该页传输的不完整。为了检测一个页是否完整(也就是在同步的时候有没有发生只同步一半的尴尬情况)，这时可以通过文件尾的校验和(checksum 值)与文件头的校验和做比对，如果两个值不相等则证明页的传输有问题，需要重新进行传输，否则认为页的传输已经完成。

页传输完成如下所示，磁盘中的头尾校验和都是一致的

![image-20241126001353419](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241126001353419.png)

具体的：

每当一个页面在内存中修改了，在同步之前就要把它的校验和算出来，因为FileHeader在页面的前边，所以校验和会被首先同步到磁盘，当完全写完时，校验和也会被写到页的尾部，如果完全同步成功，则页的首部和尾部的校验和应该是一致的。如果写了一半儿断电了，那么在File Header中的校验和就代表着已经修改过的页，而在FileTrailer中的校验和代表着原先的页，二者不同则意味着同步中间出了错。这里，校验方式就是采用 Hash 算法进行校验。



- FIL_PAGE_LSN（8字节）

页面被最后修改时对应的日志序列位置(英文名是:LogSequence Number)



##### （2）File Trailer（文件尾部，8字节）

- 前4个字节代表页的校验和

这个部分是和File Header中的校验和相对应的。

- 后4个字节代表页面被最后修改时对应的日志序列位置(LSN)

这个部分也是为了校验页的完整性的，如果首部和尾部的LSN值校验不成功的话，就说明同步过程出现了问题。





####  ② User Records（用户记录）、最大最小记录、Free Space（空闲空间）

##### （1）概要

第二个部分是记录部分，页的主要作用是存储记录，所以“最大和最小记录”和“用户记录”部分占了页结构的主要空间。

当空闲空间被用户记录占满后，会新开一个页，如下图所示

![image-20241126002009134](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241126002009134.png)

##### （2）空闲空间

存储的记录会按照指定的行格式存储到User Records部分。但是在一开始生成页的时候，其实并没有User Records这个部分，每当我们插入一条记录，都会从FreeSpace部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到UserRecords部分，当FreeSpace部分的空间全部被User Records部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去申请新的页了。

![image-20241126002730187](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241126002730187.png)

##### （3）User Records（用户记录）

User Records中的这些记录按照指定的行格式一条一条摆在User Records部分，相互之间形成单链表。

用户记录中的一条条记录通过行格式进行记录，这里将一下COMPACT行格式：

![image-20241126003400531](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241126003400531-1732552441436-1.png)

记录头信息（5字节）示意图：

![image-20241126003457930](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241126003457930.png)

![image-20241126003506370](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241126003506370.png)

记录头信息中各个属性如下所示：

 ![image-20241126003553127](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241126003553127.png)

简化后的行格式如下所示

![image-20241126003606747](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241126003606747.png)

添加记录示例,下面各个属性详解他通过该记录进行说明

![image-20241126003650140](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241126003650140.png)

**各个属性详解：**

- delete_mask

这个属性际记着当前记录是否被删除，占用1个二进制位

值为0:代表记录并没有被删除

值为1:代表记录被删除掉了

为什么不直接删除呢？

被删除的记录之所以不立即从磁盘上移除，是因为移除它们之后其他的记录在磁盘上需要重新排列，导致性能消耗。所以只是打一个删除标记而己，所有被删除掉的记录都会组成一个所谓的垃圾链表，在这个链表中的记录占用的空间称之为可重用空间，之后如果有新记录插入到表中的话，可能把这些被删除的记录占用的存储空间覆盖掉。

- min_rec_mask

B+树的每层非叶子节点中的最小记录都会添加该标记min_rec_mask值为1.我们自己插入的四条记录的min_rec_mask值都是0，意味着它们都不是B+树的非叶子节点中的最小记录。

记录头信息里还有一个叫 min_rec_mask 的属性，只有在存储 目录项记录 的页中的主键值最小的目录项记录 的 min_rec_mask值为1，其他别的记录的 min_rec_mask 值都是0。

- record_type

这个属性表示当前记录的类型，一共有4种类型的记录:

0:表示普通记录
1:表示B+树非叶节点记录
2:表示最小记录
3:表示最大记录

插入的记录就是普通记录，它们的record_type值都是0，而最小记录和最大记录的record_type值分别为2和3。

- heap_no

这个属性表示当前记录在本页中的位置。
从图中可以看出来，我们插入的4条记录在本页中的位置分别是:2、3、4、5
怎么不见heap no值为0和1的记录呢?

![image-20241126004600920](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241126004600920.png)

MySQL会自动给每个页里加了两个记录，由于这两个记录并不是我们自己插入的，所以有时候也称为伪记录或者虚拟记录。这两个伪记录一个代表最小记录，一个代表最大记录最小记录和最大记录的heap_no值分别是0和1，也就是说它们的位置最靠前。

![image-20241126004533598](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241126004533598.png)

- n_owned

页目录中每个组中最后一条记录的头信息中会存储该组一共有多少条记录，作为n_owned 字段。

- next_record

记录头信息里该属性非常重要，它表示从当前记录的真实数据到下一条记录的真实数据的地址偏移量。
比如:第一条记录的next_record值为32，意味着从第一条记录的真实数据的地址处向后找32个字节便是下一条记录的真实数据。注意，下一条记录指得并不是按照我们插入顺序的下一条记录，而是按照主键值由小到大的顺序的下一条记录。而且规定Infimum记录(也就是最小记录)的下一条记录就是本页中主键值最小的用户记录，而本页中主键值最大的用户记录的下一条记录就是Supremum记录(也就是最大记录)。下图用箭头代替偏移量表示next_record。

![image-20241126005339497](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241126005339497.png)



**删除操作演示：**

![image-20241126005434132](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241126005434132.png)

![image-20241126005517442](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241126005517442.png)



**添加操作：**

![image-20241126005545598](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241126005545598.png)

![image-20241126005601409](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241126005601409.png)



##### （4）Infimum + Supremum（最小最大记录）

![image-20241126004732814](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241126004732814.png)

![image-20241126004749198](MySQL%E7%B4%A2%E5%BC%95.assets/image-20241126004749198.png)



#### ③ Page Directory（页目录）、Page Header（页面头部）





## 结尾

### 1、参考文章

- https://javaguide.cn/database/mysql/mysql-index.htm
- https://www.cnblogs.com/zsql/p/13808417.html
- https://juejin.cn/post/6931901822231642125
- 官方文档：https://dev.mysql.com/doc/refman/8.0/en/create-index.html

## 2、其他

### 2.1 索引合并和组合索引

索引合并是指 MySQL 在查询时能够使用多个单列索引（而不是组合索引）的组合来优化查询。即使没有组合索引，MySQL 也可以通过合并多个单列索引来满足查询条件。

特点

- **无需创建组合索引**：适用于没有组合索引，但有多个单列索引的情况。MySQL 会在查询时选择多个单列索引并将它们的结果合并，以满足查询条件。
- **适用于 OR 条件**：索引合并在涉及 `OR` 查询条件时较为常见，例如 `(column_a = 'value' OR column_b = 'value')`。
- **性能可能不如组合索引**：索引合并在特定场景下比组合索引慢，尤其是在多列频繁联合查询时，组合索引通常更高效。

示例

```sql
CREATE INDEX idx_a ON table_name (column_a);
CREATE INDEX idx_b ON table_name (column_b);
-- 查询时可以加速如下查询：
SELECT * FROM table_name WHERE column_a = 'value' OR column_b = 'value';
```

区别总结

- **结构差异**：组合索引是一个单一的多列索引，而索引合并是多个单列索引在查询时的组合。
- **性能差异**：组合索引通常在多列查询中比索引合并性能更高，减少了回表次数和数据读取量。
- **适用场景**：组合索引适用于多列组合查询的高频场景；索引合并更适用于 OR 条件查询，或者当组合索引不适用时。