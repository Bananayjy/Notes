# 问题的整理

## 1、mysql-connector-java 依赖

如果你想在 Java 项目中使用 MySQL 数据库，需要添加 `mysql-connector-java` 依赖。这个依赖提供了与 MySQL 数据库交互所需的驱动程序。

以下是一个 Maven 示例，展示如何在项目的 `pom.xml` 文件中添加 `mysql-connector-java` 依赖：

```xml
<dependencies>
    <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-java</artifactId>
        <version>8.0.23</version>
    </dependency>
</dependencies>
```

上述代码片段将 `mysql-connector-java` 依赖添加到了 Maven 项目的依赖部分。



请注意，`version` 标签中指定了特定的版本号（此处为 8.0.23），你可以根据实际情况进行调整。`mysql-connector-java` 的版本和 MySQL 数据库的版本需要保持对应关系。`mysql-connector-java` 是用于在 Java 程序中与 MySQL 数据库进行交互的驱动程序。不同的 `mysql-connector-java` 版本针对不同的 MySQL 数据库版本进行了兼容性和功能支持的调整。

为了确保兼容性和稳定性，你应该根据你所使用的 MySQL 数据库的版本选择相应的 `mysql-connector-java` 版本。

如果你不确定应该使用哪个版本，可以通过查阅 MySQL 官方文档、`mysql-connector-java` 的官方文档或社区论坛等资源来获取最新的兼容性信息和建议。

一些常见的 MySQL 数据库版本与 `mysql-connector-java` 版本之间的兼容关系：

| MySQL 版本 | `mysql-connector-java` 版本 |
| ---------- | --------------------------- |
| 8.0.x      | 8.0.x                       |
| 5.7.x      | 5.1.x 或更高版本            |
| 5.6.x      | 5.1.x 或更高版本            |
| 5.5.x      | 5.1.x 或更高版本            |

我们可以在命令行客户端输入mysql `--version`命令来查看，当前使用的mysql 的版本



一旦添加了 `mysql-connector-java` 依赖，就可以在 Java 代码中使用 MySQL 数据库了。你需要加载驱动程序并建立数据库连接，然后执行相应的操作。

```java
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;

public class MySQLExample {
    public static void main(String[] args) {
        // MySQL连接信息
        String url = "jdbc:mysql://localhost:3306/mydatabase";
        String username = "your-username";
        String password = "your-password";

        try {
            // 加载MySQL驱动程序
            // Class.forName 动态加载类的方法之一
            Class.forName("com.mysql.cj.jdbc.Driver");

            // 建立数据库连接
            Connection connection = DriverManager.getConnection(url, username, password);

            // 执行数据库操作...

            // 关闭数据库连接
            connection.close();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}

```





## 2、Class.forName()

`Class.forName()` 是 Java 中用于动态加载类的方法之一。

`Class.forName(String className)` 方法通过传入类的完全限定名（包含包名和类名），在运行时加载指定的类。这个方法主要用于加载 JDBC 驱动程序、实例化对象或执行其他需要在编译时未知的类操作。

具体使用方式如下：

```java
try {
    Class<?> clazz = Class.forName("com.example.MyClass");
    // 使用 clazz 进行后续操作，如创建实例等
} catch (ClassNotFoundException e) {
    e.printStackTrace();
}
```

在上述示例中，我们尝试加载名为 "com.example.MyClass" 的类。如果成功加载，则可以使用 `clazz` 变量来执行后续操作，比如创建该类的实例。

需要注意以下几点：

1. 在使用 `Class.forName()` 加载类时，需要提供类的完全限定名，包括包名和类名。
2. 如果提供的类名无法找到对应的类，则会抛出 `ClassNotFoundException` 异常。因此，在使用 `Class.forName()` 时，需要进行异常处理。
3. 调用 `Class.forName()` 方法会触发类的静态初始化代码块，因此被加载的类会执行相应的静态初始化操作。
4. 在较新的 Java 版本中，通常更推荐使用类字面常量的形式加载类，例如 `MyClass.class`，它更简洁、类型安全，并且不会抛出 `ClassNotFoundException`。

总之，`Class.forName()` 方法是一种动态加载类的方法，可以在运行时根据类名加载指定的类，并进行后续操作。



## 3、关于Mapper和Dao的区分

Mapper和Dao是两种常见的数据访问层设计模式。

**Mapper：**

 Mapper是一种用于对象关系映射（ORM）的设计模式。它通常用于描述将数据库中的实体对象与应用程序中的领域对象（）进行映射的组件或类。在MyBatis等ORM框架中，Mapper通常指的是定义了SQL语句与方法映射关系的接口或类。Mapper负责处理数据库操作的细节，例如执行SQL查询、插入、更新等，并将结果映射为领域对象。特别是在持久层框架中（如MyBatis、Hibernate等），"Mapper"通常指的是定义了SQL语句与方法映射关系的接口或类。这些Mapper负责处理数据库操作的细节，例如执行SQL查询、插入、更新等，并将结果映射为领域对象。具体来说，在MyBatis框架中，Mapper指的是一组定义了SQL语句和方法映射关系的接口或XML文件。通过配置Mapper，我们可以将SQL语句与具体的数据访问方法进行映射，使得我们可以通过简单的方法间接调用来执行数据库操作，而无需编写繁琐的JDBC代码。"Mapper"这个术语并不仅仅局限于Java开发和ORM框架，它在其他编程语言和领域中也可能具有类似的含义，用于描述对象与数据存储之间的映射关系

**Dao：**

 Dao（Data Access Object）是一种用于封装数据访问逻辑的设计模式。Dao层位于业务逻辑层和数据存储层之间，为上层提供对底层数据存取的统一接口。Dao主要负责封装数据库的访问细节，包括数据读取、写入、更新等操作，并隐藏背后的具体实现细节，使上层业务代码可以更加聚焦于业务逻辑的实现，而不需要关心数据存取的具体实现。Dao模式提供了一种结构化的方式来处理数据访问，将数据操作与业务逻辑分离，提高了代码的可维护性和可测试性。它提供了灵活的数据访问接口，并隐藏了底层数据存取的实现细节，使得应用程序更加松耦合并易于扩展。

Dao的主要作用如下：

1. 封装数据库操作：Dao负责封装数据库的访问细节，包括数据读取、写入、更新等操作。它通过定义一组方法来描述对数据的操作，并抽象出对底层数据库的访问细节，使得上层业务代码可以更专注于业务逻辑的实现，而不需要关心数据存取的具体实现方式。
2. 提供数据访问接口：Dao提供了一组通用的数据访问接口，这些接口定义了常见的CRUD操作（创建、读取、更新、删除），以及其他与数据相关的操作。通过这些接口，上层业务代码可以方便地访问和操作数据，而无需直接与底层数据存储进行交互。
3. 实现事务管理：Dao可以负责处理事务的管理，确保多个数据操作的一致性。通过在Dao中定义事务方法，并在方法中添加事务管理的逻辑，可以保证一系列数据操作的原子性、一致性和持久性。





## 4、Mapper类的映射xml文件

我们定义了mapper接口，可以直接通过在方法上面添加注解的方式来进行映射操作,编写对应的sql语句

```java
public interface UserMapper {
    @Select("sql语句")
    List<User> findAll();
}
```

但一般情况下，我们会在resource配置包下创建该Mapper接口对应的xml文件，通过xml指定对应的mapper接口的命名空间，并在xml文件中编写对应的sql语句

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.example.mapper.UserMapper">
    <select id="findAll" resultType="com.example.entity.User">
        select * from tb_user
    </select>
</mapper>

```

在许多ORM（对象关系映射）框架中，如MyBatis、Hibernate等，Mapper类通常需要一个XML文件来定义SQL语句和方法之间的映射关系。这种设计方式有以下几个原因：

1. 解耦 SQL 和 Java 代码：将SQL语句与Java代码分离可以提高可维护性和可读性。通过使用XML文件，我们可以将SQL语句以及相应的参数和返回值类型配置在独立的文件中，使得SQL语句更易于编写和修改，并且减少了在Java代码中编写大量SQL语句的冗余。
2. 提供灵活的动态 SQL 支持：XML文件提供了一种灵活的方式来构建动态SQL语句。我们可以在XML文件中使用条件判断、循环等逻辑来生成不同的SQL语句，根据不同的场景和需求进行灵活的定制。这使得我们能够根据具体情况生成不同的SQL查询或更新语句，提高了SQL的复用性和灵活性。
3. 易于配置和管理：通过将SQL语句和方法映射配置在XML文件中，我们可以集中管理和配置这些映射关系。这样做可以统一管理SQL语句，方便查找和修改。同时，XML文件也提供了一些配置选项，如缓存、日志等，可以更方便地对Mapper进行配置和管理。
4. 支持复杂的映射关系：XML文件提供了更强大的语法和选项，可以支持复杂的映射关系。例如，可以使用XML中的元素来处理一对多、多对多等关联关系，进行级联插入、更新或删除操作，更好地满足复杂业务需求。

需要注意的是，并非所有的ORM框架都要求在Mapper类中使用XML文件进行配置。有些框架可能采用注解方式来定义SQL语句与方法的映射关系，这样可以更简洁地将SQL语句直接嵌入到Java代码中。不同的框架和项目可能会根据具体需求选择不同的配置方式。





## 5、Mapper接口的映射xml文件为什么路径要和Mapper接口一样

在 MyBatis 中，Mapper 接口与对应的映射 XML 文件之间是有约定的命名规则的。这个约定规定了 Mapper 接口的完全限定名（包括包路径）应该与映射 XML 文件的路径和文件名相对应。

将 Mapper 接口的完全限定名（包括包路径）与映射 XML 文件的路径和文件名设置为一样，是 MyBatis 默认的约定规则。这种命名约定可以使得 MyBatis 在运行时能够自动关联 Mapper 接口与对应的映射 XML 文件。

具体来说，MyBatis 在启动时会扫描指定的包路径下的 Mapper 接口，并根据默认的命名规则（即将包路径转换为文件路径，将接口名转换为文件名）去加载对应的映射 XML 文件。这样，就实现了 Mapper 接口与映射 XML 文件的自动关联。

使用相同的路径和文件名作为 Mapper 接口的完全限定名和映射 XML 文件的路径和文件名有以下几个好处：

1. 一致性：通过保持路径和文件名一致，可以增加代码的可读性和可维护性。开发人员可以更直观地找到对应的映射文件，更容易理解和修改。
2. 自动映射：MyBatis 在启动时会自动扫描路径下的 Mapper 接口，并按照默认规则加载对应的映射 XML 文件。无需在配置文件中一个个指定或注册 Mapper 接口，减少了开发人员的工作量。
3. 易于理解：采用默认的命名规则，可以使得项目结构更加清晰，并且直观地反映出 Mapper 接口与映射 XML 文件之间的对应关系。这样，其他开发人员在查看代码时能够快速理解和找到相应的映射关系。

需要注意的是，虽然默认约定规则可以提供方便的自动映射功能，但也可以通过配置来修改默认行为。例如，可以使用 `<mapper>` 元素的 `namespace` 属性指定映射文件对应的 Mapper 接口完全限定名，或者使用 `<package>` 元素或 `<mapper>` 元素指定其他的扫描和加载方式。

总而言之，将 Mapper 接口的完全限定名（包括包路径）与映射 XML 文件的路径和文件名设置为一样，可以让 MyBatis 在启动时自动关联 Mapper 接口与对应的映射 XML 文件，增加了开发的便利性和项目的可维护性。



这样做的目的主要有两个原因：

1. 方便管理和维护：通过将 Mapper 接口与映射 XML 文件的路径和文件名保持一致，可以使代码结构更加清晰和规范。开发人员可以很方便地找到对应的映射配置，并进行修改、扩展和重构。
2. 自动化映射：MyBatis 提供了自动化的映射功能，即根据 Mapper 接口的方法名称和参数来推导对应的 SQL 语句和结果映射。当 Mapper 接口的名称和映射 XML 文件的路径名一致时，MyBatis 可以自动将方法名与 XML 文件中的 SQL 语句 ID 进行匹配，从而省去了手动编写 SQL 语句的步骤。

通过保持 Mapper 接口和映射 XML 文件的路径名一致，MyBatis 可以根据约定自动进行方法与 SQL 语句的匹配，从而实现了数据库操作的自动化映射。



**自动映射配置：**

MyBatis 的自动映射配置是指通过一定的规则和约定，让 MyBatis 自动将查询结果集中的列与 Java 对象的属性进行映射，从而无需手动编写映射代码。

MyBatis 提供了三种类型的自动映射配置：

1. 自动映射（AutoMapping）：当查询结果集中的列名与 Java 对象的属性名相匹配时，MyBatis 会自动将它们进行映射。例如，数据库表 `user` 中有 `id`、`username` 和 `email` 三个列，对应 Java 对象的属性也分别为 `id`、`username` 和 `email`，则可以直接使用自动映射进行对象映射。
2. 嵌套结果映射（Nested Results Mapping）：如果查询结果集包含多个表的数据，并且这些表之间存在关联关系，可以通过嵌套结果映射来实现将查询结果映射到嵌套的对象结构中。例如，查询用户信息及其所属的部门信息，可以使用嵌套结果映射来将用户信息和部门信息映射到一个复杂的对象结构中。
3. 构造函数映射（Constructor Mapping）：如果查询结果集的列与 Java 对象的属性没有直接的对应关系，可以通过构造函数映射来进行对象的创建和映射。这种映射方式通过调用对象的构造函数来创建对象，并将查询结果映射到构造函数参数中。

自动映射配置可以在 MyBatis 的映射文件（XML 文件）中进行配置，使用 `<resultMap>` 元素和相应的属性配置来定义映射规则。也可以使用注解方式进行配置，通过在 Mapper 接口的方法上使用 `@Result` 和 `@Results` 注解来定义映射关系。

使用自动映射配置可以简化代码编写，提高开发效率。但需要注意，自动映射并不适用于所有情况，特别是复杂的查询结果集或者涉及到特殊数据类型的映射。在这些情况下，可能需要手动编写映射代码以实现更精确的映射。



需要注意的是，这种命名规则并不是强制要求的，只是 MyBatis 默认的约定。如果希望使用不同的命名规则，可以在 MyBatis 配置文件中进行相应的配置，明确指定 Mapper 接口与映射 XML 文件之间的对应关系，如下

我们定义了一个mapper接口

```java
package com.example.mapper;

import com.example.entity.User;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Select;

import java.util.List;

/**
 * @author banana
 * @create 2023-08-06 15:01
 */
public interface UserMapper {
    List<User> findAll();
}

```

然后我们定义了一个xml映射文件，且其路径和mapper接口不一样

![image-20230806182224706](%E9%97%AE%E9%A2%98%E7%9A%84%E6%95%B4%E7%90%86.assets/image-20230806182224706.png)



其中的内容如下，定义了命名空间为UserMapper接口

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.example.mapper.UserMapper">
    <select id="findAll" resultType="com.example.entity.User">
        select * from tb_user
    </select>
</mapper>

```

然后我们在mybatis的配置文件中，对该配置文件进行扫描（mappers标签中的两个都可以，一个是指定xml，一个是指定接口）

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>

    <!-- 设置数据库环境 -->
    <environments default="development">
        <environment id="development">
            <transactionManager type="JDBC"/>
            <dataSource type="POOLED">
                <!--
					mysql 5.x的时候驱动名称
					<property name="driver" value="com.mysql.jdbc.Driver"/>
 				-->
                <!-- mysql 8.x的时候驱动名称 -->
                <property name="driver" value="com.mysql.cj.jdbc.Driver"/>
                <property name="url" value="jdbc:mysql://localhost:3306/mybatis"/>
                <property name="username" value="root"/>
                <property name="password" value="123456"/>
            </dataSource>
        </environment>
    </environments>

    <!-- 加载映射器配置 -->
    <mappers>
        <!--路径名称不对应-->
        <mapper resource="com/example2/mapper2/UserMapper2.xml"/>
        <!--<package name="com.example.mapper"></package>-->
    </mappers>

</configuration>

```

最后可以发现Mapper 接口与对应的映射 XML 文件成功对应，并且成功完成了SQL的映射

![image-20230806182512412](%E9%97%AE%E9%A2%98%E7%9A%84%E6%95%B4%E7%90%86.assets/image-20230806182512412.png)

## 6、Mybatis配置文件中的mappers标签的属性

`<mappers>` 是 MyBatis 配置文件中的一个元素，用于配置映射器（Mapper）相关的信息。

在 MyBatis 中，映射器（Mapper）负责定义数据访问接口，并提供与数据库交互的 SQL 语句。`<mappers>` 元素用于将这些映射器与相应的映射文件（XML 文件）进行关联。

`<mappers>` 元素可以包含以下子元素来配置映射器的信息：

1. `<package>`：指定要扫描的 Mapper 接口所在的包路径，自动加载与之对应的映射文件。示例如下：

```xml
<mappers>
    <package name="com.example.mapper"/>
</mappers>
```

上述配置表示会扫描 `com.example.mapper` 包及其子包下的所有 Mapper 接口，并自动加载与之对应的映射文件。

1. `<mapper>`：直接指定映射文件的位置和文件名，与对应的 Mapper 接口进行关联。示例如下：

```xml
<mappers>
    <mapper resource="mapper/user.xml"/>
    <mapper class="com.example.mapper.OrderMapper"/>
</mappers>
```

上述配置表示会加载 `mapper/user.xml` 文件，并与名为 `com.example.mapper.OrderMapper` 的 Mapper 接口进行关联。

`<mappers>` 元素也可以使用 `url` 属性来指定外部资源的位置。

```xml
<mappers>
    <mapper url="file:/path/to/mapper.xml"/>
</mappers>
```

需要注意的是，`<mappers>` 元素只需在 MyBatis 的配置文件（通常是 `mybatis-config.xml`）中出现一次。如果使用 `<package>` 元素进行自动扫描，MyBatis 会在启动时自动加载配置的映射器和映射文件。如果使用 `<mapper>` 元素指定映射文件，需要确保路径和文件名正确，并与对应的 Mapper 接口进行关联。

通过配置 `<mappers>` 元素，可以将映射器与相应的映射文件进行关联，使得 MyBatis 能够正确地解析并执行 SQL 语句。





## 7、通过注解完成SQL和方法的映射

在spring中，我们可以通过在mapper类的方法上添加对应的sql注解，并在其中指定对应的sql语句，来完成映射操作，在使用注解进行 SQL 映射时，确保 Mapper 接口被标记为 `@Mapper` 注解，并且正确配置了 MyBatis 的扫描功能，以便让 MyBatis 自动扫描并注册该接口。

```java
package com.example.mapper;

import com.example.entity.User;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Select;

import java.util.List;

/**
 * @author banana
 * @create 2023-08-06 15:01
 */
public interface UserMapper {
    @Select("select * from tb_user")
    List<User> findAll();
}

```



## 8、sqlsession

`SqlSession` 是 MyBatis 中用于执行 SQL 语句并管理数据库连接的核心接口之一。

`SqlSession` 接口提供了多种方法，包括对数据库的查询、插入、更新和删除等操作，以及事务管理的支持。通过使用 `SqlSession`，我们可以在 Java 代码中直接调用相应的方法来与数据库进行交互。

主要的 `SqlSession` 方法包括：

- `selectOne(String statement, Object parameter)`: 执行查询并返回单个结果对象。
- `selectList(String statement, Object parameter)`: 执行查询并返回结果列表。
- `insert(String statement, Object parameter)`: 执行插入操作。
- `update(String statement, Object parameter)`: 执行更新操作。
- `delete(String statement, Object parameter)`: 执行删除操作。
- `commit()`: 提交事务。
- `rollback()`: 回滚事务。
- `close()`: 关闭 `SqlSession` 对象。

通常，在使用 `SqlSessionFactory` 创建完 `SqlSession` 之后，我们可以通过调用 `SqlSession` 的相关方法来执行 SQL 操作，并获得结果或提交事务。

示例代码如下：

```java
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;

public class MyBatisClient {
    public static void main(String[] args) {
        // 创建 SqlSessionFactory
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader);

        // 创建 SqlSession
        SqlSession sqlSession = sqlSessionFactory.openSession();

        try {
            // 执行查询，并获取结果
            User user = sqlSession.selectOne("UserMapper.getUserById", 1);
            System.out.println("User ID: " + user.getId() + ", Name: " + user.getName());

            // 执行插入操作
            User newUser = new User(2, "John");
            sqlSession.insert("UserMapper.insertUser", newUser);

            // 提交事务
            sqlSession.commit();
        } catch (Exception e) {
            // 发生异常时回滚事务
            sqlSession.rollback();
        } finally {
            // 关闭 SqlSession
            sqlSession.close();
        }
    }
}
```

在上述示例中，我们首先使用 `SqlSessionFactory` 创建了一个 `SqlSession` 对象。然后，通过调用 `SqlSession` 的方法来执行查询和插入操作，并最终提交或回滚事务。最后，我们关闭了 `SqlSession` 对象以释放相关资源。

需要注意的是，在使用完 `SqlSession` 后，应该及时关闭它来避免资源泄漏。通常可以将 `SqlSession` 的创建和关闭放在 `try-catch-finally` 块中，以确保在发生异常或完成操作后都能正常关闭 `SqlSession`。

总而言之，`SqlSession` 是 MyBatis 中用于执行 SQL 操作并管理数据库连接的接口，通过它我们可以执行查询、插入、更新和删除等操作，并提供了事务管理的支持。



`SqlSession` 接口提供了一个 `getMapper(Class<T> type)` 方法，该方法用于获取指定类型的 Mapper 接口实例。

在 MyBatis 中，Mapper 接口是定义 SQL 映射操作的接口。通常，为每个数据表或业务实体创建一个对应的 Mapper 接口，并在其中定义相应的方法来执行对数据库的操作。通过使用 `getMapper()` 方法，我们可以获得该 Mapper 接口的实例，从而可以直接调用其中定义的方法来执行数据库操作，而无需编写具体的 SQL 语句。

示例代码如下：

```java
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;

public class MyBatisClient {
    public static void main(String[] args) {
        // 创建 SqlSessionFactory
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader);

        // 创建 SqlSession
        SqlSession sqlSession = sqlSessionFactory.openSession();

        try {
            // 获取 UserMapper 接口的实例
            UserMapper userMapper = sqlSession.getMapper(UserMapper.class);

            // 调用 Mapper 接口中的方法执行查询操作
            User user = userMapper.getUserById(1);
            System.out.println("User ID: " + user.getId() + ", Name: " + user.getName());

            // 调用 Mapper 接口中的方法执行插入操作
            User newUser = new User(2, "John");
            userMapper.insertUser(newUser);

            // 提交事务
            sqlSession.commit();
        } catch (Exception e) {
            // 发生异常时回滚事务
            sqlSession.rollback();
        } finally {
            // 关闭 SqlSession
            sqlSession.close();
        }
    }
}
```

在上述示例中，我们首先使用 `getMapper(UserMapper.class)` 方法获取了 `UserMapper` 接口的实例。然后，通过调用该接口中定义的方法来执行数据库操作，如查询和插入。

需要注意的是，在使用 `getMapper()` 方法时，MyBatis 会动态生成对应的 Mapper 接口的实现类，并将其与当前的 `SqlSession` 关联起来。这样，当调用 Mapper 接口的方法时，实际上是由 MyBatis 代理对象来完成具体的 SQL 操作。

总而言之，通过 `SqlSession` 的 `getMapper()` 方法，我们可以方便地获取指定类型的 Mapper 接口实例，并直接调用其中定义的方法来执行数据库操作，从而实现了数据访问层的解耦和简化。





## 9、Mapper接口没有实现类，其通过代理直接调用SQL语句

在典型的 MyBatis 中，Mapper 接口是没有实现类的。

Mapper 接口是一个纯粹的接口，其中定义了与数据库交互的方法。这些方法的实现由 MyBatis 框架动态生成，并在运行时根据方法名和参数等信息自动映射到对应的 SQL 语句执行。

这种方式称为 Mapper 接口的代理（Proxy）实现。MyBatis 使用 Java 动态代理技术，在运行时为 Mapper 接口生成一个代理对象，该对象会拦截对方法的调用，并将其转发给底层的 SQL 执行引擎。

因此，开发人员只需编写 Mapper 接口，并在 XML 映射文件中配置 SQL 语句，无需为 Mapper 接口编写具体的实现类。

需要注意的是，MyBatis 提供了一些辅助功能，如基于注解的 SQL 编写、ResultMap 的自动映射等，这些功能可以在 Mapper 接口上使用相应的注解进行标记。但这并不是实现类，而是用来辅助生成 SQL 语句或实现特定的映射逻辑。

总结来说，Mapper 接口本身是没有实现类的，它的方法由 MyBatis 在运行时动态生成。开发人员只需要编写 Mapper 接口，并在 XML 映射文件中配置 SQL 语句，而无需为 Mapper 接口编写具体的实现类。