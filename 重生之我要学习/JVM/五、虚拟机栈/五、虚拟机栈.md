## 五、虚拟机栈

### 1、虚拟机栈概述

#### 1.1 虚拟机栈出现的背景

由于跨平台性的设计，Java的指令都是根据栈来设计的。原因是对于不同平台CPU架构不同，所以不能设计为基于寄存器的。

**关于虚拟机的优缺点：**

**优点：**跨平台，指令集小，编译器容易实现

**缺点：**是性能下降，实现同样的功能需要更多的指令。



#### 1.2 初步印象

因为C和C++的内存结构主体是由堆（heap）和栈（stack）组成

因此很多Java开发人员一提到Java内存结构，就会非常粗粒度地将JVM中的内存区域理解为仅有java堆和java栈。



#### 1.3 内存中的栈与堆

栈是运行时的单位，而堆是存储的单位。

栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。

堆解决的是数据存储的问题，即数据怎么放、放在哪儿。



#### 1.4 虚拟机栈基本内容

##### 1、Java虚拟机栈是什么

Java虚拟机栈(Java Virtual Machine stack)，早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈（即线程私有的），其内部保存一个个的栈帧(stack Frame)，对应着一次次的Java方法调用（同时也对应着一次次栈帧的出栈和入栈）

##### 2、生命周期

生命周期和线程一致

##### 3、作用

主管Java程序的运行，它保存方法的局部变量（涉及8种基本数据类型，对象的引用地址【具体的对象存储在堆中】）、部分结果，并参与方法的调用和返回。

##### 4、举例

如下代码的具体的栈操作是这样的，当我们执行methodA方法的时候，即将methodA中的内容加载到栈中，首先是i = 10 入栈，然后j = 20 入参，并且i = 10 和 j = 20 都在一个栈帧中（一个栈帧对应一个方法）。当执行methodB方法的时候，会将x=30和y=40入栈，并且他们属于一个栈帧。我们把栈顶的栈帧称为当前方法，即methodB，当methodB方法执行完毕后，methodB对应的栈帧就会出栈，然后此时methodA就变成了当前方法，执行methodA中的内容。

```java
public class StackTest{
    
    public static void main(String[] args) {
        StackTest stackTest = new StackTest();
        stackTest.methodA();
    } 
    
    public void methodA(){
        int i = 10;
        int j = 20;
        this.methodB();
    }
    
    public void methodB(){
        int x = 30;
        int y = 40;
    }
    
}
```

##### 5、栈的特点（优点）

- 栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。

- JVM直接对Java栈的操作只有两个:
  - 每个方法执行，伴随着进栈(入栈、压栈)
  - 执行结束后的出栈工作
- 对于栈来说不存在垃圾回收问题（GC），因为只涉及入栈和出栈，不需要高级的算法进行垃圾回收。但是其会存在OOM，即溢出问题。

![image-20240624234323593](%E4%BA%94%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.assets/image-20240624234323593.png)

##### 6、栈中可能出现的异常

Java 虚拟机规范允许Java栈的大小是动态（初始大小可以通过启动参数（如`-Xss`）来设置，但在很多JVM实现中，栈的大小可以根据需要动态调整。比如，当一个方法调用导致需要更多的栈空间时，JVM可以动态增加栈的大小；反之，当不再需要那么多栈空间时，JVM可以回收一些栈空间。是否可以动态分配的，取决于JVM的实现，如果不指定-xss参数，通常情况下java虚拟机会采用默认的栈空间）的或者是固定不变的。

- 如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个StackoverflowError 异常

  示例：

  ```
  public static void main(String[] atgs) {
  	main(args);
  }
  
  //抛出异常:Exception in thread "main"java.lang.stackoverflowError
  //程序不断的进行递归调用，而且没有退出条件，就会导致不断地进行压栈。
  ```

  

- 如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法中请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个OutOfMemoryError 异常

我们可以使用参数-Xss 选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。可以通过如下方式查看调用的深度

默认情况下count:11420

设置栈大小：-Xss256k: count:2465

```java

public Test{
	private static int count = 1；
	public static void main(String[] args) {
		System.out.println(count);
		count++;
		main(args);
	}
}
```



### 2、栈的存储单位

#### 2.1 栈中的存储内容

- 每个线程都有自己的栈，栈中的数据都是以栈帧(stack Frame)的格式存在
- 在这个线程上正在执行的每个方法都各自对应一个栈帧(stack Frame)。（栈帧的方法的关系：一一对应）
- 栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息



#### 2.2 栈运行原理

##### 1.原理概括

- JVM直接对Java栈的操作只有两个，就是对栈帧的压栈和出栈，遵循“先进后出”/“后进先出”原则。
- 在一条活动线程中（各个线程是并发运行的，一个CPU在同一时刻只能运行一个线程，多核处理器，也是每个核心同一时间只能执行一个线程0），一个时间点上，只会有一个活动的栈帧（栈中最顶层的栈帧）。即只有当前正在执行的方法的栈帧(栈顶栈帧)是有效的，这个栈被称为当前栈帧(Current Frame)，与当前栈帧相对应的方法就是当前方法(Current Method)，定义这个方法的类就是当前类(Currentclass)
- 执行引擎运行的所有字节码指令只针对当前栈帧进行操作
- 如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。
- 不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。（每个线程维护一个虚拟机栈，每个线程共享堆空间）
- 如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧
- Java方法有两种返回函数的方式（方法结束有两种方式），一种是正常的函数返回，使用return指令;另外一种是抛出异常。不管使用哪种方式，都会导致帧被弹出，并将结果返回给下一个栈帧（return将值返回，异常将异常抛出给下一个栈帧）

##### 2.具体示例

![image-20240627000234912](%E4%BA%94%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.assets/image-20240627000234912.png)



示例代码

```java
/**
 * @author banana
 * @create 2024-06-27 0:03
 */
public class StackFrameTest {

    public static void main(String[] args) {
        StackFrameTest test = new StackFrameTest();
        test.method1();
    }

    public void method1() {
        System.out.println("method1方法开始执行");
        method2();
        System.out.println("method1方法执行结束");
    }

    public int method2() {
        System.out.println("method2方法开始执行");
        double v = method3();
        System.out.println("method2方法执行结束");
        return (int)v * 2;
    }

    public double method3() {
        System.out.println("method3方法开始执行");
        double num = 2.1;
        System.out.println("method3方法执行结束");
        return num;
    }

}
```

运行结果：

```
method1方法开始执行
method2方法开始执行
method3方法开始执行
method3方法执行结束
method2方法执行结束
method1方法执行结束
```

说明：

首先我们调用main方法，会把main方法对应的栈帧放入虚拟机栈中，然后开始执行main方法，即此时为当前栈帧，当调用到method1方法的时候，会将method1对应的栈帧放入虚拟机栈中，此时method1对应的栈帧作为当前栈帧，当调用到methdo2方法的时候，会将methdo2对应的栈帧放入到虚拟机栈中，同理，直到method3方法对应的栈帧放入虚拟机栈中，当method3方法执行完毕后，其对应的栈帧出栈，此时method2对应的栈帧为当前栈帧，执行对应的方法，同理，直到所有的栈帧都出栈，即结束。（总结：栈帧的入栈，对应一个方法的调用，栈帧的出栈，对应一个方法的结束）

可以通过IDEA提供的Frames栈帧来查看具体的虚拟机栈中的栈帧情况：

![image-20240627001130771](%E4%BA%94%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.assets/image-20240627001130771.png)

将上述的代码的字节码文件反编译一下

```
D:\codesaver\UtilsTest\target\classes\com\yjy\JVMTEST>javap -v StackFrameTest.class
Classfile /D:/codesaver/UtilsTest/target/classes/com/yjy/JVMTEST/StackFrameTest.class
  Last modified 2024-6-27; size 1165 bytes
  MD5 checksum fa1f8dcb73dbf8ec490d00fa289e7271
  Compiled from "StackFrameTest.java"
public class com.yjy.JVMTEST.StackFrameTest
  minor version: 0
  major version: 52
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
   #1 = Methodref          #17.#40        // java/lang/Object."<init>":()V
   #2 = Class              #41            // com/yjy/JVMTEST/StackFrameTest
   #3 = Methodref          #2.#40         // com/yjy/JVMTEST/StackFrameTest."<init>":()V
   #4 = Methodref          #2.#42         // com/yjy/JVMTEST/StackFrameTest.method1:()V
   #5 = Fieldref           #43.#44        // java/lang/System.out:Ljava/io/PrintStream;
   #6 = String             #45            // method1方法开始执行
   #7 = Methodref          #46.#47        // java/io/PrintStream.println:(Ljava/lang/String;)V
   #8 = Methodref          #2.#48         // com/yjy/JVMTEST/StackFrameTest.method2:()I
   #9 = String             #49            // method1方法执行结束
  #10 = String             #50            // method2方法开始执行
  #11 = Methodref          #2.#51         // com/yjy/JVMTEST/StackFrameTest.method3:()D
  #12 = String             #52            // method2方法执行结束
  #13 = String             #53            // method3方法开始执行
  #14 = Double             2.1d
  #16 = String             #54            // method3方法执行结束
  #17 = Class              #55            // java/lang/Object
  #18 = Utf8               <init>
  #19 = Utf8               ()V
  #20 = Utf8               Code
  #21 = Utf8               LineNumberTable
  #22 = Utf8               LocalVariableTable
  #23 = Utf8               this
  #24 = Utf8               Lcom/yjy/JVMTEST/StackFrameTest;
  #25 = Utf8               main
  #26 = Utf8               ([Ljava/lang/String;)V
  #27 = Utf8               args
  #28 = Utf8               [Ljava/lang/String;
  #29 = Utf8               test
  #30 = Utf8               method1
  #31 = Utf8               method2
  #32 = Utf8               ()I
  #33 = Utf8               v
  #34 = Utf8               D
  #35 = Utf8               method3
  #36 = Utf8               ()D
  #37 = Utf8               num
  #38 = Utf8               SourceFile
  #39 = Utf8               StackFrameTest.java
  #40 = NameAndType        #18:#19        // "<init>":()V
  #41 = Utf8               com/yjy/JVMTEST/StackFrameTest
  #42 = NameAndType        #30:#19        // method1:()V
  #43 = Class              #56            // java/lang/System
  #44 = NameAndType        #57:#58        // out:Ljava/io/PrintStream;
  #45 = Utf8               method1方法开始执行
  #46 = Class              #59            // java/io/PrintStream
  #47 = NameAndType        #60:#61        // println:(Ljava/lang/String;)V
  #48 = NameAndType        #31:#32        // method2:()I
  #49 = Utf8               method1方法执行结束
  #50 = Utf8               method2方法开始执行
  #51 = NameAndType        #35:#36        // method3:()D
  #52 = Utf8               method2方法执行结束
  #53 = Utf8               method3方法开始执行
  #54 = Utf8               method3方法执行结束
  #55 = Utf8               java/lang/Object
  #56 = Utf8               java/lang/System
  #57 = Utf8               out
  #58 = Utf8               Ljava/io/PrintStream;
  #59 = Utf8               java/io/PrintStream
  #60 = Utf8               println
  #61 = Utf8               (Ljava/lang/String;)V
{
  public com.yjy.JVMTEST.StackFrameTest();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         4: return
      LineNumberTable:
        line 7: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       5     0  this   Lcom/yjy/JVMTEST/StackFrameTest;

  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=2, args_size=1
         0: new           #2                  // class com/yjy/JVMTEST/StackFrameTest
         3: dup
         4: invokespecial #3                  // Method "<init>":()V
         7: astore_1
         8: aload_1
         9: invokevirtual #4                  // Method method1:()V
        12: return
      LineNumberTable:
        line 10: 0
        line 11: 8
        line 12: 12
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      13     0  args   [Ljava/lang/String;
            8       5     1  test   Lcom/yjy/JVMTEST/StackFrameTest;

  public void method1();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=1, args_size=1
         0: getstatic     #5                  // Field java/lang/System.out:Ljava/io/PrintStream;
         3: ldc           #6                  // String method1方法开始执行
         5: invokevirtual #7                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
         8: aload_0
         9: invokevirtual #8                  // Method method2:()I
        12: pop
        13: getstatic     #5                  // Field java/lang/System.out:Ljava/io/PrintStream;
        16: ldc           #9                  // String method1方法执行结束
        18: invokevirtual #7                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
        21: return               // 方法1的返回值为void
      LineNumberTable:
        line 15: 0
        line 16: 8
        line 17: 13
        line 18: 21
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      22     0  this   Lcom/yjy/JVMTEST/StackFrameTest;

  public int method2();
    descriptor: ()I
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=3, args_size=1
         0: getstatic     #5                  // Field java/lang/System.out:Ljava/io/PrintStream;
         3: ldc           #10                 // String method2方法开始执行
         5: invokevirtual #7                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
         8: aload_0
         9: invokevirtual #11                 // Method method3:()D
        12: dstore_1
        13: getstatic     #5                  // Field java/lang/System.out:Ljava/io/PrintStream;
        16: ldc           #12                 // String method2方法执行结束
        18: invokevirtual #7                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
        21: dload_1
        22: d2i
        23: iconst_2
        24: imul
        25: ireturn         // 方法2的返回值为int
      LineNumberTable:
        line 21: 0
        line 22: 8
        line 23: 13
        line 24: 21
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      26     0  this   Lcom/yjy/JVMTEST/StackFrameTest;
           13      13     1     v   D

  public double method3();
    descriptor: ()D
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=3, args_size=1
         0: getstatic     #5                  // Field java/lang/System.out:Ljava/io/PrintStream;
         3: ldc           #13                 // String method3方法开始执行
         5: invokevirtual #7                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
         8: ldc2_w        #14                 // double 2.1d
        11: dstore_1
        12: getstatic     #5                  // Field java/lang/System.out:Ljava/io/PrintStream;
        15: ldc           #16                 // String method3方法执行结束
        17: invokevirtual #7                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
        20: dload_1
        21: dreturn          // 方法3的返回值为double
      LineNumberTable:
        line 28: 0
        line 29: 8
        line 30: 12
        line 31: 20
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      22     0  this   Lcom/yjy/JVMTEST/StackFrameTest;
           12      10     1   num   D
}
SourceFile: "StackFrameTest.java"

```



#### 2.3 栈帧的内部结构

- 局部变量表(Local Variables)
- 操作数栈(operand stack，或表达式栈)
- 动态链接(Dynamic Linking)(或指向运行时常量池的方法引用)
- 方法返回地址(Return address)(或方法正常退出或者异常退出的定义)
- 一些附加信息

注意：在一些地方将方法返回地址、动态链接、一些附加信息称为帧数据区。

![image-20240627002421703](%E4%BA%94%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.assets/image-20240627002421703.png)

多个线程中的栈帧结构

![image-20240627002441770](%E4%BA%94%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.assets/image-20240627002441770.png)



### 3、局部变量表（Local Variables）

#### 3.1 说明

- 局部变量表也被称之为局部变量数组或亦地变量表。

- 定义为一个数字数组（一维数组），主要用于存储**方法参数**和**定义在方法体内的局部变量**这些数据类型包括各类基本数据类型、对象引用(reerence)，以及**returnAddress类型**。

  对如下数据的字节码文件通过javap命令进行解析

  ```java
  /**
   * @author banana
   * @create 2024-06-27 21:32
   */
  public class LocalVariablesTest {
  
      public static void main(String[] args) {
          LocalVariablesTest localVariablesTest = new LocalVariablesTest();
          int num = 10;
      }
  }
  
  ```

  解析结果

  ```
  D:\codesaver\UtilsTest\target\classes\com\yjy\JVMTEST>javap -v LocalVariablesTest.class
  Classfile /D:/codesaver/UtilsTest/target/classes/com/yjy/JVMTEST/LocalVariablesTest.class
    Last modified 2024-6-27; size 534 bytes
    MD5 checksum 9a00a99d41b4c7f787dbdf0401cfaa7b
    Compiled from "LocalVariablesTest.java"
  public class com.yjy.JVMTEST.LocalVariablesTest
    minor version: 0
    major version: 52
    flags: ACC_PUBLIC, ACC_SUPER
  Constant pool:
     #1 = Methodref          #4.#22         // java/lang/Object."<init>":()V
     #2 = Class              #23            // com/yjy/JVMTEST/LocalVariablesTest
     #3 = Methodref          #2.#22         // com/yjy/JVMTEST/LocalVariablesTest."<init>":()V
     #4 = Class              #24            // java/lang/Object
     #5 = Utf8               <init>
     #6 = Utf8               ()V
     #7 = Utf8               Code
     #8 = Utf8               LineNumberTable
     #9 = Utf8               LocalVariableTable
    #10 = Utf8               this
    #11 = Utf8               Lcom/yjy/JVMTEST/LocalVariablesTest;
    #12 = Utf8               main
    #13 = Utf8               ([Ljava/lang/String;)V
    #14 = Utf8               args
    #15 = Utf8               [Ljava/lang/String;
    #16 = Utf8               localVariablesTest
    #17 = Utf8               num
    #18 = Utf8               I
    #19 = Utf8               MethodParameters
    #20 = Utf8               SourceFile
    #21 = Utf8               LocalVariablesTest.java
    #22 = NameAndType        #5:#6          // "<init>":()V
    #23 = Utf8               com/yjy/JVMTEST/LocalVariablesTest
    #24 = Utf8               java/lang/Object
  {
    public com.yjy.JVMTEST.LocalVariablesTest();
      descriptor: ()V
      flags: ACC_PUBLIC
      Code:
        stack=1, locals=1, args_size=1
           0: aload_0
           1: invokespecial #1                  // Method java/lang/Object."<init>":()V
           4: return
        LineNumberTable:
          line 7: 0
        LocalVariableTable:
          Start  Length  Slot  Name   Signature
              0       5     0  this   Lcom/yjy/JVMTEST/LocalVariablesTest;
  
    public static void main(java.lang.String[]);
      descriptor: ([Ljava/lang/String;)V
      flags: ACC_PUBLIC, ACC_STATIC
      Code:
        stack=2, locals=3, args_size=1
           0: new           #2                  // class com/yjy/JVMTEST/LocalVariablesTest
           3: dup
           4: invokespecial #3                  // Method "<init>":()V
           7: astore_1
           8: bipush        10
          10: istore_2
          11: return
        LineNumberTable:
          line 10: 0
          line 11: 8
          line 12: 11
        LocalVariableTable:
          Start  Length  Slot  Name   Signature
              0      12     0  args   [Ljava/lang/String;
              8       4     1 localVariablesTest   Lcom/yjy/JVMTEST/LocalVariablesTest;
             11       1     2   num   I
      MethodParameters:
        Name                           Flags
        args
  }
  SourceFile: "LocalVariablesTest.java"
  
  ```

  可以看到其中有个局部变量表中信息，一共有三个，分别是形参args，当前类对象localVariablesTest以及定义的int类型num。

  ```
  LocalVariableTable:
          Start  Length  Slot  Name   Signature
              0      12     0  args   [Ljava/lang/String;
              8       4     1 localVariablesTest   Lcom/yjy/JVMTEST/LocalVariablesTest;
             11       1     2   num   I
  ```

- 由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题

- 局部变量表所需的容量大小是在编译期（编译完成后就确定）确定下来的，并保存在方法的Code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的。

  通过jclasslib查看maximum local variables的值如下所示，即可确定是在类完成编译后，生成class文件后，就确定下来

  ![image-20240627214924181](%E4%BA%94%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.assets/image-20240627214924181.png)

- 方法嵌套调用的次数由栈的大小决定。一般来说，越大，方法套调用次数越多。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少，
- 局部变量表中的变量只在当前方法调用中有效。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后随着方法栈帧的销毁，局部变量表也会随之销毁，



#### 3.2 字节码中方法内部结构剖析

配合jclasslib（也可以通过javap -v命令，反汇编 Java 类文件并打印出类的详细信息，反汇编 Java 类文件的主要目的是让开发人员能够查看类的内部结构和实现细节，以便进行调试、分析和优），就如下代码的字节码进行深入理解

```java
/**
 * @author banana
 * @create 2024-06-27 21:32
 */
public class LocalVariablesTest {

    public static void main(String[] args) {
        LocalVariablesTest localVariablesTest = new LocalVariablesTest();
        int num = 10;
    }
}
```

![image-20240627223400639](%E4%BA%94%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.assets/image-20240627223400639.png)

说明如下

![image-20240627222106637](%E4%BA%94%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.assets/image-20240627222106637.png)

![image-20240627222327594](%E4%BA%94%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.assets/image-20240627222327594.png)

![image-20240627222342258](%E4%BA%94%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.assets/image-20240627222342258.png)

![image-20240627222617065](%E4%BA%94%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.assets/image-20240627222617065.png)

![image-20240627222658592](%E4%BA%94%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.assets/image-20240627222658592.png)

![image-20240627223822399](%E4%BA%94%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.assets/image-20240627223822399.png)

#### 3.3 关于Slot的理解和演示

##### 1.说明

- 参数值的存放总是在局部变量数组的index0开始，到数组长度-1的索引结束。
- 局部变量表，最基本的存储单元是slot(变量槽)
- 局部变量表中存放编译期可知的各种基本数据类型(8种)，引用类型(reference)，returnAddress类型的变量。
- 在局部变量表里，32位以内的类型只占用一个slot(包括return Address类型)，64位的类型(long和double)占用两个slot。>
  - byte、short、char 在存储前被转换为int，boolean 也被转换为int，0表示false，非0表示true，占据1个slot
  - long 和double ，占据两个slot
- JVM会为局部变量表中的每一个slot都分配一个访问索引，通过这个素引即可成功访问到局部变量表中指定的局部变量值
- 当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照声明顺序被复制到局部变量表中的每一个slot上
- 如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。(比如:访问long或double类型变量，及通过起始地址进行访问占用2个slot的内容)
- 如果当前帧是由构造方法或者实例方法创建的（即在构造方法或实例方法中调用）那么该对象引用this将会存放在index为0的slot处，其余的参数按照参数表顺序继续排列。
  - 在Java中，当一个类的对象被创建时，它的方法并不会立即作为栈帧（stack frame）被塞入虚拟机栈（JVM stack）中。当对象的方法被调用时，才会生成对应的栈帧并入栈。栈帧是在方法执行过程中动态创建的，包含了方法执行所需的所有信息。每次方法调用，都会生成一个新的栈帧，该栈帧包含了方法执行的上下文信息。
  - 构造方法：当对象被创建时（使用 `new` 关键字），会调用相应的构造方法来初始化对象，当一个构造方法被调用时，它也会创建一个当前帧来执行其中的代码。
  - 实例方法：实例方法在对象创建后，通过对象引用（即 `this` 关键字）来调用，this可能是隐式的。

##### 2.图示

![image-20240627234852421](%E4%BA%94%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.assets/image-20240627234852421.png)

##### 3.具体演示

```java
/**
 * @author banana
 * @create 2024-06-27 21:32
 */
public class LocalVariablesTest {

    public static void main(String[] args) {
        LocalVariablesTest localVariablesTest = new LocalVariablesTest();
        int num = 10;
    }
    
    private int count;
    
    // 构造方法
    public LocalVariablesTest(){
        this.count = 1;
    }
    
    public void test1() {
        Date date = new Date();
        String name = "name";
        test2(date, name);
        
    }
    
    public String test2(Date date, String name) {
        date = null;
        name = "123";
        double db = 2.0;
        char gender = '男';
        return name + "33";
    }
    
}
```

分析构造方法，和两个实例方法

构造方法的局部变量表（可以看到其吧this放入了第一个slot）

![image-20240627235855182](%E4%BA%94%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.assets/image-20240627235855182.png)

test1方法的局部变量表（如果这里写成String tmp = test2(date, name);那么局部变量表中会多一个局部变量，因为这里没有赋值产生局部变量所以没有）

![image-20240627235916408](%E4%BA%94%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.assets/image-20240627235916408.png)

test2方法的局部变量表，可以看到double类型占了2个Slot，其序号跨越了

![image-20240627235959794](%E4%BA%94%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.assets/image-20240627235959794.png)



#### 3.4 关于Slot的重复利用

栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。

示例：

```java
 public void test4() {
    int a = 0;
    {
        int b = 0;
        b = a + 1;
        // b的作用域到此结束
    }
    int c = a + 1;
}
```

其局部变量表如下，可以看到c复用了b的slot

![image-20240628000536464](%E4%BA%94%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.assets/image-20240628000536464.png)

#### 3.5 静态变量与局部变量的对比

##### 1.变量分类说明

按照数据类型分类：

- 基本数据类型  
- 引用数据类型

按照在类中声明的位置分类：

- 成员变量：成员变量定义在类体中，但在任何方法之外，都经历过默认初始化赋值。

  - 类变量：类变量是在类中声明的变量，并且使用`static`关键字修饰。这意味着类变量与类本身关联，而不是与类的任何特定实例关联。

    类变量的值初始化过程：在类加载子系统的链接阶段（linking）的准备（prepare）过程赋予默认值，在初始化过程（initialization）阶段给类变量显示赋值以及静态代码块内容的执行。

  - 实例变量：实例变量是在类中声明的变量，但没有使用`static`关键字修饰。这意味着实例变量与类的特定实例（即对象）关联。

    实例对象的值初始化过程：随着对象的创建，会在堆空间中分配实例变量空间，并进行默认赋值。

- 局部变量：局部变量定义在方法体中，或在任何控制结构（如for循环）中。注意：在使用前，必须进行显示的赋值，否则在使用该局部变量的时候，会发生编译不同的问题。

##### 2. 静态变量与局部的对比

- 参数表（通常指的是在方法/函数定义时列出的参数列表，这些参数用于在方法被调用时接收外部传入的值）分配完毕之后，再根据方法体内定义的局部变量的顺序和作用域分配。如果执行的是实例方法（即非静态方法），局部变量表的第0位索引通常用于存储隐式参数`this`，该参数指向调用该方法的对象实例。【只有隐式参数this、参数表、局部变量会加入到局部变量表中】
- 类变量表有两次初始化的机会，第一次是在“准备阶段”，执行系统初始化，对类变量设置零值，另一次则是在“初始化”阶段，赋予程序员在代码中定义的初始值。
- 和类变量初始化不同的是，局部变量表不存在系统初始化的过程，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。
- 在栈帧中，与性能调优关系最为密切的部分就是前面提到的局部变量表在方法执行时，虚拟机使用局部变量表完成方法的传递。
- 局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。



### 4、操作数栈（Operand Stack）

#### 4.1 操作数栈的特点

- 每一个独立的栈帧中除了包含局部变量表以外，还包含一个后进先出(Last-In-First-Out)的操作数栈，也可以称之为表达式栈（Expression Stack)

- 操作数栈，在方法执行过程中，根据字节码指令，往中写入数据或提取数据，即入栈(push)/出栈(pop)。

  - 某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈，如:执行复制、交换、求和等操作

    示例：

    ![image-20240629161735470](%E4%BA%94%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.assets/image-20240629161735470.png)

- 操作数栈，主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。

- 操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候一个新的栈帧也会随之被创建出来，此时这个栈帧中的操作数栈是空的。

- 每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为max_stack的值(java -p 编译的即对应如下Code中的stack的值)。

  ```
   Code:
        stack=2, locals=3, args_size=1
  ```

- 栈中的任何一个元素都是可以任意的Java数据类型

  - 32bit的类型占用一个栈单位深度
  - 64bit的类型占用两个栈单位深度

- 操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈(push)和出栈(pop)操作来完成一次数据访问。
- 如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令。
- 操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证（确认操作数栈的深度），同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。
- Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈。



#### 4.2 代码追踪-操作数

##### 1. 代码跟踪操作1

创建一个测试类。如下所示

```java
public class OperandStackTest {
    
    public void testAddOperation() {
        int i = 10;
        int j = 20;
        int k = i + j;
    }
}

```

将该java类编译成字节码文件后，通过javap -v 或 通过jclasslib查看字节码文件反汇编后的内容。

> 就javap -v的说明：
>
> `javap -v` 是一个用于分析 Java 类文件的命令。它的全称是 `Java Class File Disassembler`，意思是 Java 类文件反汇编器。通过这个命令，可以查看和分析 Java 类文件的详细信息，包括类的结构、字段、方法、常量池以及其他属性。具体来说：
>
> - `javap`: 这是一个 Java 开发工具包（JDK）提供的命令行工具，用于反汇编 Java 类文件。
> - `-v`: 这是 `javap` 命令的一个选项，表示输出详细信息（verbose），包括类的所有成员、方法等详细内容。
>
> 使用 `javap -v ClassName` 命令时，将 `ClassName` 替换为你要分析的 Java 类的名称。例如，如果你有一个名为 `Example` 的类，你可以运行以下命令来查看其详细信息

具体的操作指令如下所示

```
 0 bipush 10    // 将10放入到操作数栈中（这里的b表示byte类型，但是存的时候都是转化为int存储到slot槽中的）
 2 istore_1	    // 将10从操作数栈中取出，放入局部变量表索引为1的位置（这里取出的时候已经是int类型） 
 3 bipush 20    // 将20放入到操作数栈中
 5 istore_2     // 将20从操作数栈中取出，放入局部变量表索引为2的位置
 6 iload_1      // 取出局部病例表中索引为1的值放入操作数栈 即 10
 7 iload_2		// 取出局部病例表中索引为2的值放入操作数栈 即 20
 8 iadd			// 取出操作数栈中的两个内容，通过执行引擎将以翻译成机器指令，通过机器指令进行求和，然后就爱那个结果30再次放入到操作数栈中
 9 istore_3		// 就相加结果30从操作数栈中取出，放如局部变量索引为3的位置
10 return
```

运行完结果如下图所示

![image-20240630161547546](%E4%BA%94%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.assets/image-20240630161547546.png)



##### 2.代码跟踪操作2

关于如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令的验证：

测试类代码如下图所示

```java
public class OperandStackTest {

    public int getSum() {
        int i = 10;
        int j = 20;
        int k = i + j;
        return k;
    }

    public void testGetSum() {
        int i = getSum();
        int j = 10;
    }
}

```

getSum方法的指令

```
 0 bipush 10
 2 istore_1
 3 bipush 20
 5 istore_2
 6 iload_1
 7 iload_2
 8 iadd
 9 istore_3
10 iload_3
11 ireturn		// 将k值返回

```

上述方法返回k值后，其栈帧结束，当前栈帧变换为testGetSum，其中testGetSum方法指令如下

```
0 aload_0	// 获取上一个栈帧返回的结果，并保存到操作数栈中
1 invokevirtual #2 <com/yjy/JVMTEST/OperandStackTest.getSum>
4 istore_1
5 bipush 10
7 istore_2
8 return

```



#### 4.3 栈顶缓存（Top-of-Stack-Cashing）技术

前面提过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派(instruction dispatch)次数和内存读/写次数
由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存(ToS，Top-of-stackCashing)技术，将栈顶元素全部缓存在物理cPu的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率

缓存内容：

- **局部变量**：方法内部定义的局部变量，比如基本数据类型（如`int`、`float`等）和对象引用。这些变量在方法调用时常被频繁访问，因此将它们缓存到栈顶可以提高访问效率
- **中间计算结果**：在进行一些计算时产生的临时变量或中间结果，也可能被存储在栈顶，以便于后续的计算使用
- **方法参数**：在方法调用时传递的参数，如果这些参数在方法体内频繁使用，可以被直接缓存到栈顶部

示例：

```java
public class Example {
    public void calculate() {
        int a = 5;
        int b = 10;
        int c = a + b;
        // 进行一些计算
    }
}
```

假设`calculate`方法被频繁调用。在使用栈顶缓存技术时，JVM可能会将`a`和`b`的值直接保存在栈顶。当方法再次调用时，它们可以被快速访问，而不是每次都从局部变量表中查找。



### 5、动态链接（Dynamic Linking）

#### 5.1 概念说明

- 每一个栈帧（即对应每一个方法）内部都包含一个指向运行时常量池中该栈帧所属方法的引用（即动态链接）。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接(Dynamic Linking)。比如:invokedynamic指令。
- 在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用(Symbolic Reference)保存在class文件的常量池里比如:描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。

#### 5.2 具体示例

创建一个测试代码：

```java
public class DynamicLinkingTest {

    int num = 1;
    
    public void methodA() {
        System.out.println("methodA方法被调用……");
    }

    public void methodB() {
        System.out.println("MethodB方法被调用");
        methodA();
        
        num ++;
    }
}
```

通过javap -v 反汇编一下其 字节码文件，其结果如下所示

```
D:\codesaver\UtilsTest\target\classes\com\yjy\JVMTEST>javap -v DynamicLinkingTest.class
Classfile /D:/codesaver/UtilsTest/target/classes/com/yjy/JVMTEST/DynamicLinkingTest.class
  Last modified 2024-6-30; size 731 bytes
  MD5 checksum 9ac307e34e4b94f832415799ec44e986
  Compiled from "DynamicLinkingTest.java"
public class com.yjy.JVMTEST.DynamicLinkingTest
  minor version: 0
  major version: 52
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
   #1 = Methodref          #9.#23         // java/lang/Object."<init>":()V
   #2 = Fieldref           #8.#24         // com/yjy/JVMTEST/DynamicLinkingTest.num:I
   #3 = Fieldref           #25.#26        // java/lang/System.out:Ljava/io/PrintStream;
   #4 = String             #27            // methodA方法被调用……
   #5 = Methodref          #28.#29        // java/io/PrintStream.println:(Ljava/lang/String;)V
   #6 = String             #30            // MethodB方法被调用
   #7 = Methodref          #8.#31         // com/yjy/JVMTEST/DynamicLinkingTest.methodA:()V
   #8 = Class              #32            // com/yjy/JVMTEST/DynamicLinkingTest
   #9 = Class              #33            // java/lang/Object
  #10 = Utf8               num
  #11 = Utf8               I
  #12 = Utf8               <init>
  #13 = Utf8               ()V
  #14 = Utf8               Code
  #15 = Utf8               LineNumberTable
  #16 = Utf8               LocalVariableTable
  #17 = Utf8               this
  #18 = Utf8               Lcom/yjy/JVMTEST/DynamicLinkingTest;
  #19 = Utf8               methodA
  #20 = Utf8               methodB
  #21 = Utf8               SourceFile
  #22 = Utf8               DynamicLinkingTest.java
  #23 = NameAndType        #12:#13        // "<init>":()V
  #24 = NameAndType        #10:#11        // num:I
  #25 = Class              #34            // java/lang/System
  #26 = NameAndType        #35:#36        // out:Ljava/io/PrintStream;
  #27 = Utf8               methodA方法被调用……
  #28 = Class              #37            // java/io/PrintStream
  #29 = NameAndType        #38:#39        // println:(Ljava/lang/String;)V
  #30 = Utf8               MethodB方法被调用
  #31 = NameAndType        #19:#13        // methodA:()V
  #32 = Utf8               com/yjy/JVMTEST/DynamicLinkingTest
  #33 = Utf8               java/lang/Object
  #34 = Utf8               java/lang/System
  #35 = Utf8               out
  #36 = Utf8               Ljava/io/PrintStream;
  #37 = Utf8               java/io/PrintStream
  #38 = Utf8               println
  #39 = Utf8               (Ljava/lang/String;)V
{
  int num;
    descriptor: I
    flags:

  public com.yjy.JVMTEST.DynamicLinkingTest();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         4: aload_0
         5: iconst_1
         6: putfield      #2                  // Field num:I
         9: return
      LineNumberTable:
        line 7: 0
        line 9: 4
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      10     0  this   Lcom/yjy/JVMTEST/DynamicLinkingTest;

  public void methodA();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=1, args_size=1
         0: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;
         3: ldc           #4                  // String methodA方法被调用……
         5: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
         8: return
      LineNumberTable:
        line 12: 0
        line 13: 8
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       9     0  this   Lcom/yjy/JVMTEST/DynamicLinkingTest;

  public void methodB();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=3, locals=1, args_size=1
         0: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;
         3: ldc           #6                  // String MethodB方法被调用
         5: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
         8: aload_0
         9: invokevirtual #7                  // Method methodA:()V
        12: aload_0
        13: dup
        14: getfield      #2                  // Field num:I
        17: iconst_1
        18: iadd
        19: putfield      #2                  // Field num:I
        22: return
      LineNumberTable:
        line 16: 0
        line 17: 8
        line 19: 12
        line 20: 22
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      23     0  this   Lcom/yjy/JVMTEST/DynamicLinkingTest;
}
SourceFile: "DynamicLinkingTest.java"

```

可以从上看到，在methodB中调用methdoA的字节码指令，其实通过调用虚方法invokevirtual来实现的

```
9: invokevirtual #7                  // Method methodA:()V
```

#7是在字节码文件中的常量池Constant pool（当字节码文件运行起来后，就会将引用的内容放到对应的方法区的运行时常量池中）中声明符号引用，右边就是其真实引用的内容在哪里，并且可以看到还有继续的嵌套引用存在。

```
Constant pool:
   #1 = Methodref          #9.#23         // java/lang/Object."<init>":()V
   #2 = Fieldref           #8.#24         // com/yjy/JVMTEST/DynamicLinkingTest.num:I
   #3 = Fieldref           #25.#26        // java/lang/System.out:Ljava/io/PrintStream;
   #4 = String             #27            // methodA方法被调用……
   #5 = Methodref          #28.#29        // java/io/PrintStream.println:(Ljava/lang/String;)V
   #6 = String             #30            // MethodB方法被调用
   #7 = Methodref          #8.#31         // com/yjy/JVMTEST/DynamicLinkingTest.methodA:()V
   #8 = Class              #32            // com/yjy/JVMTEST/DynamicLinkingTest
   #9 = Class              #33            // java/lang/Object
  #10 = Utf8               num
  #11 = Utf8               I
  #12 = Utf8               <init>
  #13 = Utf8               ()V
  #14 = Utf8               Code
  #15 = Utf8               LineNumberTable
  #16 = Utf8               LocalVariableTable
  #17 = Utf8               this
  #18 = Utf8               Lcom/yjy/JVMTEST/DynamicLinkingTest;
  #19 = Utf8               methodA
  #20 = Utf8               methodB
  #21 = Utf8               SourceFile
  #22 = Utf8               DynamicLinkingTest.java
  #23 = NameAndType        #12:#13        // "<init>":()V
  #24 = NameAndType        #10:#11        // num:I
  #25 = Class              #34            // java/lang/System
  #26 = NameAndType        #35:#36        // out:Ljava/io/PrintStream;
  #27 = Utf8               methodA方法被调用……
  #28 = Class              #37            // java/io/PrintStream
  #29 = NameAndType        #38:#39        // println:(Ljava/lang/String;)V
  #30 = Utf8               MethodB方法被调用
  #31 = NameAndType        #19:#13        // methodA:()V
  #32 = Utf8               com/yjy/JVMTEST/DynamicLinkingTest
  #33 = Utf8               java/lang/Object
  #34 = Utf8               java/lang/System
  #35 = Utf8               out
  #36 = Utf8               Ljava/io/PrintStream;
  #37 = Utf8               java/io/PrintStream
  #38 = Utf8               println
  #39 = Utf8               (Ljava/lang/String;)V
```

在调用属性的时候，即num ++的时候，其也会有引用

```
14: getfield      #2                  // Field num:I
```

上面的#xx，符号引用，就是我们所说的动态链接即指向运行时常量池的方法的引用，注意字节码文件运行起来后，其常量池内容就放到方法区中，称为运行时常量池。

#### 5.3 动态链接图

![image-20240630173242068](%E4%BA%94%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.assets/image-20240630173242068.png)

注意：运行时常量池中的内容就是字节码文件中的常量池信息，一些引用信息，只不过是运行的时候，才将字节码中的常量池放到的方法区中的运行时常量池中。



#### 5.4 为什么

##### 1. 为什么要有需要符号引用

- 方便复用，直接通过引用的方式即可将对应的代码引入到某个代码中进行使用

- 如果一个类生成的字节码文件里面什么东西都直接存放，而不是通过引用的方式，会很大，存在冗余。

##### 2.为什么需要常量池

常量池的作用，就是为了听一些符号和常量，便于指令的识别。



### 6、方法的调用

#### 6.1 说明

在JVM中，将符号引用转化为调用方法的直接引用与方法的绑定机制相关。

**其中可以细分为静态链接和动态链接：**

- 静态链接

当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期可知，且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接。

- 动态链接

如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接。



**静态链接和动态链接同时也对应方法的绑定机制：早期绑定（Early Binding ）和晚期绑定（Late Binding）**。绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。

- 早期绑定

早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。

- 晚期绑定

如果被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式也就被称之为晚期绑定。



随着高级语言的横空出世，类似于Java一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都文持封装、继承和多态等面向对象特性既然这一类的编程语言具备多态特性，那么自然也就具备早期绑定和晚期绑定两种绑定方式。
Java中任何一个普通的方法其实都具备虚函数的特征，它们相当于C++语言中的虚函数(C++中则需要使用关键字virtual来显式定义)。如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字final（类不能被继承，不具有多态的特征）来标记这个方法。



#### 6.2 虚方法与非虚方法

##### 非虚方法

1.概念：

- 即动态链接或晚期绑定。
- 如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的这样的方法称为非虚方法
- 静态方法（不可被重写）、私有方法（不可被重写）、final方法（不可被继承，也不可被重写）、实例构造器（当前类中调用this方式调用其他构造器也是确定的）、父类方法（super方式调用，也是确定的）都是非虚方法
- 其他方法称为虚方法

2.补充：

子类对象的多态性的使用前提 ①类的继承关系 ②方法的重写

3.示例



#### 6.3 方法调用指令

**虚拟机提供了几种方法调用的指令，如下所示**

**1.普通调用指令**

- invokestatic：调用静态方法，解析阶段确定唯一方法版本（非虚方法）
- invokespecial：调用<init>方法、私有及父类方法，解析阶段确定唯一方法版本（非虚方法）
- invokevirtual：调用所有虚方法（final修饰的除外）
- invokeinterface：调用接口方法

普通调用指令示例：

```java
package com.example.JVMTEST.VirtualMethod;

/**
 * 解析调用汇总废墟方法、虚方法测试
 * @author banana
 * @create 2024-10-05 16:20
 */
public class Son extends Father{

    public Son() {
        // invokespecial
        super();
    }

    public Son(int age) {
        // invokespecial
        this();
    }

    // 注：父类静态方法无法被重写
    public static  void showStatic(String str) {
        System.out.println("son " + str);
    }

    // 私有方法
    private void showPrivate(String str) {
        System.out.println("son private " + str);
    }

    public void show() {
        // invokestatic(非虚方法)
        showStatic("banana");
        // invokestatic(非虚方法)
        super.showStatic("banana");
        // invokespecial(非虚方法)
        showPrivate("banana");
        // invokespecial(非虚方法)
        super.showCommon();

        // invokevirtual（但仍然是非虚方法，声明final不能被子类重写）
        showFinal();
        // invokespecial
        super.showFinal();
        // invokevirtual(虚方法，没有加super或this，如果子类重写了，就会出现多态的特性，编译过程中确定不下来)
        showCommon();
        info();

        // invokeinterface（体现虚方法，使用实现类中的方法）
        MethodInterface in = null;
        in.methodA();
    }

    public void info() {}

    public void display(Father f) {
        f.showCommon();
    }

    public static void main(String[] args) {
        Son so = new Son();
        so.show();
    }

}

interface MethodInterface{
    void methodA();
}

class Father {
    public Father() {
        System.out.println("Fatherd的构造器");
    }

    // 静态方法
    public static void showStatic(String str) {
        System.out.println("father " + str);
    }

    // final方法
    public final void showFinal() {
        System.out.println("father show final");
    }

    // 普通方法
    public void showCommon() {
        System.out.println("father show common");
    }

}

```



**2.动态调用指令**

- invokedynamic：动态解析出需要调用的方法，然后执行

前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而invokedynamic指令则支持由用户确定方法版本。其中invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的(final修饰的除外)称为虚方法。



JVM字节码指令集一直比较稳定，一直到Java7中才增加了一个invokedynamic指令，这是Java为了实现「动态类型语言」支持而做的种改进。
但是在Java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具来产生invokedynamic指令。直到Java8的Lambda表达式的出现，invokedynamic指令的生成，在Java中才有了直接的生成方式。
Java7中增加的动态语言类型支持的本质是对Java虚拟机规范的修改，而不是对Java语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在Java平台的动态语言的编译器。



关于动态类型语言和静态类型语言

动态类型语言和静态类型语言两者的区别就在于对类型的检查是在编译期还是在运行期，满足前者就是静态类型语言，反之是动态类型语言。
说的再直白一点就是，静态类型语言是判断变量自身的类型信息;动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息，这是动态语言的一个重要特征。



示例

```java
@FunctionalInterface
interface Func {
    public boolean func(String str);
}

public class Lambda {

    public void lambda(Func func) {
        return;
    }

    public static void main(String[] args) {
        // invokespecial
        Lambda lambda = new Lambda();

        // invokedynamic
        Func func = s -> {
            return true;
        };

        //  invokedynamic
        lambda.lambda(func);

        //  invokedynamic
        lambda.lambda(s -> {
            return true;
        });
    }

}
```

![image-20241006004612102](%E4%BA%94%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.assets/image-20241006004612102.png)





#### 6.4 方法重写的本质

**Java重写方法的本质**

- 找到操作数栈顶的第一个元素所执行的对象的实际类型，记作C。

Java 虚拟机在执行方法时，会使用一个操作数栈来存放方法调用的参数和返回值等信息。当一个方法被调用时，相关的对象引用会放在这个栈的顶部。在方法调用时，虚拟机会找到操作数栈顶的第一个元素，这通常是调用方法的对象（即 `this` 引用）。这个对象的实际类型是指它在内存中创建的具体类，而不是声明类型。比如，如果有一个 `Dog` 类继承自 `Animal` 类，而你用 `Animal myDog = new Dog();` 创建了一个 `Dog` 对象，那么在此情况下，`myDog` 的实际类型是 `Dog`，这里的 `C` 表示当前对象的实际类型。在上面的例子中，`C` 就是 `Dog`

- 如果在类型C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束;如果不通过，则返回java.lang.IllegalAccessError 异常。

当 Java 虚拟机确定了对象的实际类型 `C` 后，它会在 `C` 类中查找一个与调用的方法名称和参数类型完全匹配的方法。这就是所谓的“方法签名”，包括方法的名称和参数的类型。如果在类 `C` 中找到了匹配的方法，虚拟机会检查该方法的访问权限：

public：可以被任何类访问。

protected：可以被同一包内的类或子类访问。

默认（包私有）：只能被同一包内的类访问。

private：只能被该类内的方法访问。

如果调用者（即当前对象）没有权限访问这个方法，则抛出 `java.lang.IllegalAccessError` 异常

- 否则，按照继承关系从下往上依次对c的各个父类进行第 2步的搜索和验证过程。
- 如果始终没有找到合适的方法，则抛出 java.lang.AbstractMethodError异常



关于IllegalAccessError说明：

程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。



#### 6.5 虚方法表

- 在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，为了提高性能，I采用在类的方法区建立一个虚方法表(virtual method table)(非虚方法不会出现在表中)来实现。使用索引表来代替查找。

- 每个类中都有一个虚方法表，表中存放着各个方法的实际入口

- 那么虚方法表什么时候被创建?

  虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，IM会把该类的方法表也初始化完毕。



具体示例：

![image-20241006013450656](%E4%BA%94%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.assets/image-20241006013450656.png)

![image-20241006013457946](%E4%BA%94%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.assets/image-20241006013457946.png)

![image-20241006013505912](%E4%BA%94%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.assets/image-20241006013505912.png)



#### 6.6、方法返回地址

**概念**

- 存放调用该方法的pc寄存器（其存储的是下一条需要执行的指令值）的值

  如在一个虚拟机栈中，有方法A和方法B两个栈帧（B为当前栈帧），B的方法返回地址存储的即是A方法调用B方法后的下一条指令地址

- 一个方法的结束，有两种方式:
  - 正常执行完成
  - 出现未处理的异常，非正常退出
- 无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。
- 本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。
- 正常完成出口和异常完成出口的区别在于:通过异常完成出口退出的不会给他的上层调用者产生任何的返回值



**退出方法的两种方式**

- 执行引擎遇到任意一个方法返回的字节码指令(return)，会有返回值传递给上层的方法调用者，简称正常完成出口

  - 一个方法在正常调用完成之后究竟需要使用哪一个返回指令还需要根据方法返回值 的实际数据类型而定。
  - 在字节码指令中，返回指令包含ireturn(当返回值是boolean、byte、char.short和int类型时使用)、lreturn（长整型类型）、freturn（浮点）、dreturn（双精度）以及areturn（引用类型），另外还有一个return指令供声明为void的方法、实例初始化方法、类和接口的初始化方法使用。

- 在方法执行的过程中遇到了异常(Exception)，并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出。简称异常完成出口。

  方法执行过程中抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码。

  如下是异常处理表，from to表示从第几行到第几行指令中出现问题，到target进行处理，类型type可以是任意any。

![image-20241006113657779](%E4%BA%94%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.assets/image-20241006113657779.png)



**方法返回地址和方法类型**

- **方法返回地址**

  - 位置: 方法返回地址通常存储在栈帧的顶部或某个特定的位置，具体实现可能会有所不同。它指向调用该方法的下一条指令的位置。

  - 作用: 当方法执行完毕后，JVM会使用这个返回地址跳转回调用该方法的位置，以继续执行程序。

- **方法返回类型**

  - 定义: 方法返回类型是在方法定义时指定的，比如 `int`、`void`、`String` 等。在字节码指令中，返回类型信息通过特定的指令表示，例如：
    - `ireturn`: 返回一个整数类型。
    - `return`: 用于无返回值的方法（如 `void`）。
    - `areturn`: 返回一个引用类型。

  - 与返回地址的关系: 方法返回类型并不直接存储在栈帧中，而是通过字节码指令来表示。具体的返回指令（如 `ireturn`、`areturn` 等）会根据方法的返回类型执行相应的操作。

**总结**

- 方法返回地址: 存储在栈帧中，用于指示方法执行完毕后应该返回到哪个位置。
- 方法返回类型: 通过字节码中的返回指令（如 `ireturn` 等）来表达，不直接存储在栈帧中，但会影响栈帧中操作数栈的数据处理和返回。



#### 6.7 一些附加信息

栈帧中还允许携带与Java虚拟机实现相关的些附加信息。例如，对程序调试提供支持的信息。

![image-20241006124835168](%E4%BA%94%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.assets/image-20241006124835168.png)





### 补充

- 有些书上将栈帧中的方法返回地址、动态链接、一些附加信息统称为帧数据区。

- 程序计数器没有error也没有gc，虚拟机栈、本地方法栈有error没有gc

- 分配的栈内存越大越好吗

  栈用于存储方法的局部变量、操作数和返回地址。

  - **内存浪费**: 如果栈分配过大，而实际使用的内存较少，就会造成资源浪费。
  - **性能影响**: 大栈可能导致上下文切换和内存管理变得复杂，从而影响性能。
  - **栈溢出**: 如果栈的最大深度受限于设置，过大的栈大小可能会导致栈溢出错误（`StackOverflowError`），尤其是在递归调用时。

- 线程不安全问题

```java
// 线程不安全（逃逸，有返回值，其他线程可以对其进行操作）
// StringBuilder没有在内部消亡
public static StringBuilder method() {
	StringBuilder s = new StringBuilder();
	s.append("a");
	s.append("b");
	return s;
}

// 线程不安全（逃逸，有入参，其他线程可以对其进行操作）
// StringBuilder没有在内部消亡
public static StringBuilder method(StringBuilder s) {
	s.append("a");
	s.append("b");
	return s;
}

// 线程安全
// StringBuilder在内部消亡
public static void method() {
	StringBuilder s = new StringBuilder();
	s.append("a");
	s.append("b");
	return s;
}

// 线程安全
// StringBuilder在内部消亡
public static String method() {
	StringBuilder s = new StringBuilder();
	s.append("a");
	s.append("b");
	return s.toString();
}
```



#### 1.关于类中实例对象的存储问题

讲解一下关于类中实例对象在JVM中实际的存储方式，示例代码如下所示

```java
public class A {
    int x = 1;  // 实例变量

    public void method() {
        int a = x + 1;  // 使用实例变量 x
    }
}
```

其通过java编译后的字节码指令如下所示

```
0 aload_0	// 将当前对象引用（this）推入操作数栈
1 getfield #2 <com/example/A.x>	// 获取实例变量 x 的值（x 的字段编号）
4 iconst_1	 // 将常量 1 推入操作数栈
5 iadd	// 将栈顶两个整数相加，结果放回栈顶
6 istore_1	// 将栈顶整数存储到局部变量表索引 1（a）
7 return
```

具体指令说明如下所示

- `aload_0`：此指令将当前对象的引用（即 `this`）推入操作数栈。`this` 是对当前实例的引用，允许我们访问该实例的字段和方法。

- `getfield #2`：该指令用于访问实例变量 `x`。`#2` 是在类文件中定义 `x` 的字段的索引，表示从当前对象中获取 `x` 的值。这一指令从 `this` 对象中读取实例变量 `x`，并将其值推入操作数栈。

- `iconst_1`：此指令将常量 `1` 推入操作数栈。此处是为了计算 `x + 1`。

- `iadd`：该指令将操作数栈顶部的两个整数相加。在这个例子中，它将 `x` 的值（从 `getfield` 指令获取）和 `1` 相加，并将结果（`2`）放回操作数栈的顶部。

- `istore_1`：该指令将操作数栈顶部的整数存储到局部变量表的索引 1（即 `a`）中。这样，`a` 就被赋值为 `2`。

- `return`：该指令结束方法的执行。

局部变量表信息

![image-20241024233250757](%E4%BA%94%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.assets/image-20241024233250757.png)

其中x实例对象实际上也是在堆中的，其是通过java虚拟机栈中的this，即A的实例对象间接引用的，即Java虚拟机栈中通过this引用在堆中实际存储的A的实例对象，而A的实例对象中又维护着x的相关信息。

关于实例A对象在堆中存放的内存结构主要包含两部分：①对象头 ②实例变量

1. 对象头（Object Header）：
   - 对象头通常包含两个主要部分：
     - 类型指针**（Class Pointer）**：指向对象的类元数据，包含类的信息（如字段、方法、继承关系等）。
     - 哈希码**（Hash Code）**：用于支持 `hashCode()` 方法。
     - 锁信息（如果该对象被锁定）：用于实现 Java 的同步机制。
2. 实例变量（Fields）：
   - `int x` 是 `A` 类的一个实例变量。在 Java 中，基本数据类型（如 `int`）的变量直接存储在对象的内存中，而不是引用。
   - 因此，在堆中 `x` 的值会直接存储为 4 个字节（在 32 位或 64 位 JVM 中通常是 4 字节），而不是存储为引用（基本数据类型（如 `int`, `char`, `float` 等）会直接存储在对象中；引用类型（如对象、数组）则存储一个指向实际对象的引用。对于引用类型，实例对象的结构会包含指向其在堆中存储的实际对象的指针）

```
+---------------------+
|    对象头          |  <- Object Header (类型指针、哈希码等)
+---------------------+
|   int x = 1        |  <- 实例变量 x 的值直接存储在这里
+---------------------+
```

