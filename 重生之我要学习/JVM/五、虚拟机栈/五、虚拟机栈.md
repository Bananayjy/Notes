## 五、虚拟机栈

### 1、虚拟机栈概述

#### 1.1 虚拟机栈出现的背景

由于跨平台性的设计，Java的指令都是根据栈来设计的。原因是对于不同平台CPU架构不同，所以不能设计为基于寄存器的。

**关于虚拟机的优缺点：**

**优点：**跨平台，指令集小，编译器容易实现

**缺点：**是性能下降，实现同样的功能需要更多的指令。



#### 1.2 初步印象

因为C和C++的内存结构主体是由堆（heap）和栈（stack）组成

因此很多Java开发人员一提到Java内存结构，就会非常粗粒度地将JVM中的内存区域理解为仅有java堆和java栈。



#### 1.3 内存中的栈与堆

栈是运行时的单位，而堆是存储的单位。

栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。

堆解决的是数据存储的问题，即数据怎么放、放在哪儿。



#### 1.4 虚拟机栈基本内容

##### 1、Java虚拟机栈是什么

Java虚拟机栈(Java Virtual Machine stack)，早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈（即线程私有的），其内部保存一个个的栈帧(stack Frame)，对应着一次次的Java方法调用（同时也对应着一次次栈帧的出栈和入栈）

##### 2、生命周期

生命周期和线程一致

##### 3、作用

主管Java程序的运行，它保存方法的局部变量（涉及8种基本数据类型，对象的引用地址【具体的对象存储在堆中】）、部分结果，并参与方法的调用和返回。

##### 4、举例

如下代码的具体的栈操作是这样的，当我们执行methodA方法的时候，即将methodA中的内容加载到栈中，首先是i = 10 入栈，然后j = 20 入参，并且i = 10 和 j = 20 都在一个栈帧中（一个栈帧对应一个方法）。当执行methodB方法的时候，会将x=30和y=40入栈，并且他们属于一个栈帧。我们把栈顶的栈帧称为当前方法，即methodB，当methodB方法执行完毕后，methodB对应的栈帧就会出栈，然后此时methodA就变成了当前方法，执行methodA中的内容。

```java
public class StackTest{
    
    public static void main(String[] args) {
        StackTest stackTest = new StackTest();
        stackTest.methodA();
    } 
    
    public void methodA(){
        int i = 10;
        int j = 20;
        this.methodB();
    }
    
    public void methodB(){
        int x = 30;
        int y = 40;
    }
    
}
```

##### 5、栈的特点（优点）

- 栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。

- JVM直接对Java栈的操作只有两个:
  - 每个方法执行，伴随着进栈(入栈、压栈)
  - 执行结束后的出栈工作
- 对于栈来说不存在垃圾回收问题（GC），因为只涉及入栈和出栈，不需要高级的算法进行垃圾回收。但是其会存在OOM，即溢出问题。

![image-20240624234323593](%E4%BA%94%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.assets/image-20240624234323593.png)

##### 6、栈中可能出现的异常

Java 虚拟机规范允许Java栈的大小是动态（初始大小可以通过启动参数（如`-Xss`）来设置，但在很多JVM实现中，栈的大小可以根据需要动态调整。比如，当一个方法调用导致需要更多的栈空间时，JVM可以动态增加栈的大小；反之，当不再需要那么多栈空间时，JVM可以回收一些栈空间。是否可以动态分配的，取决于JVM的实现，如果不指定-xss参数，通常情况下java虚拟机会采用默认的栈空间）的或者是固定不变的。

- 如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个StackoverflowError 异常

  示例：

  ```
  public static void main(String[] atgs) {
  	main(args);
  }
  
  //抛出异常:Exception in thread "main"java.lang.stackoverflowError
  //程序不断的进行递归调用，而且没有退出条件，就会导致不断地进行压栈。
  ```

  

- 如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法中请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个OutOfMemoryError 异常

我们可以使用参数-Xss 选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。可以通过如下方式查看调用的深度

默认情况下count:11420

设置栈大小：-Xss256k: count:2465

```java

public Test{
	private static int count = 1；
	public static void main(String[] args) {
		System.out.println(count);
		count++;
		main(args);
	}
}
```



### 3、栈的存储单位

#### 3.1 栈中的存储内容

- 每个线程都有自己的栈，栈中的数据都是以栈帧(stack Frame)的格式存在
- 在这个线程上正在执行的每个方法都各自对应一个栈帧(stack Frame)。（栈帧的方法的关系：一一对应）
- 栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息



#### 3.2 栈运行原理

##### 1.原理概括

- JVM直接对Java栈的操作只有两个，就是对栈帧的压栈和出栈，遵循“先进后出”/“后进先出”原则。
- 在一条活动线程中（各个线程是并发运行的，一个CPU在同一时刻只能运行一个线程，多核处理器，也是每个核心同一时间只能执行一个线程0），一个时间点上，只会有一个活动的栈帧（栈中最顶层的栈帧）。即只有当前正在执行的方法的栈帧(栈顶栈帧)是有效的，这个栈被称为当前栈帧(Current Frame)，与当前栈帧相对应的方法就是当前方法(Current Method)，定义这个方法的类就是当前类(Currentclass)
- 执行引擎运行的所有字节码指令只针对当前栈帧进行操作
- 如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。
- 不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。（每个线程维护一个虚拟机栈，每个线程共享堆空间）
- 如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧
- Java方法有两种返回函数的方式（方法结束有两种方式），一种是正常的函数返回，使用return指令;另外一种是抛出异常。不管使用哪种方式，都会导致帧被弹出。

##### 2.具体示例

![image-20240627000234912](%E4%BA%94%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.assets/image-20240627000234912.png)



示例代码

```java
/**
 * @author banana
 * @create 2024-06-27 0:03
 */
public class StackFrameTest {

    public static void main(String[] args) {
        StackFrameTest test = new StackFrameTest();
        test.method1();
    }

    public void method1() {
        System.out.println("method1方法开始执行");
        method2();
        System.out.println("method1方法执行结束");
    }

    public int method2() {
        System.out.println("method2方法开始执行");
        double v = method3();
        System.out.println("method2方法执行结束");
        return (int)v * 2;
    }

    public double method3() {
        System.out.println("method3方法开始执行");
        double num = 2.1;
        System.out.println("method3方法执行结束");
        return num;
    }

}
```

运行结果：

```
method1方法开始执行
method2方法开始执行
method3方法开始执行
method3方法执行结束
method2方法执行结束
method1方法执行结束
```

说明：

首先我们调用main方法，会把main方法对应的栈帧放入虚拟机栈中，然后开始执行main方法，即此时为当前栈帧，当调用到method1方法的时候，会将method1对应的栈帧放入虚拟机栈中，此时method1对应的栈帧作为当前栈帧，当调用到methdo2方法的时候，会将methdo2对应的栈帧放入到虚拟机栈中，同理，直到method3方法对应的栈帧放入虚拟机栈中，当method3方法执行完毕后，其对应的栈帧出栈，此时method2对应的栈帧为当前栈帧，执行对应的方法，同理，直到所有的栈帧都出栈，即结束。

可以通过IDEA提供的Frames栈帧来查看具体的虚拟机栈中的栈帧情况：

![image-20240627001130771](%E4%BA%94%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.assets/image-20240627001130771.png)
