# 十一、直接内存

## 一、前言

以内jdk8之后，就采用元空间作为方法区的具体实现，其使用的就是本地内存，即直接内存。



## 二、相关内容

- 直接内存不是虚拟机运行时数据区中的任何一部分，也不是《java虚拟机规范》中定义的内存区域，其是在Java堆外，直接向系统申请的内存区间。
- 来源于NIO，通过存在堆中的DirectByteBuffer操作Native内存（本地内存，实际上通过unsage的allocateMemory操作本地内存）

| IO            | NIO(New IO/Non-Blocking IO) |
| ------------- | --------------------------- |
| byte[]/char[] | Buffer                      |
| Stream        | Channel                     |

通过DirectByteBuffer直接操作内存示例：

![image-20250121224720061](%E5%8D%81%E4%B8%80%E3%80%81%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98.assets/image-20250121224720061.png)

在scanner.next()等待输入过程中，内存分配完毕后，我们通过jps获取对应的java进程看下占用内存可以发现大概是1gb，当输入完成后，即内存释放后，内存减小到不足1GB。

- 通常，访问直接内存的速度会优于java堆，即读写性能更高

出于性能考虑，读写频繁的场合可能会考虑使用直接内存。

并且Java的NIO库允许Java程序使用直接内存，用于数据缓冲区。

对于IO和NIO读写文件也是不同的，需要与磁盘交互需要由用户态切换到内核态。在内核态时，需要内存操作的方式如下所示：

使用IO，	需要两份内存存储重复数据（涉及到数据拷贝），效率低。

 ![image-20250121225403314](%E5%8D%81%E4%B8%80%E3%80%81%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98.assets/image-20250121225403314.png)

使用NIO时，操作系统划出的直接缓存区可以被java代码直接访问，只有一份。NIO适合对大文件的读写操作。

![image-20250121225518056](%E5%8D%81%E4%B8%80%E3%80%81%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98.assets/image-20250121225518056.png)

- 对于直接内存，也可能导致OutOfMemoryError异常

示例一：

![image-20250121231128606](%E5%8D%81%E4%B8%80%E3%80%81%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98.assets/image-20250121231128606.png)

示例二：

![image-20250121231220439](%E5%8D%81%E4%B8%80%E3%80%81%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98.assets/image-20250121231220439.png)

结果（过程无法通过检测工具检测到，以内一些检测工具只是检测堆内存）：

![image-20250121231141862](%E5%8D%81%E4%B8%80%E3%80%81%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98.assets/image-20250121231141862.png)

- 由于直接内存在Java堆外，因此它的大小不会直接受限于-Xmx指定的最大堆大小，但是系统内存是有限的，Java堆和直接内存的总和依然受限于操作系统能给出的最大内存。直接内存大小可以通过MaxDirectMemorysize设置，如果不指定，默认与堆的最大值-Xmx参数值一致
- 直接内存的缺点如下：分配回收成本较高；不受JVM内存回收管理；

![image-20250121231410725](%E5%8D%81%E4%B8%80%E3%80%81%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98.assets/image-20250121231410725.png)