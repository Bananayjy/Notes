## 十、对象的实例化内存布局与访问定位

### 1、对象的实例化

#### 1.1 创建对象的方式

- new 

通过new构造器创建对象的方式是最常见的方式。

变形1：对于构造器私有的类，通过Xxx的静态方法，在静态方法中，通过new 构造器的方式完成对该对象的实例化（构造器对静态方法暴露，而不对外暴露）

变形2：XxxBuilder/XxxFactory的静态方法

对于变形1和变形2本质上都是通过new构造器的方式完成对象的创建，区别无非是构造器是否私有。

- 反射方式

JDK8以前，通过Class的newInstance()方法，通过反射的方式完成类的创建，但是其只能调用空参的构造器，并且权限必须是public。

因此在JDK9后，将上述方法弃用，改用（lang包下）Constructor的newInstance（Xxx）的方式，完成反射创建对象并且其可以调用空参、有参的构造器，并且对权限没有要求

- clone

其不调用任何构造器，当前类需要实现爱你Cloneable接口，实现clone方法

- 序列化（反序列）

通过反序列化，从文件、网络中获取对象的二进制流，还原成内存中的对象

- 第三方库

Objenesis字节码技术……

#### 1.2 创建对象的步骤

##### 1、字节码层面

测试代码如下所示

```java
public class ObjectTest {
    public static void main(String[] args) {
        Object o = new Object();
    }
}

```

通过javap命令查看其字节码内容

```
Classfile /D:/codesaver/Banana-project/Banana-own-projects/target/classes/com/example/JVMTEST/ObjectCreate/ObjectTest.class
  Last modified 2025-1-19; size 516 bytes
  MD5 checksum d9d2212d3935b2ee661ed9fb756c3863
  Compiled from "ObjectTest.java"
public class com.example.JVMTEST.ObjectCreate.ObjectTest
  minor version: 0
  major version: 52
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
   #1 = Methodref          #2.#20         // java/lang/Object."<init>":()V
   #2 = Class              #21            // java/lang/Object
   #3 = Class              #22            // com/example/JVMTEST/ObjectCreate/ObjectTest
   #4 = Utf8               <init>
   #5 = Utf8               ()V
   #6 = Utf8               Code
   #7 = Utf8               LineNumberTable
   #8 = Utf8               LocalVariableTable
   #9 = Utf8               this
  #10 = Utf8               Lcom/example/JVMTEST/ObjectCreate/ObjectTest;
  #11 = Utf8               main
  #12 = Utf8               ([Ljava/lang/String;)V
  #13 = Utf8               args
  #14 = Utf8               [Ljava/lang/String;
  #15 = Utf8               o
  #16 = Utf8               Ljava/lang/Object;
  #17 = Utf8               MethodParameters
  #18 = Utf8               SourceFile
  #19 = Utf8               ObjectTest.java
  #20 = NameAndType        #4:#5          // "<init>":()V
  #21 = Utf8               java/lang/Object
  #22 = Utf8               com/example/JVMTEST/ObjectCreate/ObjectTest
{
  public com.example.JVMTEST.ObjectCreate.ObjectTest();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         4: return
      LineNumberTable:
        line 7: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       5     0  this   Lcom/example/JVMTEST/ObjectCreate/ObjectTest;

  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=2, args_size=1
         0: new           #2                  // class java/lang/Object
         3: dup
         4: invokespecial #1                  // Method java/lang/Object."<init>":()V
         7: astore_1
         8: return
      LineNumberTable:
        line 9: 0
        line 10: 8
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       9     0  args   [Ljava/lang/String;
            8       1     1     o   Ljava/lang/Object;
    MethodParameters:
      Name                           Flags
      args
}
SourceFile: "ObjectTest.java"
```

其主要的操作就是如下几个

![image-20250119224814521](%E5%8D%81%E3%80%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D.assets/image-20250119224814521.png)

首先是调用new操作符的时候，会去查找运行时常量池中是否已经把为常量池中为2对应内容即Object的对象加载了，如果没有加载，会使用类的加载器，将lang包下的Object类加载到方法区中，然后在堆空间开辟对应的空间，并且为一些变量进行赋值。

然后通过dup，即把操作数栈中生成的变量赋值一份，都指堆空间中的对象。此时操作数栈中有两个变量，栈底用于赋值操作，上面的是句柄去调用相关方法（△）

调用invokespecial，即方法调用，调用Object的init方法，即Object的构造器。

最后通过astore1将变量从操作数中拿出来，放到局部变量表中。



##### 2、创建对象执行步骤

- 判断对象对应的类是否加载、链接、初始化

虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化。(即判断类元信息是否存在)。如果没有，那么在双亲委派模式下，使用当前类加载器以ClassLoader+包名+类名为Key进行查找对应的.class 文件。如果没有找到文件，则抛出ClassNotFoundException 异常如果找到，则进行类加载，并生成对应的Class 类对象。

- 为对象分配内存

首先计算对象占用空间大小，如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小。其中又可以分为内存规整、不规整。

如果内存是规整的，那么虚拟机将采用的是指针碰撞法(Bump The Pointer)来为对象分配内
存。意思是所有用过的内存在一边，空闲的内存在另外一边，中间放着一个指针作为分界点的指示器分配内存就仅仅是把指针向空闲那边挪动一段与对象大小相等的距离罢了。如果垃圾收集器选择的是Serial、ParNew这种基于压缩算法的，虚拟机采用这种分配方式。一股使用带有compact(整理)过程的收集器时，使用指针碰撞。

如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表法来为对象分配内存。意思是虚拟机维护了一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式成为“空闲列表(Free List)"。

选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。

- 处理并发安全问题

堆空间创建对象，堆是共享的，会有线程安全问题存在。

可以通过采用CAS配上失败重试保证更新的原子性。

也可以每个线程预先分配一块TLAB（伊甸园区，线程不共享）

- 初始化分配到的空间（属性的默认初始化，零值初始化）

对象中所有属性设置默认值（即属性的默认初始化），保证对象实例字段在不赋值时可以直接使用。

- 设置对象头

将对象的所属类(即类的元数据信息)，对象的Hashcode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。

- 执行init方法进行初始化（属性的显示初始化、代码块中初始化、构造器中初始化）

在Java程序的视角看来，初始化才正式开始（显示初始化/代码块初始化、构造器初始化）。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量。因此一般来说(由字节码中是否跟随有invokespeclal指令所决定)，new指令之后会接着就是执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全创建出来。

```java
public class Customer {

    // 显示赋值
    int id = 1001;
    String name;
    Account acct;

    // 代码中初始化
    {
        name = "匿名客户";
    }

    // 构造器中初始化
    public Customer() {
        acct = new Account();
    }
}

class Account {

}
```



### 2、对象的内存布局

类对象

```java
public class Customer {

    // 显示赋值
    int id = 1001;
    String name;
    Account acct;

    // 代码中初始化
    {
        name = "匿名客户";
    }

    // 构造器中初始化
    public Customer() {
        acct = new Account();
    }
}

class Account {

}
```

测试类

```java
public class CusomerTest {
    public static void main(String[] args) {
        Customer cust = new Customer();
    }
}
```



调用main方法后，Customer对象在内存中的布局如下所示：

![image-20250120230108324](%E5%8D%81%E3%80%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D.assets/image-20250120230108324.png)

通过字节码也可以看到其局部变量表中的内容如下所示（静态方法，不放this）：

![image-20250120225915443](%E5%8D%81%E3%80%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D.assets/image-20250120225915443.png)

在堆空间对象的内容可以分为如下

- 对象头（Header）

包含两部分：

①运行时元数据(MarkWord)

哈希值(HashCode，在堆空间的首地址值，用于引用对象指向堆空间的位置)、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳

②类型指针

指向类元数据instanceKlass，确定该对象所厘的类那

（注意：如果是数组，还需记录数组的长度）

- 实例数据(Instance Data)

说明：它是对象真正存储的有效信息，包括程序代码中定义的各种类型的字段(包括从**父类继承下来**的和本身拥有的字段）

规则：相同宽度的享段总是被分配在一起；父类中定义的变量会出现在子类之前；如果CompactFields参数为true(默认为true):子类的窄变量可能播入到父类变量的空隙。

- 对齐填充(Padding)

不是必须的，也没特别会义，仅仅起到占位符的作用



### 3、对象的访问定位

#### 3.1 分类

JVM是通过栈帧上的reference访问到其内部对象的示例，如下图所示

![image-20250121214337605](%E5%8D%81%E3%80%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D.assets/image-20250121214337605.png)

对象访问的方式主要又可以分为两种：①句柄访问 ②直接指针（Hotspot采用）

①句柄访问

![image-20250121214918306](%E5%8D%81%E3%80%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D.assets/image-20250121214918306.png)

栈的局部变量表中记录了对象的引用，即reference，指向java堆中专门开辟出来用来放句柄的句柄池（里面放了很多句柄），一个对象有一个句柄，一个句柄中有两个信息，一个用来只想对象实例（new的对象）的数据指针，另一个用来指向对象类型数据的指针（即执行方法区中的类元数据）



②直接访问

hotspot虚拟机采用

![image-20250121215658943](%E5%8D%81%E3%80%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D.assets/image-20250121215658943.png)

#### 3.2 优缺点

- 通过句柄存储的好处是，reference中存储稳定的句柄地址，对象被移动（垃圾收集时移动对象很普遍）时只会改变句柄中实例数据指针即可，reference本身不需要被修改，还是指向对应的句柄。对于直接访问的方式，在堆中对象移动后，就需要修改reference的指向了。
- 通过句柄存储需要专门开辟一个空间存放句柄（浪费空间），并且访问对象的时候，需要先通过reference找到句柄，再通过句柄找到对应的对象（效率低）。而直接访问是直接通过栈空间的refernce指向就可以找到对应的对象实例，效率高、内存使用低。
