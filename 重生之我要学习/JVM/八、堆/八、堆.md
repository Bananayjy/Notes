## 八、堆

### 1、堆的核心概述

#### 1.1 位置

堆和方法区对于一个进程来说是唯一的，一个进程对应一个JVM的实例，一个JVM实例就有一个运行时数据区（即Runtime Data Area），一个进程有多个线程，多个线程共享堆空间和方法区，每给线程有一份自己的程序计数器、本地方法栈、虚拟机栈。

![image-20241006230500618](%E5%85%AB%E3%80%81%E5%A0%86.assets/image-20241006230500618.png)

- 一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域

- Java 堆区在JVM 启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间。

  - 堆内存的大小是可以调节的(-Xms)。

- 《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的（通过物理空间和虚拟空间的映射表完成映射）

- 所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区(ThreadLocal Allocation Buffer,TLAB，线程安全，并发性好)

- 《Java虚拟机规范》中对Java堆的描述是:所有的对象实例以及数组都应当在运行时分配在堆上。

  - 我要说的是:“几乎”所有的对象实例都在这里分配内存。从实际使用角度看的。

- 数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。

  ![image-20241007000339376](%E5%85%AB%E3%80%81%E5%A0%86.assets/image-20241007000339376.png)

- 在方法结束后，栈中的引用就从虚拟机栈中出栈了，但堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除（防止堆空间中回收的频率高，影响用户线程的执行）
- 堆，是GC(Garbage Collection，垃圾收集器)执行垃圾回收的重点区域。



#### 1.2 内存细分

![image-20241007002834184](%E5%85%AB%E3%80%81%E5%A0%86.assets/image-20241007002834184.png)

堆空间只计算新生代和老年代，不包含永久区（元空间）

![image-20241007002907192](%E5%85%AB%E3%80%81%E5%A0%86.assets/image-20241007002907192.png)



![image-20241007002912545](%E5%85%AB%E3%80%81%E5%A0%86.assets/image-20241007002912545.png)



### 2、设置堆内存大小与OOM

#### 2.1 堆空间大小的设置

- Java堆区用于存储Java对象实例，那么堆的大小在JM启动时就已经设定好了，大家可以通过选项“-Xmx"和”-Xms"来进行设置。
  - “-Xms”用于表示堆区的起始内存，等价于-XX:InitialHeapSize
  - “-Xmx"则用于表示堆区的最大内存，等价于-XX:MaxHeapSize
- 一旦堆区中的内存大小超过“-Xmx"所指定的最大内存时，将会抛出OutOfMemoryError异常。
- 通常会将-Xms和-Xmx两个参数配置相同的值，其目的是为了能够在iava垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能（避免gc后，频繁扩容释放，调转堆大小，增加系统压力）
- 默认情况下，初始内存大小:物理电脑内存大小/64，最大内存大小:物理电脑内存大小/4



#### 2.2 查看设置参数

- 方式一：jps / jstat -gc 进程id（查看各个进程内存使用情况）

运行如下代码

```java
public class HeapSpaceInitial {

    public static void main(String[] args) throws InterruptedException {
        // java虚拟机中的堆内存总量
        long initialMemory = Runtime.getRuntime().totalMemory() / 1024 / 1024;

        // java虚拟机视图使用的最大堆内存量
        long maxMemory = Runtime.getRuntime().maxMemory() / 1024 / 1024;

        System.out.println("-Xms:" + initialMemory + "M");
        System.out.println("-Xmx:" + maxMemory + "M");



        Thread.sleep(100000000);
    }
}
```

执行相关命令

![image-20241007013235877](%E5%85%AB%E3%80%81%E5%A0%86.assets/image-20241007013235877.png)

- SOC：S0空间
- S1C：S1空间
- S0U：S0使用量
- S1U：S0使用量
- EC：伊甸园区空间
- EU：伊甸园区使用量
- OC：老年代空间
- OU：老年代使用量

注意：Runtime.getRuntime().totalMemory()打印出来的内存空间，原因是S0和S1区只能二选一来进行存储。



- 方式二：-XX:+PrintGCDetails 在运行结束后打印内存信息

![image-20241007013918777](%E5%85%AB%E3%80%81%E5%A0%86.assets/image-20241007013918777.png)

![image-20241007013930489](%E5%85%AB%E3%80%81%E5%A0%86.assets/image-20241007013930489.png)



#### 2.3 OutOfMemor举例

代码示例

```java
package com.example.JVMTEST.Heap;

import java.util.ArrayList;
import java.util.Random;

/**
 * OOM场景示例
 * 设置内存参数：-Xms600m -Xmx600m
 * @author banana
 * @create 2024-10-07 15:20
 */
public class OOMTest {

    public static void main(String[] args) {
        ArrayList<Picture> list = new ArrayList<>();
        while(true) {
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                System.out.println(e);
            }
            list.add(new Picture(new Random().nextInt(1024 * 1024)));
        }
    }
}

class Picture {

    private byte[] pixles;

    public Picture(int len) {
        this.pixles = new byte[len];
    }

}

```

报错信息

```
Exception in thread "main" java.lang.OutOfMemoryError: Java heap space
	at com.example.JVMTEST.Heap.Picture.<init>(OOMTest.java:32)
	at com.example.JVMTEST.Heap.OOMTest.main(OOMTest.java:22)
```

java VisualVM信息

![image-20241007155104203](%E5%85%AB%E3%80%81%E5%A0%86.assets/image-20241007155104203.png)



###  3、年轻代与老年代

#### 3.1 简介

- 存储在JVM中的Java对象可以被划分为两类:
  - 一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速。
  - 另外一类对象的生命周期却非常长，在某些极端的情况下还能够与M的生命周期保持一致。
- Java堆区进一步细分的话，可以划分为年轻代(YoungGen)和老年代(oldGen)
- 其中年轻代又可以划分为Eden空间、Survivor0空间和Survivor1空间(有时也叫做from区、to区)

![image-20241007155643300](%E5%85%AB%E3%80%81%E5%A0%86.assets/image-20241007155643300.png)

#### 3.2 参数调整

默认堆空间各个部分的参数

![image-20241007161244320](%E5%85%AB%E3%80%81%E5%A0%86.assets/image-20241007161244320.png)

配置新生代与老年代在堆结构的占比

- 默认-XX:NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3
- 可以修改-XX:NewRatio=4，表示新生代占1，老年代占4，新生代占整个堆的1/5
- 在HotSpot中，Eden空间和另外两个Survivor空间缺省所占的比例是8:1:1
- 当然开发人员可以通过选项“-XX:SurvivorRatio”调整这个空间比例。比如-XX:SurvivorRatio=8
- 几乎所有的Java对象都是在Eden区被new出来的。
- 绝大部分的Java对象的销毁都在新生代进行了。IBM 公司的专门研究表明，新生代中80%的对象都是“朝生夕死”的。
- 可以使用选项”-Xmn"设置新生代最大内存大小， 这个参数一般使用默认值就可以了（同时设置-Xmn和-XX:NewRatio，-Xmn的优先级更加高）

其中流转过程如下所示

![image-20241007161525506](%E5%85%AB%E3%80%81%E5%A0%86.assets/image-20241007161525506.png)



### 4、图解对象分解过程

#### 4.1 概述

为新对象分配内存是一件非常严谨和复杂的任务，JVM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中您生内存碎片。

#### 4.2 具体过程

- new的对象先放伊甸园区。此区有大小限制。

- 当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收(Minor GC)，将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区

- 然后将伊甸园中的剩余对象移动到幸存者0区:如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区。

- 如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区

- 默认是15次后去养老区

  - 可以设置参数:-XX:MaxTenuringThreshold=<N>进行设置

- 在养老区，相对悠闲。当养老区内存不足时，再次触发GC:MajorGC，进行养老区的内存清理。

- 若养老区执行了Major GC之后发现依然无法进行对象的保存，就会产生OOM异常

  ```
  java.lang.OutOfMemoryError:Java heap space
  ```

#### 4.3 图示

![image-20241007181548379](%E5%85%AB%E3%80%81%E5%A0%86.assets/image-20241007181548379.png)

#### 4.4 总结

- 针对幸存者s0,s1区的总结:复制之后有交换，谁空谁是to，非空的为from
- 关于垃圾回收:频繁在新生区收集，很少在养老区收集，几乎不在永久区元空间收集。



#### 4.5 对象分配特殊情况

即关于Eden区和S0、S1区放不下时候，都是会将对象晋升到老年区，如果老年区也放不下，出发FGC，再次尝试放老年代，如果还是放不下，老年代会尝试扩然，如果还是放不下，爆OOM

扩容机制（△）：

- 老年区扩容：老年区的扩容通常是由 JVM 的内存管理策略决定的。不同的 JVM 实现可能会有不同的扩容策略，但一般情况下，老年区会在以下条件下尝试扩容：
  - 如果在 Full GC 过程中发现老年区的使用率达到了某个阈值。
  - 具体的扩容行为一般依赖于 JVM 的参数设置，比如 `-XX:MaxHeapSize` 和 `-XX:NewRatio` 等。
- 扩容条件：老年区的扩容可以根据 JVM 的实现而有所不同，一般情况下会考虑整体堆的大小设置、当前内存使用情况以及其他一些 JVM 的配置参数。
- 最终结果：如果老年区扩容后仍然无法容纳新的对象，系统就会抛出 OutOfMemoryError（OOM）。

![image-20241007184716786](%E5%85%AB%E3%80%81%E5%A0%86.assets/image-20241007184716786.png)



#### 4.6 调优工具

- JDK命令行
- Eclipse:Memory Analyzer Tool
- Jconsole
- VisualVM
- Jprofiler
- Java Flight Recorder
- GCViewer
- GC Easy



### 5、Minor GC、Major GC、Full GC

JVM在进行GC时，并非每次都对上面三个内存(新生代、老年代、方法区)区域一起回收的，大部分时候回收的都是指新生代。

针对Hotspot VM的实现，它里面的GC按照回收区域又分为两大种类型:一种是部分收集(Partial GC)，一种是整堆收集(Full GC)

- 部分收集:不是完整收集整个Java堆的垃圾收集。其中又分为:
  - 新生代收集(Minor GC / Young GC):只是新生代的垃圾收集
  - 老年代收集(Major GC / old GC):只是老年代的垃圾收集。
    -  目前，只有CMS GC会有单独收集老年代的行为。
    -  注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收。
  - 混合收集(Mixed GC):收集整个新生代以及部分老年代的垃圾收集。√
    - 目前，只有G1 GC会有这种行为

- 整堆收集(Fu11 GC):收集整个java堆和方法区的垃圾收集。

- 年轻代GC(Minor GC)触发机制:

  - 当年轻代空间不足时，就会触发Minor GC，这里的年轻代满指的是Eden代满，survivor满不会引发GC。(每次 Minor GC的同时会清理年轻代的内存)
  - 因为 Java 对象大多都具备朝生夕灭的特性，所以MinorGc非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。
  - Minor GC会引发STW，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行。

  ![image-20241007215709546](%E5%85%AB%E3%80%81%E5%A0%86.assets/image-20241007215709546.png)

- 老年代GC(Major GC / Full GC)触发机制:

  - 指发生在老年代的GC，对象从老年代消失时，我们说“MajorGC”或“Full GC”发生了。
  - 出现了Major GC，经常会伴随至少一次的Minor GC(但非绝对的，在ParalleL Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程)。
    - 也就是在老年代空间不足时，会先尝试触发Minor GC。如果之后空间还不足，则触发Major GC

  - Major GC的速度一般会比Minor Gc慢8倍以上，STW的时间更长。
  - 如果Major GC后，内存还不足，就报OOM了。
  - Major GC的速度一般会比Minor GC慢10倍以上。



- Full GC触发机制:

  触发Full GC 执行的情况有如下五种:
  (1)调用system.gc()时，系统建议执行Full GC，但是不必然执行
  (2)老年代空间不足
  (3)方法区空间不足
  (4)通过Minor GC后进入老年代的平均大小大于老年代的可用内存
  (5)由Eden区、survivor space0(From Space)区向survivor space1(To Space)区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小
  说明:full gc是开发或调优中尽量要避免的。这样暂时时间会短一些



### 6、堆空间分代思想

#### 6.1 为什么需要把Jaya堆分代?不分代就不能正常工作了吗

- 经研究，不同对象的生命周期不同。70%-99%的对象是临时对象
- 新生代:有Eden、两块大小相同的survivor(又称为from/to，s0/s1)构成to总为空。
- 老年代:存放新生代中经历多次GC仍然存活的对象。

#### 6.2 为什么需要把Java堆分代?不分代就不能正常工作了吗?

其实不分代完全可以，分代的唯一理由就是优化GC性能。如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC的时候要找到哪些对象没用这样就会对堆的所有区域进行扫描。而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当GC的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来

![image-20241007232022384](%E5%85%AB%E3%80%81%E5%A0%86.assets/image-20241007232022384.png)



### 7、内存分配策略

如果对象在Eden 出生并经过第一次MinorGC后仍然存活，并且能被survivor容纳的话，将被移动到survivor空间中，并将对象年龄设为1。对象在年龄就增加1岁，当它的年龄增加到一定Survivor 区中每熬过一次MinorGC，年龄就增加1岁。当它的年龄增加到一定程度(默认为15岁，其实每个JVM、每个GC都有所不同)时，就会被晋升到老年代中。
对象晋升老年代的年龄阈值，可以通过选项-XX:MaxTenuringThreshold来设置



针对不同年龄段的对象分配原则如下所示:

- 优先分配到Eder
- 大对象直接分配到老年代
  - 尽量避免程序中出现过多的大对象
- 长期存活的对象分配到老年代
- 动态对象年龄判断
  - 如果survivor 区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。
- 空间分配担保
  - -XX:HandlePromotionFailure



### 8、为对象分配内存：TLAB

#### 8.1 为什么TLAB（Thread Local Allocation Buffer）

- 堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据
- 由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中（堆是多线程共享的）划分内存空间是线程不安全的
- 为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度（加锁，串行，降低并发率，从而降低执行效率）

#### 8.2 什么是TLAB

- 从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内。
- 多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为快速分配策略。
- 据我所知所有openJDK衍生出来的JVM都提供了TLAB的设计。

![image-20241008225340275](%E5%85%AB%E3%80%81%E5%A0%86.assets/image-20241008225340275.png)

#### 8.3 TLAB分配说明

- 尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选。
- 在程序中，开发人员可以通过选项“-XX:UseTLAB”设置是否开启TLAB空间。
- 默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的1%，当然我们可以通过选项“-XX:TLABWasteTargetPercent”设置TLAB空间所占用Eden空间的百分比大小。
- 一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在Eden空间中分配内存。

![image-20241008225531713](%E5%85%AB%E3%80%81%E5%A0%86.assets/image-20241008225531713.png)



### 9、小结堆空间的参数设置

#### 9.1 官方参数说明地址

https://docs.oracle.com/iavase/8/docs/technotes/tools/unix/iava.htm]

#### 9.2 堆空间中常用参数

- -XX:+PrintrlagsInitial:查看所有的参数的默认初始值
- -XX:+Printrlagsrinal :查看所有的参数的最终值(可能会存在修改不再是初始值)
- -Xms:初始堆空间内存(默认为物理内存的1/64)
- -Xmx:最大堆空间内存(默认为物理内存的1/4)
- -Xmn:设置新生代的大小。(初始值及最大值)
- -XX:NewRatio:配置新生代与老年代在堆结构的占比
- -XX:SurvivorRatio:设置新生代中Eden和S0/S1空间的比例
- -XX:MaxTenuringThreshold:设置新生代垃圾的最大年龄（默认即最大，15）
- XX:+PrintGCDetails:输出详细的GC处理日志
  - 打印qc简要信息:①-XX:+PrintGC  ②-verbose:gC
- -XX:HandlePromotionFailure:是否设置空间分配担保





### 10、逃逸分析

#### 10.1 堆是分配对象的唯一选择？

在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述:随着JIT编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。
在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是如果经过逃逸分析(Escape analysis)后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配（说到底就是减少堆中的GC）。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。
此外，前面提到的基于openJDK深度定制的TaoBaoVM，其中创新的GCIH(GCinvisible heap)技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。

#### 10.2 逃逸分析概述

- 如何将堆上的对象分配到栈，需要使用逃逸分析手段。
- 这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。
- 通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。
- 逃逸分析的基本行为就是分析对象动态作用域:
  - 当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。
  - 当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中

#### 10.3 逃逸示例

没有发生逃逸的对象，则可以分配到栈上，随着方法执行的结束，栈空间就被移除。

![image-20241008235235138](%E5%85%AB%E3%80%81%E5%A0%86.assets/image-20241008235235138.png)

发生逃逸

![image-20241008235301138](%E5%85%AB%E3%80%81%E5%A0%86.assets/image-20241008235301138.png)

![image-20241008235310751](%E5%85%AB%E3%80%81%E5%A0%86.assets/image-20241008235310751.png)

![image-20241008235320184](%E5%85%AB%E3%80%81%E5%A0%86.assets/image-20241008235320184.png)



#### 10.4 参数设置

- 在JDK 6u23版本之后，HotSpot中默认就已经开启了逃逸分析。
- 如果使用的是较早的版本，开发人员则可以通过
  - 选项“-XX:+DoEscapeAnalysis"显式开启逃逸分析
  - 通过选项“-XX:+PrintEscapeAnalysis"查看逃逸分析的筛选结果。



#### 10.5 结论

开发中能使用局部变量的，就不要定义在方法外面，使用逃逸分析，避免过多对象在堆中，频繁出现GC



