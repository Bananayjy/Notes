## 八、堆

### 1、堆的核心概述

#### 1.1 位置

堆和方法区对于一个进程来说是唯一的，一个进程对应一个JVM的实例，一个JVM实例就有一个运行时数据区（即Runtime Data Area），一个进程有多个线程，多个线程共享堆空间和方法区，每给线程有一份自己的程序计数器、本地方法栈、虚拟机栈。

![image-20241006230500618](%E5%85%AB%E3%80%81%E5%A0%86.assets/image-20241006230500618.png)

- 一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域

- Java 堆区在JVM 启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间。

  - 堆内存的大小是可以调节的(-Xms)。

- 《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的（通过物理空间和虚拟空间的映射表完成映射）

- 所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区(ThreadLocal Allocation Buffer,TLAB，线程安全，并发性好)

- 《Java虚拟机规范》中对Java堆的描述是:所有的对象实例以及数组都应当在运行时分配在堆上。

  - 我要说的是:“几乎”所有的对象实例都在这里分配内存。从实际使用角度看的。

- 数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。

  ![image-20241007000339376](%E5%85%AB%E3%80%81%E5%A0%86.assets/image-20241007000339376.png)

- 在方法结束后，栈中的引用就从虚拟机栈中出栈了，但堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除（防止堆空间中回收的频率高，影响用户线程的执行）
- 堆，是GC(Garbage Collection，垃圾收集器)执行垃圾回收的重点区域。



#### 1.2 内存细分

![image-20241007002834184](%E5%85%AB%E3%80%81%E5%A0%86.assets/image-20241007002834184.png)

堆空间只计算新生代和老年代，不包含永久区（元空间）

![image-20241007002907192](%E5%85%AB%E3%80%81%E5%A0%86.assets/image-20241007002907192.png)



![image-20241007002912545](%E5%85%AB%E3%80%81%E5%A0%86.assets/image-20241007002912545.png)



### 2、设置堆内存大小与OOM

#### 2.1 堆空间大小的设置

- Java堆区用于存储Java对象实例，那么堆的大小在JM启动时就已经设定好了，大家可以通过选项“-Xmx"和”-Xms"来进行设置。
  - “-Xms”用于表示堆区的起始内存，等价于-XX:InitialHeapSize
  - “-Xmx"则用于表示堆区的最大内存，等价于-XX:MaxHeapSize
- 一旦堆区中的内存大小超过“-Xmx"所指定的最大内存时，将会抛出OutOfMemoryError异常。
- 通常会将-Xms和-Xmx两个参数配置相同的值，其目的是为了能够在iava垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能（避免gc后，频繁扩容释放，调转堆大小，增加系统压力）
- 默认情况下，初始内存大小:物理电脑内存大小/64，最大内存大小:物理电脑内存大小/4



#### 2.2 查看设置参数

- 方式一：jps / jstat -gc 进程id（查看各个进程内存使用情况）

运行如下代码

```java
public class HeapSpaceInitial {

    public static void main(String[] args) throws InterruptedException {
        // java虚拟机中的堆内存总量
        long initialMemory = Runtime.getRuntime().totalMemory() / 1024 / 1024;

        // java虚拟机视图使用的最大堆内存量
        long maxMemory = Runtime.getRuntime().maxMemory() / 1024 / 1024;

        System.out.println("-Xms:" + initialMemory + "M");
        System.out.println("-Xmx:" + maxMemory + "M");



        Thread.sleep(100000000);
    }
}
```

执行相关命令

![image-20241007013235877](%E5%85%AB%E3%80%81%E5%A0%86.assets/image-20241007013235877.png)

- SOC：S0空间
- S1C：S1空间
- S0U：S0使用量
- S1U：S0使用量
- EC：伊甸园区空间
- EU：伊甸园区使用量
- OC：老年代空间
- OU：老年代使用量

注意：Runtime.getRuntime().totalMemory()打印出来的内存空间，原因是S0和S1区只能二选一来进行存储。



- 方式二：-XX:+PrintGCDetails 在运行结束后打印内存信息

![image-20241007013918777](%E5%85%AB%E3%80%81%E5%A0%86.assets/image-20241007013918777.png)

![image-20241007013930489](%E5%85%AB%E3%80%81%E5%A0%86.assets/image-20241007013930489.png)



#### 2.3 OutOfMemor举例

代码示例

```java
package com.example.JVMTEST.Heap;

import java.util.ArrayList;
import java.util.Random;

/**
 * OOM场景示例
 * 设置内存参数：-Xms600m -Xmx600m
 * @author banana
 * @create 2024-10-07 15:20
 */
public class OOMTest {

    public static void main(String[] args) {
        ArrayList<Picture> list = new ArrayList<>();
        while(true) {
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                System.out.println(e);
            }
            list.add(new Picture(new Random().nextInt(1024 * 1024)));
        }
    }
}

class Picture {

    private byte[] pixles;

    public Picture(int len) {
        this.pixles = new byte[len];
    }

}

```

报错信息

```
Exception in thread "main" java.lang.OutOfMemoryError: Java heap space
	at com.example.JVMTEST.Heap.Picture.<init>(OOMTest.java:32)
	at com.example.JVMTEST.Heap.OOMTest.main(OOMTest.java:22)
```

java VisualVM信息

![image-20241007155104203](%E5%85%AB%E3%80%81%E5%A0%86.assets/image-20241007155104203.png)



###  3、年轻代与老年代

#### 3.1 简介

- 存储在JVM中的Java对象可以被划分为两类:
  - 一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速。
  - 另外一类对象的生命周期却非常长，在某些极端的情况下还能够与M的生命周期保持一致。
- Java堆区进一步细分的话，可以划分为年轻代(YoungGen)和老年代(oldGen)
- 其中年轻代又可以划分为Eden空间、Survivor0空间和Survivor1空间(有时也叫做from区、to区)

![image-20241007155643300](%E5%85%AB%E3%80%81%E5%A0%86.assets/image-20241007155643300.png)

#### 3.2 参数调整

默认堆空间各个部分的参数

![image-20241007161244320](%E5%85%AB%E3%80%81%E5%A0%86.assets/image-20241007161244320.png)

配置新生代与老年代在堆结构的占比

- 默认-XX:NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3
- 可以修改-XX:NewRatio=4，表示新生代占1，老年代占4，新生代占整个堆的1/5
- 在HotSpot中，Eden空间和另外两个Survivor空间缺省所占的比例是8:1:1
- 当然开发人员可以通过选项“-XX:SurvivorRatio”调整这个空间比例。比如-XX:SurvivorRatio=8
- 几乎所有的Java对象都是在Eden区被new出来的。
- 绝大部分的Java对象的销毁都在新生代进行了。IBM 公司的专门研究表明，新生代中80%的对象都是“朝生夕死”的。
- 可以使用选项”-Xmn"设置新生代最大内存大小， 这个参数一般使用默认值就可以了（同时设置-Xmn和-XX:NewRatio，-Xmn的优先级更加高）

其中流转过程如下所示

![image-20241007161525506](%E5%85%AB%E3%80%81%E5%A0%86.assets/image-20241007161525506.png)



### 4、图解对象分解过程

#### 4.1 概述

为新对象分配内存是一件非常严谨和复杂的任务，JVM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中您生内存碎片。

#### 4.2 具体过程

- new的对象先放伊甸园区。此区有大小限制。

- 当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收(Minor GC)，将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区

- 然后将伊甸园中的剩余对象移动到幸存者0区:如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区。

- 如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区

- 默认是15次后去养老区

  - 可以设置参数:-XX:MaxTenuringThreshold=<N>进行设置

- 在养老区，相对悠闲。当养老区内存不足时，再次触发GC:MajorGC，进行养老区的内存清理。

- 若养老区执行了Major GC之后发现依然无法进行对象的保存，就会产生OOM异常

  ```
  java.lang.OutOfMemoryError:Java heap space
  ```

#### 4.3 图示

![image-20241007181548379](%E5%85%AB%E3%80%81%E5%A0%86.assets/image-20241007181548379.png)

#### 4.4 总结

- 针对幸存者s0,s1区的总结:复制之后有交换，谁空谁是to，非空的为from
- 关于垃圾回收:频繁在新生区收集，很少在养老区收集，几乎不在永久区元空间收集。



#### 4.5 对象分配特殊情况

即关于Eden区和S0、S1区放不下时候，都是会将对象晋升到老年区，如果老年区也放不下，出发FGC，再次尝试放老年代，如果还是放不下，老年代会尝试扩然，如果还是放不下，爆OOM

扩容机制（△）：

- 老年区扩容：老年区的扩容通常是由 JVM 的内存管理策略决定的。不同的 JVM 实现可能会有不同的扩容策略，但一般情况下，老年区会在以下条件下尝试扩容：
  - 如果在 Full GC 过程中发现老年区的使用率达到了某个阈值。
  - 具体的扩容行为一般依赖于 JVM 的参数设置，比如 `-XX:MaxHeapSize` 和 `-XX:NewRatio` 等。
- 扩容条件：老年区的扩容可以根据 JVM 的实现而有所不同，一般情况下会考虑整体堆的大小设置、当前内存使用情况以及其他一些 JVM 的配置参数。
- 最终结果：如果老年区扩容后仍然无法容纳新的对象，系统就会抛出 OutOfMemoryError（OOM）。

![image-20241007184716786](%E5%85%AB%E3%80%81%E5%A0%86.assets/image-20241007184716786.png)



#### 4.6 调优工具

- JDK命令行
- Eclipse:Memory Analyzer Tool
- Jconsole
- VisualVM
- Jprofiler
- Java Flight Recorder
- GCViewer
- GC Easy



### 5、Minor GC、Major GC、Full GC

JVM在进行GC时，并非每次都对上面三个内存(新生代、老年代、方法区)区域一起回收的，大部分时候回收的都是指新生代。

针对Hotspot VM的实现，它里面的GC按照回收区域又分为两大种类型:一种是部分收集(Partial GC)，一种是整堆收集(Full GC)

- 部分收集:不是完整收集整个Java堆的垃圾收集。其中又分为:
  - 新生代收集(Minor GC / Young GC):只是新生代的垃圾收集
  - 老年代收集(Major GC / old GC):只是老年代的垃圾收集。
    -  目前，只有CMS GC会有单独收集老年代的行为。
    -  注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收。
  - 混合收集(Mixed GC):收集整个新生代以及部分老年代的垃圾收集。√
    - 目前，只有G1 GC会有这种行为

- 整堆收集(Fu11 GC):收集整个java堆和方法区的垃圾收集。

- 年轻代GC(Minor GC)触发机制:

  - 当年轻代空间不足时，就会触发Minor GC，这里的年轻代满指的是Eden代满，survivor满不会引发GC。(每次 Minor GC的同时会清理年轻代的内存)
  - 因为 Java 对象大多都具备朝生夕灭的特性，所以MinorGc非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。
  - Minor GC会引发STW，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行。

  ![image-20241007215709546](%E5%85%AB%E3%80%81%E5%A0%86.assets/image-20241007215709546.png)

- 老年代GC(Major GC / Full GC)触发机制:

  - 指发生在老年代的GC，对象从老年代消失时，我们说“MajorGC”或“Full GC”发生了。
  - 出现了Major GC，经常会伴随至少一次的Minor GC(但非绝对的，在ParalleL Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程)。
    - 也就是在老年代空间不足时，会先尝试触发Minor GC。如果之后空间还不足，则触发Major GC

  - Major GC的速度一般会比Minor Gc慢8倍以上，STW的时间更长。
  - 如果Major GC后，内存还不足，就报OOM了。
  - Major GC的速度一般会比Minor GC慢10倍以上。



- Full GC触发机制:

  触发Full GC 执行的情况有如下五种:
  (1)调用system.gc()时，系统建议执行Full GC，但是不必然执行
  (2)老年代空间不足
  (3)方法区空间不足
  (4)通过Minor GC后进入老年代的平均大小大于老年代的可用内存
  (5)由Eden区、survivor space0(From Space)区向survivor space1(To Space)区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小
  说明:full gc是开发或调优中尽量要避免的。这样暂时时间会短一些



### 6、堆空间分代思想

#### 6.1 为什么需要把Jaya堆分代?不分代就不能正常工作了吗

- 经研究，不同对象的生命周期不同。70%-99%的对象是临时对象
- 新生代:有Eden、两块大小相同的survivor(又称为from/to，s0/s1)构成to总为空。
- 老年代:存放新生代中经历多次GC仍然存活的对象。

#### 6.2 为什么需要把Java堆分代?不分代就不能正常工作了吗?

其实不分代完全可以，分代的唯一理由就是优化GC性能。如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC的时候要找到哪些对象没用这样就会对堆的所有区域进行扫描。而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当GC的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来

![image-20241007232022384](%E5%85%AB%E3%80%81%E5%A0%86.assets/image-20241007232022384.png)



### 7、内存分配策略

如果对象在Eden 出生并经过第一次MinorGC后仍然存活，并且能被survivor容纳的话，将被移动到survivor空间中，并将对象年龄设为1。对象在年龄就增加1岁，当它的年龄增加到一定Survivor 区中每熬过一次MinorGC，年龄就增加1岁。当它的年龄增加到一定程度(默认为15岁，其实每个JVM、每个GC都有所不同)时，就会被晋升到老年代中。
对象晋升老年代的年龄阈值，可以通过选项-xx:MaxTenuringThreshold来设置



针对不同年龄段的对象分配原则如下所示:

- 优先分配到Eder
- 大对象直接分配到老年代
  - 尽量避免程序中出现过多的大对象
- 长期存活的对象分配到老年代
- 动态对象年龄判断
  - 如果survivor 区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。
- 空间分配担保
  - -XX:HandlePromotionFailure



### 8、为对象分配内存：TLAB

### 9、小结堆空间的参数设置

### 10、堆是分配对象的唯一选择吗

