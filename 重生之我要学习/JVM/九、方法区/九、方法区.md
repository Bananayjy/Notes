## 九、方法区

### 1、栈、堆、方法区的交互关系

### 1.1 运行时数据区结构图

Method Area为方法区位置如下

![image-20241013003248535](%E4%B9%9D%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA.assets/image-20241013003248535.png)

从线程共享与否的角度来看

![image-20241013003532768](%E4%B9%9D%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA.assets/image-20241013003532768.png)





### 1.2 堆、栈、方法区的交互关系

new一个对象时，各个内容的存储位置

![image-20241013003902917](%E4%B9%9D%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA.assets/image-20241013003902917.png)



数据区中，上述内容存储在堆、栈、方法区的内容及位置

![image-20241013004202435](%E4%B9%9D%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA.assets/image-20241013004202435.png)



### 2、方法区的理解

#### 2.1 官方文档

https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms.2.5.4

#### 2.2 基本理解

- java中的方法区和Java堆一样，是各个线程共享的区域，如创建了一个类对象（class对象），可以被被多个线程共享使用。

- 方法区和传统语言编译好之后存储的区域是类似的，即方法区存储的也是字节码指令，与操作系统编译好之后的文本片段类似。其存储的是类的结构，运行时常量池、属性和方法的数据、方法和构造器的字节码，还包括特殊的一些方法，用于类或实例、接口的初始化。

- 方法区在虚拟机启动的时候创建，其占用的内容物理上可以是不连续的，但逻辑上是连续的

-  逻辑上可以把方法区看做是堆的一部分，堆有gc、垃圾算法，但是在具体虚拟机实现中，方法区可以不去实现压缩和gc

- 方法区的大小和堆空间一样，可以选择固定的大小，也可以动态地修改扩展（当用不了那么多的时候，会自动压缩）

- 方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：java.lang.OutOfMemoryError:PermGen space（在Java 8之前的版本中，PermGen space用于存储类的元数据，包括类的结构、方法、注解等，以及内部字符串常量池等） 或者java.langOutOfMemoryError:Metaspace（从Java 8开始，Metaspace替代了PermGen space，同样用于存储类的元数据）。出现内存溢出的情况：加载大量的第三方jar包;Tomcat部署的工程过大（30-50个）;大量动态反射类;

- 关闭JVM就会释放方法区的内存

  

总结：《Java虚拟机规范》中说明，尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的JVM实现可能不会选择去进行垃圾收集或者进行压缩。但对于HotSpot JVM而言，方法区还有一个别名叫做Non-Heap(非堆)，目的就是要和堆分开（堆中主要存放new的对象，方法区存放类的信息，而不需要去new，从这个角度来说，也可以将两者区分开来；以及在通过参数设置堆大小的时候，也不会影响到方法区的大小）。所以，方法区看作是一块独立于Java堆的内存空间，如下图所示

![image-20250106214411637](%E4%B9%9D%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA.assets/image-20250106214411637.png)

### 2.3 Hotspot中方法区的演进

- 在jdk7及以前，习惯上把方法区，称为永久代。jdk8开始，使用元空间取代了永久代。（本质上，方法区和永久代并不等价。仅是对hotspot而言的。《Java虚拟机规范》对如何实现方法区，不做统一要求。例如:BEAJRockit/IBMJ9中不存在永久代的概念）

  ![image-20250106222334111](%E4%B9%9D%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA.assets/image-20250106222334111.png)

- 当年使用永久代，不是很好，因为使用的是JVM的内存（相较于本地内存比较小），从而导致Java程序更容易OOM(超过-XX:MaxPermSize上限)

- 而到了JDK-8，终于完全废弃了永久代的概念，改用与JRockit（最快的虚拟机？）、J9一样在本地内存（即电脑的内存，一般有好几个G）中实现的元空间(Metaspace)来代替

- 元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于:元空间不在虚拟机设置的内存中，而是使用本地内存。

- 永久代、元空间二者并不只是名字变了，内部结构也调整了（如静态变量、字符串常量池等）

- 根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时（即本地内存不够大时），将抛出OOM异常。

### 3、设置方法区大小与OOM

### 4、方法区的内部结构

### 5、 方法区使用举例

### 6、方法区的演进细节

### 7、方法区的垃圾回收

### 8、总结



