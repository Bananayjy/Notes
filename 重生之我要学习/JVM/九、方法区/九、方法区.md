## 九、方法区

### 1、栈、堆、方法区的交互关系

#### 1.1 运行时数据区结构图

Method Area为方法区位置如下

![image-20241013003248535](%E4%B9%9D%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA.assets/image-20241013003248535.png)

从线程共享与否的角度来看

![image-20241013003532768](%E4%B9%9D%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA.assets/image-20241013003532768.png)

#### 1.2 堆、栈、方法区的交互关系

new一个对象时，各个内容的存储位置

![image-20241013003902917](%E4%B9%9D%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA.assets/image-20241013003902917.png)



数据区中，上述内容存储在堆、栈、方法区的内容及位置

![image-20241013004202435](%E4%B9%9D%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA.assets/image-20241013004202435.png)



### 2、方法区的理解

#### 2.1 官方文档

https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms.2.5.4

#### 2.2 基本理解

- java中的方法区和Java堆一样，是各个线程共享的区域，如创建了一个类对象（class对象），可以被被多个线程共享使用。

- 方法区和传统语言编译好之后存储的区域是类似的，即方法区存储的也是字节码指令，与操作系统编译好之后的文本片段类似。其存储的是类的结构，运行时常量池、属性和方法的数据、方法和构造器的字节码，还包括特殊的一些方法，用于类或实例、接口的初始化。

- 方法区在虚拟机启动的时候创建，其占用的内容物理上可以是不连续的，但逻辑上是连续的

-  逻辑上可以把方法区看做是堆的一部分，堆有gc、垃圾算法，但是在具体虚拟机实现中，方法区可以不去实现压缩和gc

- 方法区的大小和堆空间一样，可以选择固定的大小，也可以动态地修改扩展（当用不了那么多的时候，会自动压缩）

- 方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：java.lang.OutOfMemoryError:PermGen space（在Java 8之前的版本中，PermGen space用于存储类的元数据，包括类的结构、方法、注解等，以及内部字符串常量池等） 或者java.langOutOfMemoryError:Metaspace（从Java 8开始，Metaspace替代了PermGen space，同样用于存储类的元数据）。出现内存溢出的情况：加载大量的第三方jar包;Tomcat部署的工程过大（30-50个）;大量动态反射类;

- 关闭JVM就会释放方法区的内存

  

总结：《Java虚拟机规范》中说明，尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的JVM实现可能不会选择去进行垃圾收集或者进行压缩。但对于HotSpot JVM而言，方法区还有一个别名叫做Non-Heap(非堆)，目的就是要和堆分开（堆中主要存放new的对象，方法区存放类的信息，而不需要去new，从这个角度来说，也可以将两者区分开来；以及在通过参数设置堆大小的时候，也不会影响到方法区的大小）。所以，方法区看作是一块独立于Java堆的内存空间，如下图所示

![image-20250106214411637](%E4%B9%9D%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA.assets/image-20250106214411637.png)

#### 2.3 Hotspot中方法区的演进

- 在jdk7及以前，习惯上把方法区，称为永久代。jdk8开始，使用元空间取代了永久代。（本质上，方法区和永久代并不等价。仅是对hotspot而言的。《Java虚拟机规范》对如何实现方法区，不做统一要求。例如:BEAJRockit/IBMJ9中不存在永久代的概念）

  ![image-20250106222334111](%E4%B9%9D%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA.assets/image-20250106222334111.png)

- 当年使用永久代，不是很好，因为使用的是JVM的内存（相较于本地内存比较小），从而导致Java程序更容易OOM(超过-XX:MaxPermSize上限)

- 而到了JDK-8，终于完全废弃了永久代的概念，改用与JRockit（最快的虚拟机？）、J9一样在本地内存（即电脑的内存，一般有好几个G）中实现的元空间(Metaspace)来代替

- 元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于:元空间不在虚拟机设置的内存中，而是使用本地内存。

- 永久代、元空间二者并不只是名字变了，内部结构也调整了（如静态变量、字符串常量池等）

- 根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时（即本地内存不够大时），将抛出OOM异常。

### 3、设置方法区大小与OOM

#### 3.1 设置方法区大小

方法区的大小不一定是固定的，jvm可以根据应用的需要动态进行调整。

jdk7及以前：

- 通过-xx:Permsize来设置永久代初始分配空间。默认值是20.75M

- -xx:MaxPermsize来设定永久代最大可分配空间。32位机器默认是64M，64位机器模式是82M

  ![image-20250106224359930](%E4%B9%9D%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA.assets/image-20250106224359930.png)

- 当JVM加载的类信息容量超过了这个值，会报异常OutOfMemoryError:PermGenspace 

jdk8及以后：

- 元数据区大小可以使用参数-XX:MetaspaceSize和-XX:MaxMetaspacesize指定替代上述原有的两个参数。
- 默认值依赖于平台。windows下，-XX:Metaspacesize是21M，XX:MaxMetaspacesize 的值是-1，即没有限制（本地内存有多大就有多大）。
- 与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常OutOfMemoryError:Metaspace
- -XX:Metaspacesize:设置初始的元空间大小。对于一个64位的服务器端J来说其默认的-XX:Metaspacesize值为21MB。这就是初始的高水位线，一旦触及这个水位线，Full GC将会被触发并卸载没用的类(即这些类对应的类加载器不再存活)然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间。如果释放的空间不足，那么在不超过MaxMetaspacesize时，适当提高该值。如果释放空间过多，则适当降低该值。
- 如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到Full GC多次调用。为了避免频繁地GC，建议将-XX:Metaspacesize设置为一个相对较高的值。



#### 3.2 方法区OOM

（1）深入JVM中的一个例子

通过CGLib动态代理，产生内存溢出OOM

![image-20250107211043306](%E4%B9%9D%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA.assets/image-20250107211043306.png)



（2）示例2

在元空间中增加了10000个类

![image-20250107211259270](%E4%B9%9D%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA.assets/image-20250107211259270.png)

#### 3.4 如何解决OOM

- 要解决OOM异常或heap space的异常（内存空间异常可能是堆空间溢出，也有可能是元空间溢出，但是遇到比较多的时堆空间的溢出），一般的手段是首先通过内存映像分析工具(如Eclipse Memory Analyzer、jvisualvm、JProfiler)对dump 出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏(Memory Leak)还是内存溢出(Memory overflow)
- 如果是内存泄漏（堆中的对象没有引用指向它了就会被回收，但是如果有引用指向的堆对象后面没有使用了，但却始终和GC Roots关联，始终释放不掉），可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象是通过怎样的路径与GC  Roots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及GC Roots引用链的信息，就可以比较准确地定位出泄漏代码的位置。
- 如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数(-Xmx与-Xms)，与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。



### 4、方法区的内部结构

#### 4.1 图示

![image-20250107213008725](%E4%B9%9D%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA.assets/image-20250107213008725.png)

#### 4.2 方法区中存储内容

《深入理解Java 虚拟机》书中对方法区(Method Area)存储内容描述如下:它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。

![image-20250107213342649](%E4%B9%9D%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA.assets/image-20250107213342649.png)

- 类型信息

对每个加载的类型(类clags、接口interface、枚举enum、注解annotation)，JVM必
须在方法区中存储以下类型信息:

1. 这个类型的完整有效名称(全名=包名.类名)
2. 这个类型直接父类的完整有效名(对于interface或是java.lang.Object，都没有父类)
3. 这个类型的修饰符(public,abstract,final的某个子集)
4. 这个类型直接接口的一个有序列表(因为一个类实现接口可以有多个)

- 域（Field）信息（即成员变量、属性）

1. JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。
2. 域的相关信息包括: 域名称、域类型、域修饰符(public，privateprotected,static,final,volatile,transient的某个子集，即可以有多个修饰符)

- 方法（Method）信息

1. 方法名称
2. 方法的返回类型(或 void)
3. 方法参数的数量和类型(按顺序)
4. 方法的修饰符(public,private,protected，static，final,synchronized，native，abstract的一个子集)
5. 方法的字节码(bytecodes)、操作数栈、局部变量表及大小(abstract和native方法除外)
6. 异常表(abstract和native方法除外) 每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引

- 常量池和运行时常量池

  ![image-20250108235018967](%E4%B9%9D%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA.assets/image-20250108235018967.png)

  方法区，内部包含了运行时常量池。字节码文件，内部包含了常量池，要弄清楚方法区，需要理解清楚ClassFile，因为加载类的信息都在方法区，要弄清楚方法区的运行时常量池，需要理解清楚ClassFile中的常量池。

  ![image-20250108235404999](%E4%B9%9D%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA.assets/image-20250108235404999.png)

  一个有效的字节码文件（ClassFile）中除了包含类的版本信息、字段、方法以及接口等描述信息外，还包含一项信息那就是常量池表(constantPool Table)，包括各种字面量和对类型、域和方法（如变量名称、一些字符串）的**符号引用**。

  一个java源文件中的类、接口，编译后产生一个字节码文件。而Java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池这个字节码包含了指向常量池的引用。在动态链接的时候会用到运行时常量池，之前有介绍。如下代码：

  ![image-20250108235604102](%E4%B9%9D%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA.assets/image-20250108235604102.png)

  虽然只有194字节，但是里面却使用了string、System、Printstream及obiect等结构。这里代码量其实已经很小了。如果代码多，引用到的结构会更多!这里就需要常量池了

  ![image-20250108235711530](%E4%B9%9D%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA.assets/image-20250108235711530.png)

  因此，对于常量池，可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型。

  那么关于运行时常量池：

  ![image-20250108235812603](%E4%B9%9D%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA.assets/image-20250108235812603.png)







可以通过字节码文件看到会被加载到方法区的相关内容（字节码中的类信息会通过类加载器加载到方法区中，还会存放该字节码文件使用的是哪一个类加载器加载进来的，即classLoader，但是字节码文件中不存在类加载器的信息。一个类加载到方法区中，记录了是被谁加载的，classLoader也会记录它加载了谁，互相加载）

弄一个代码示例，看看有什么内容会被存储到方法区中：

```java
public class MethodInnerStructTest {

    // 属性
    public int num = 10;
    private static String str = "测试";

    // 空参构造器

    // 方法
    public void test1() {
        int count = 20;
        System.out.println("count=" + count);
    }

    // 静态方法
    public static int test2(int cal) {
        int result = 0;
        try {
            int value = 30;
            result = value / cal;
        } catch (Exception e) {
            e.printStackTrace();
        }
        return result;
    }

    @Override
    public boolean equals(Object obj) {
        System.out.println("guagua");
        return super.equals(obj);
    }
}
```

对该类进行编译后，在控制台中通过 javap -v -p命令对该类进行反编译查看其字节码文件内容

![image-20250107222047933](%E4%B9%9D%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA.assets/image-20250107222047933.png)

首先可以看到该类的全类名、继承父类和实现接口，即类型信息

![image-20250107222359879](%E4%B9%9D%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA.assets/image-20250107222359879.png)

类的修饰符

![image-20250107222627064](%E4%B9%9D%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA.assets/image-20250107222627064.png)

域信息

![image-20250107222702280](%E4%B9%9D%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA.assets/image-20250107222702280.png)

方法，包括空参构造器（未声明，默认提供，在字节码角度看也是方法，源代码看区分方法和构造器）

![image-20250107222741912](%E4%B9%9D%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA.assets/image-20250107222741912.png)

方法中记录操作数栈、局部变量表、参数大小

![image-20250107222845612](%E4%B9%9D%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA.assets/image-20250107222845612.png)

异常表

![image-20250107223054599](%E4%B9%9D%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA.assets/image-20250107223054599.png)



> 扩展：
>
> non-final的类变量
>
> - 静态变量和类关联在一起，而不需要创建实体对象就能使用，其随着类的加载而加载，成为类数据在逻辑上的一部分。
>
>   ```java
>   public class NonFinalTest {
>   
>       public static void main(String[] args) {
>           A.method();	// baga
>           System.out.println(A.count);	// 1
>       }
>   
>   }
>   
>   class A {
>   
>       public static int count = 1;
>   
>       public static void method() {
>           System.out.println("baga");
>       }
>   
>   }
>   ```
>
> - 类变量被类所有实例共享，即使没有类实例时你也可以访问它。
>
>   ```java
>   public class NonFinalTest {
>   
>       public static void main(String[] args) {
>           // 虽然不会这么去用
>           A a = null;
>           a.method();		// baga
>           int count = a.count;	
>           System.out.println(count);	// 1
>       }
>   
>   }
>   
>   class A {
>   
>       public static int count = 1;
>   
>       public static void method() {
>           System.out.println("baga");
>       }
>   
>   }
>   ```
>
> - 关于全局常量（即用static修饰、又用final修饰），被声明为final的类变量的处理方法则不同，每个全局常量在编译的时候就会被分配了。
>
>   ```java
>   public class NonFinalTest {
>   
>       public static void main(String[] args) {
>           A.method();
>           System.out.println(A.count);
>       }
>   
>   }
>   
>   class A {
>   
>       public static int count = 1;
>       public static final int count2 = 2;
>   
>       public static void method() {
>           System.out.println("baga");
>       }
>   
>   }
>   ```
>
>   对于类A中声明了两个静态属性，一个是final修饰的，一个没有，我们通过javap -p -v对其字节码文件i进行反编译查看，可以看到对于全局常量count2在编译的时候就将值写进去了，而对于count的值在类加载器加载的Linking的Prepare过程中进行初始化（默认值=0），在Initalization过程中对其进行赋值1.
>
>   ![image-20250108234510073](%E4%B9%9D%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA.assets/image-20250108234510073.png)









### 5、 方法区使用举例

### 6、方法区的演进细节

### 7、方法区的垃圾回收

### 8、总结



