## 九、方法区

### 1、栈、堆、方法区的交互关系

#### 1.1 运行时数据区结构图

Method Area为方法区位置如下

![image-20241013003248535](%E4%B9%9D%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA.assets/image-20241013003248535.png)

从线程共享与否的角度来看

![image-20241013003532768](%E4%B9%9D%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA.assets/image-20241013003532768.png)

#### 1.2 堆、栈、方法区的交互关系

new一个对象时，各个内容的存储位置

![image-20241013003902917](%E4%B9%9D%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA.assets/image-20241013003902917.png)



数据区中，上述内容存储在堆、栈、方法区的内容及位置

![image-20241013004202435](%E4%B9%9D%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA.assets/image-20241013004202435.png)



### 2、方法区的理解

#### 2.1 官方文档

https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms.2.5.4

#### 2.2 基本理解

- java中的方法区和Java堆一样，是各个线程共享的区域，如创建了一个类对象（class对象），可以被被多个线程共享使用。

- 方法区和传统语言编译好之后存储的区域是类似的，即方法区存储的也是字节码指令，与操作系统编译好之后的文本片段类似。其存储的是类的结构，运行时常量池、属性和方法的数据、方法和构造器的字节码，还包括特殊的一些方法，用于类或实例、接口的初始化。

- 方法区在虚拟机启动的时候创建，其占用的内容物理上可以是不连续的，但逻辑上是连续的

-  逻辑上可以把方法区看做是堆的一部分，堆有gc、垃圾算法，但是在具体虚拟机实现中，方法区可以不去实现压缩和gc

- 方法区的大小和堆空间一样，可以选择固定的大小，也可以动态地修改扩展（当用不了那么多的时候，会自动压缩）

- 方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：java.lang.OutOfMemoryError:PermGen space（在Java 8之前的版本中，PermGen space用于存储类的元数据，包括类的结构、方法、注解等，以及内部字符串常量池等） 或者java.langOutOfMemoryError:Metaspace（从Java 8开始，Metaspace替代了PermGen space，同样用于存储类的元数据）。出现内存溢出的情况：加载大量的第三方jar包;Tomcat部署的工程过大（30-50个）;大量动态反射类;

- 关闭JVM就会释放方法区的内存

  

总结：《Java虚拟机规范》中说明，尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的JVM实现可能不会选择去进行垃圾收集或者进行压缩。但对于HotSpot JVM而言，方法区还有一个别名叫做Non-Heap(非堆)，目的就是要和堆分开（堆中主要存放new的对象，方法区存放类的信息，而不需要去new，从这个角度来说，也可以将两者区分开来；以及在通过参数设置堆大小的时候，也不会影响到方法区的大小）。所以，方法区看作是一块独立于Java堆的内存空间，如下图所示

![image-20250106214411637](%E4%B9%9D%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA.assets/image-20250106214411637.png)

#### 2.3 Hotspot中方法区的演进

- 在jdk7及以前，习惯上把方法区，称为永久代。jdk8开始，使用元空间取代了永久代。（本质上，方法区和永久代并不等价。仅是对hotspot而言的。《Java虚拟机规范》对如何实现方法区，不做统一要求。例如:BEAJRockit/IBMJ9中不存在永久代的概念）

  ![image-20250106222334111](%E4%B9%9D%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA.assets/image-20250106222334111.png)

- 当年使用永久代，不是很好，因为使用的是JVM的内存（相较于本地内存比较小），从而导致Java程序更容易OOM(超过-XX:MaxPermSize上限)

- 而到了JDK-8，终于完全废弃了永久代的概念，改用与JRockit（最快的虚拟机？）、J9一样在本地内存（即电脑的内存，一般有好几个G）中实现的元空间(Metaspace)来代替

- 元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于:元空间不在虚拟机设置的内存中，而是使用本地内存。

- 永久代、元空间二者并不只是名字变了，内部结构也调整了（如静态变量、字符串常量池等）

- 根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时（即本地内存不够大时），将抛出OOM异常。

### 3、设置方法区大小与OOM

#### 3.1 设置方法区大小

方法区的大小不一定是固定的，jvm可以根据应用的需要动态进行调整。

jdk7及以前：

- 通过-xx:Permsize来设置永久代初始分配空间。默认值是20.75M

- -xx:MaxPermsize来设定永久代最大可分配空间。32位机器默认是64M，64位机器模式是82M

  ![image-20250106224359930](%E4%B9%9D%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA.assets/image-20250106224359930.png)

- 当JVM加载的类信息容量超过了这个值，会报异常OutOfMemoryError:PermGenspace 

jdk8及以后：

- 元数据区大小可以使用参数-XX:MetaspaceSize和-XX:MaxMetaspacesize指定替代上述原有的两个参数。
- 默认值依赖于平台。windows下，-XX:Metaspacesize是21M，XX:MaxMetaspacesize 的值是-1，即没有限制（本地内存有多大就有多大）。
- 与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常OutOfMemoryError:Metaspace
- -XX:Metaspacesize:设置初始的元空间大小。对于一个64位的服务器端J来说其默认的-XX:Metaspacesize值为21MB。这就是初始的高水位线，一旦触及这个水位线，Full GC将会被触发并卸载没用的类(即这些类对应的类加载器不再存活)然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间。如果释放的空间不足，那么在不超过MaxMetaspacesize时，适当提高该值。如果释放空间过多，则适当降低该值。
- 如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到Full GC多次调用。为了避免频繁地GC，建议将-XX:Metaspacesize设置为一个相对较高的值。



#### 3.2 方法区OOM

（1）深入JVM中的一个例子

通过CGLib动态代理，产生内存溢出OOM

![image-20250107211043306](%E4%B9%9D%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA.assets/image-20250107211043306.png)



（2）示例2

在元空间中增加了10000个类

![image-20250107211259270](%E4%B9%9D%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA.assets/image-20250107211259270.png)

#### 3.4 如何解决OOM

- 要解决OOM异常或heap space的异常（内存空间异常可能是堆空间溢出，也有可能是元空间溢出，但是遇到比较多的时堆空间的溢出），一般的手段是首先通过内存映像分析工具(如Eclipse Memory Analyzer、jvisualvm、JProfiler)对dump 出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏(Memory Leak)还是内存溢出(Memory overflow)
- 如果是内存泄漏（堆中的对象没有引用指向它了就会被回收，但是如果有引用指向的堆对象后面没有使用了，但却始终和GC Roots关联，始终释放不掉），可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象是通过怎样的路径与GC  Roots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及GC Roots引用链的信息，就可以比较准确地定位出泄漏代码的位置。
- 如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数(-Xmx与-Xms)，与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。



### 4、方法区的内部结构

### 5、 方法区使用举例

### 6、方法区的演进细节

### 7、方法区的垃圾回收

### 8、总结



