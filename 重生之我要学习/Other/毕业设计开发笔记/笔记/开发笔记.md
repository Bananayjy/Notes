# 开发笔记

## 零、一些常用命令

#### 1、启动虚拟机

进入当前用户目录，通过命令`vagrant up`启动虚拟机

再次通过`vargrant ssh`连接上虚拟机

切换root用户

```
su root
passwoord:vagrant
```



#### 2、docke相关常用命令

启动docker

```
sudo systemctl start docker
```

设置docker开机自动启动

```
sudo systemctl enable docker
```

查看docker所有的容器

```
docker ps -a
```

## 一、概念相关

#### 1、电商模式

市面上5种电商模式`B2B`、`B2C`、`C2B`、`C2C`、`O2O`

①`B2B`

B2B(Business to Business), 是指商家与商家建立的商业关系。如：阿里巴巴（1688，商家与商家互相购买）。

②`B2C`

B2C（Customer to Consumer），就是我们经常看到的供应商直接把商品卖给用户，即“商对客”模式，也就是通常说的商业零售，直接面向消费者销售产品和服务。如：苏宁易购、京东、天猫、小米商城等。

③`C2B`

C2B（Customer to Business）即消费者对企业。先有消费者需求产生而后有企业生产，即先有消费者提出需求，后有生产企业按需求组织生产。

④`C2C`

C2C（Customer to Consumer），客户之间自己把东西放上网去卖，如：淘宝，闲鱼

⑤`O2O`

O2O（Oline to Offline）， 也即将线上商务的机会与互联网结合在了一起，让互联网成为线下交易的前台。线上快速支付，线下优质服务。如：饿了么，美团，淘票票，京东到家。

## 二、技术相关

### I、问题

#### 1、Maven下的config配置多个settings.xml

一开始我们maven的conf下的配置文件由这么多个

![image-20231231160749694](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231231160749694.png)

但我在实际开发的时候指定的是`settings-TTS.xml`

但是在下载依赖的时候都回去settings.xml中配置的镜像去获取

原因是IDEA中的profiles指的是激活的profile，如下图激活的是jdk-1.8

![image-20231231160828402](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231231160828402.png)

```xml
<profiles>
    <profile>
        <id>jdk-1.8</id>
        <activation>
            <activeByDefault>true</activeByDefault>
            <jdk>1.8</jdk>
        </activation>
        <properties>
            <maven.compiler.source>1.8</maven.compiler.source>
            <maven.compiler.target>1.8</maven.compiler.target>
            <maven.compiler.compilerVersion>1.8</maven.compiler.compilerVersion>
        </properties>
    </profile>
</profiles>
```

但是对应`settings.xml`有一些配置是没有放到profile中的，也就是说会默认加载，如下中配置的镜像内容，这也导致了下载的时候会先去对应的镜像中获取内容

```java
<?xml version="1.0" encoding="UTF-8"?>

<settings xmlns="http://maven.apache.org/SETTINGS/1.2.0"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.2.0 https://maven.apache.org/xsd/settings-1.2.0.xsd">

<localRepository>D:\tool\develop\apache-maven-3.6.1\mvn_repo</localRepository>
  
<pluginGroups>

</pluginGroups>
 
<proxies>

</proxies>

<servers>
<server>
  <id>hs_snapshots</id>
  <username>heitian</username>
  <password>axx123!</password>
</server>
<server>
  <id>hs_releases</id>
  <username>heitian</username>
  <password>axx123!</password>
</server>
</servers>

<mirrors>
<mirror>
	<id>nexus</id>
	<mirrorOf>*</mirrorOf>
	<name>Nexus hs</name>
	<url>http://192.168.9.41:8081/repository/maven-releases/</url>
</mirror>

<mirror>
	<id>Nexus2</id>
	<url>http://192.168.9.41:8081/repository/maven-releases/</url>
	<mirrorOf>public-snapshots</mirrorOf>
</mirror> 
 <!-- 阿里云仓库 -->
<mirror>
  <id>alimaven</id>
  <mirrorOf>central</mirrorOf>
  <name>aliyun maven</name>
  <url>http://maven.aliyun.com/nexus/content/repositories/central/</url>
  <!-- <url>http://maven.aliyun.com/nexus/content/groups/public/</url> -->
</mirror>
<!--    
<mirror>
  <id>maven-default-http-blocker</id>
  <mirrorOf>external:http:*</mirrorOf>
  <name>Pseudo repository to mirror external repositories initially using HTTP.</name>
  <url>http://0.0.0.0/</url>
  <blocked>true</blocked>
</mirror>
-->
</mirrors>

 
  <profiles>
    <profile>
      <id>dev</id>
    </profile>
	<profile>
		<id>public-snapshots</id>
		<repositories>
			<repository>
				<id>public-snapshots</id>	
				<name>Nexus hs</name>
				<url>http://192.168.9.41:8081/repository/maven-releases/</url>
				<releases><enabled>true</enabled></releases>
				<snapshots><enabled>true</enabled></snapshots>
			</repository>
	    </repositories>
		
		<pluginRepositories>
			<pluginRepository>
				<id>public-snapshots</id>
				<name>Nexus hs</name>
				<url>http://192.168.9.41:8081/repository/maven-releases/</url>
				<releases><enabled>true</enabled></releases>
				<snapshots><enabled>true</enabled></snapshots>
			</pluginRepository>
		</pluginRepositories>
	</profile>
  </profiles>

  <activeProfiles>
	<activeProfile>dev</activeProfile>
	<!--<activeProfile>anotherAlwaysActiveProfile</activeProfile>  -->
  </activeProfiles>
</settings>
```



#### 2、xss过滤△

XSS（Cross-Site Scripting）是一种常见的Web安全漏洞，攻击者通过注入恶意脚本代码，使得用户在浏览器端执行该脚本，从而达到攻击的目的。为了防止XSS攻击，我们可以使用XSS过滤来对用户输入的数据进行处理和清理。

下面是一些常见的XSS过滤方法：

1. 输入验证：对用户输入的数据进行校验，只接受合法的输入数据，并拒绝包含特殊字符或HTML标签的数据。
2. 输出转义：将用户输入的特殊字符进行转义，例如将 `<` 转义为 `<`、`>` 转义为 `>` 等。这样可以防止浏览器将其误认为是HTML标签。
3. 白名单过滤：定义一个白名单，只允许特定的标签、属性和样式通过过滤器，其他非法的标签和属性将被删除或替换。
4. 使用安全的富文本编辑器：如果需要用户输入富文本内容，建议使用安全的富文本编辑器，它会自动过滤和清理用户输入的恶意代码。
5. HttpOnly Cookie：将敏感信息存储在 HttpOnly Cookie 中，以防止脚本代码获取到这些信息。
6. CSP（Content Security Policy）：使用CSP来定义页面的资源加载策略，限制页面中可执行的脚本和外部资源的加载来源。

需要注意的是，XSS过滤只是一种防御手段，不能完全解决XSS漏洞。在编写代码时，还应该注意其他安全性措施，如输入验证、权限控制、保持软件及时更新等。

```
/**
 * Copyright (c) 2016-2019 人人开源 All rights reserved.
 *
 * https://www.renren.io
 *
 * 版权所有，侵权必究！
 */

package com.yjy.common.utils.xss;

import javax.servlet.*;
import javax.servlet.http.HttpServletRequest;
import java.io.IOException;

/**
 * XSS过滤
 *
 * @author Mark sunlightcs@gmail.com
 */
public class XssFilter implements Filter {

	@Override
	public void init(FilterConfig config) throws ServletException {
	}

	public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
            throws IOException, ServletException {
		XssHttpServletRequestWrapper xssRequest = new XssHttpServletRequestWrapper(
				(HttpServletRequest) request);
		chain.doFilter(xssRequest, response);
	}

	@Override
	public void destroy() {
	}

}
```



```
/**
 * Copyright (c) 2016-2019 人人开源 All rights reserved.
 *
 * https://www.renren.io
 *
 * 版权所有，侵权必究！
 */

package com.yjy.common.utils.xss;

import org.apache.commons.io.IOUtils;
import org.apache.commons.lang.StringUtils;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;

import javax.servlet.ReadListener;
import javax.servlet.ServletInputStream;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletRequestWrapper;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.util.LinkedHashMap;
import java.util.Map;

/**
 * XSS过滤处理
 *
 * @author Mark sunlightcs@gmail.com
 */
public class XssHttpServletRequestWrapper extends HttpServletRequestWrapper {
    //没被包装过的HttpServletRequest（特殊场景，需要自己过滤）
    HttpServletRequest orgRequest;
    //html过滤
    private final static HTMLFilter htmlFilter = new HTMLFilter();

    public XssHttpServletRequestWrapper(HttpServletRequest request) {
        super(request);
        orgRequest = request;
    }

    @Override
    public ServletInputStream getInputStream() throws IOException {
        //非json类型，直接返回
        if(!MediaType.APPLICATION_JSON_VALUE.equalsIgnoreCase(super.getHeader(HttpHeaders.CONTENT_TYPE))){
            return super.getInputStream();
        }

        //为空，直接返回
        String json = IOUtils.toString(super.getInputStream(), "utf-8");
        if (StringUtils.isBlank(json)) {
            return super.getInputStream();
        }

        //xss过滤
        json = xssEncode(json);
        final ByteArrayInputStream bis = new ByteArrayInputStream(json.getBytes("utf-8"));
        return new ServletInputStream() {
            @Override
            public boolean isFinished() {
                return true;
            }

            @Override
            public boolean isReady() {
                return true;
            }

            @Override
            public void setReadListener(ReadListener readListener) {

            }

            @Override
            public int read() throws IOException {
                return bis.read();
            }
        };
    }

    @Override
    public String getParameter(String name) {
        String value = super.getParameter(xssEncode(name));
        if (StringUtils.isNotBlank(value)) {
            value = xssEncode(value);
        }
        return value;
    }

    @Override
    public String[] getParameterValues(String name) {
        String[] parameters = super.getParameterValues(name);
        if (parameters == null || parameters.length == 0) {
            return null;
        }

        for (int i = 0; i < parameters.length; i++) {
            parameters[i] = xssEncode(parameters[i]);
        }
        return parameters;
    }

    @Override
    public Map<String,String[]> getParameterMap() {
        Map<String,String[]> map = new LinkedHashMap<>();
        Map<String,String[]> parameters = super.getParameterMap();
        for (String key : parameters.keySet()) {
            String[] values = parameters.get(key);
            for (int i = 0; i < values.length; i++) {
                values[i] = xssEncode(values[i]);
            }
            map.put(key, values);
        }
        return map;
    }

    @Override
    public String getHeader(String name) {
        String value = super.getHeader(xssEncode(name));
        if (StringUtils.isNotBlank(value)) {
            value = xssEncode(value);
        }
        return value;
    }

    private String xssEncode(String input) {
        return htmlFilter.filter(input);
    }

    /**
     * 获取最原始的request
     */
    public HttpServletRequest getOrgRequest() {
        return orgRequest;
    }

    /**
     * 获取最原始的request
     */
    public static HttpServletRequest getOrgRequest(HttpServletRequest request) {
        if (request instanceof XssHttpServletRequestWrapper) {
            return ((XssHttpServletRequestWrapper) request).getOrgRequest();
        }

        return request;
    }

}

```



#### 3、引入的版本太高导致报错`UnsupportedClassVersionError`

当前使用的jdk版本是1.8

在pom文件中引入如下内容

```xml
<properties>
    <java.version>1.8</java.version>
    <spring-cloud.version>2023.0.0</spring-cloud.version>
</properties>

<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-dependencies</artifactId>
            <version>${spring-cloud.version}</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
```

运行报错

![image-20240108203516391](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240108203516391.png)

解决方法降低对应依赖版本即可



#### 4、通过mybatis插入数据报错

![image-20240108204207057](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240108204207057.png)

![image-20240108204202232](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240108204202232.png)

```yml
spring:
  # 配置数据源相关信息
  datasource:
    username: root
    password: root
    url: jdbc:mysql://192.168.56.10:3306/tts_pms
    driver-class-name: com.mysql.cj.jdbc.Driver
```

结果是url写错了，直接写的是`jdbc:mysql//192.168.56.10:3306/tts_pms`

#### 5、数据源配置url中的useUnicode=true 和 characterEncoding=utf8的区别

`useUnicode=true`和`characterEncoding=utf8`都是用于解决MySQL数据库在处理数据时可能出现的字符编码问题，但它们的作用有所不同。

`useUnicode=true`参数表示要使用Unicode字符集来处理数据，这对于支持多语言的应用程序非常重要。当`useUnicode=true`时，JDBC驱动程序将会把所有的字符串编码为Unicode形式进行传输。这个参数只是告诉JDBC是否使用Unicode编码，但并没有指定具体的字符集。

`characterEncoding=utf8`参数则用于指定MySQL数据库连接时使用的字符编码为UTF-8。这个参数告诉JDBC使用UTF-8字符集来处理数据，这样就可以正确地保存和读取UTF-8编码的数据了。



如果只使用`characterEncoding=utf8`而不使用`useUnicode=true`，可能会导致以下问题：

1. 数据存储问题：当插入或查询包含非ASCII字符（如中文、日文、俄文等）的数据时，如果没有设置`useUnicode=true`，MySQL数据库将会把这些字符当作默认编码处理，比如Latin1。这样可能导致字符被截断或转换成乱码。
2. 查询结果问题：如果数据库中存储的是UTF-8编码的数据，但连接字符串中未指定`useUnicode=true`，则在查询结果返回时，这些UTF-8编码的数据可能会以错误的编码显示，导致乱码。

举例来说，假设有一个包含中文数据的表格，存储使用UTF-8编码。如果连接字符串中只指定了`characterEncoding=utf8`而没有使用`useUnicode=true`，那么在查询结果中，这些中文字符可能会以错误的编码显示，例如变成乱码或者显示为其他字符。

因此，为了正确处理和显示包含非ASCII字符的数据，建议同时使用`characterEncoding=utf8`和`useUnicode=true`。这样可以确保数据库连接以UTF-8编码进行处理，并正确地存储和读取包含ASCII字符的数据。



在MySQL中，`useUnicode`参数的默认值是`true`。这意味着，默认情况下，MySQL的JDBC驱动程序会使用Unicode字符集来处理数据。

因此，如果在数据源连接的URL中没有显式地设置`useUnicode`参数，那么它将默认为`true`，即使用Unicode字符集来处理数据。这是为了确保能够正确处理多语言字符，避免出现乱码或无法处理特殊字符的情况。

配置数据源示例：

```yml
spring:
  # 配置数据源相关信息
  datasource:
    username: root
    password: root
    url: jdbc:mysql://192.168.56.10:3306/tts_pms?&useUnicode=true&characterEncoding=utf8
    driver-class-name: com.mysql.cj.jdbc.Driver
```

例如：mysql数据库用的是gbk编码，而项目数据库用的是utf-8编码。这时候如果添加了useUnicode=true&characterEncoding=UTF-8 ，那么作用有如下两个方面：

1、存数据时：

数据库在存放项目数据的时候会先用UTF-8格式将数据解码成字节码，然后再将解码后的字节码重新使用GBK编码存放到数据库中。

2、取数据时：

在从数据库中取数据的时候，数据库会先将数据库中的数据按GBK格式解码成字节码，然后再将解码后的字节码重新按UTF-8格式编码数据，最后再将数据返回给客户端。



#### 6、nacos数据持久化配置（mysql数据库）

##### 6.1、nacos客户端保存数据的默认方式

当我们启动nacos后，会在当前客户端所在目录生成两个文件`data	`和`logs`

![image-20240123224335199](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240123224335199.png)

① `data`文件夹

说明：`data` 文件夹用于存储 Nacos 客户端的数据，其中的数据是通过 RocksDB 存储的。RocksDB 是一个基于 LSM 树的高性能、持久化键值存储引擎，支持快速的写入和查询操作，并且具有较高的可靠性和可扩展性，是 Nacos 客户端选择 RocksDB 作为数据存储的主要原因。

其具体包含内容如下：

- `naming` 目录：存储服务注册和发现相关的数据，包括注册的服务实例信息、订阅的服务等。
- `config` 目录：存储配置管理相关的数据，包括配置信息和对应的监听器信息。



②`logs`文件夹

说明：`log` 文件夹用于存储 Nacos 客户端的日志文件。

具体包含以下内容：

- `nacos.log` 日志文件：记录 Nacos 客户端的运行日志，包括启动日志、错误日志等。
- 其他日志文件：根据 Nacos 客户端的配置，可能还会生成其他的日志文件，用于记录特定模块或功能的日志。

##### 6.2、nacos的数据持久化（mysql数据库）

**6.2.1、 问题引出：**对于上述`nacos`自带的数据持久化方式，可能会出现不小心将`data`目录删除后，相关内容丢失的情况，因此我们考虑将`nacos`中的数据持久化操作化放到数据库中。并且我们可以发现`nacos`是用`java`语言编写的，并且基于 `Spring Boot` 框架开发，其提供了一些启动脚本，如 `startup.cmd`（Windows 系统）和 `startup.sh`（`Unix/Linux 系统`）来帮助快速启动`nacos`服务端和客户端。

![image-20240123230010759](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240123230010759.png)

并且我们可以在conf目录下，能够看到对应的`spring`的配置文件`application.properties`

![image-20240123230119031](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240123230119031.png)

**6.2.2、具体构建方式**

①构建`nacos`相关数据表

通过`Nacos`目录中`conf/nacos-masql.sql`文件创建响应的数据表

![image-20240123230452566](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240123230452566.png)

![image-20240123230802976](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240123230802976.png)

2、在`Nacos `的 `conf/application.properties` 文件中配置响应的`mysql`数据源

```
spring.datasource.platform=mysql
db.num=1
db.url.0=jdbc:mysql://192.168.56.10:3306/tts_nacos?characterEncoding=utf8&connectTimeout=1000&socketTimeout=3000&autoReconnect=true
db.password=root
```

3、启动`nacos`,创建相关配置，可以发现相关内容成功保存到数据表中

#### 7、`npm install`报错

**参考文章：**

```
https://blog.csdn.net/u014708644/article/details/127946338
https://blog.csdn.net/zcyf0809/article/details/134843225
https://blog.csdn.net/Unclear_cat/article/details/135202617
```

**具体问题解决1：**

```
ChromeDriver installation failed Error with http request: {
date: 'Sat, 23 Dec 2023 09:33:08 GMT',
'content-type': 'text/html',
'content-length': '154',
connection: 'close',
location: ' 网页链接;,
'strict-transport-security': 'max-age=15768000',
via: 'npmmirror.com-03'
} 
```

从报错信息可以看出，下载chromedriver失败了，这时更换数据源就可以了

说什么ChromeDriver被墙了！

①通过如下地址，直接下载一个chromedriver_win32.zip

```
https://cdn.npmmirror.com/binaries/chromedriver/2.27/chromedriver_win32.zip
```

②首先将所有下载的依赖都删掉，即删掉项目中的 **node_modules** [文件夹](https://so.csdn.net/so/search?q=文件夹&spm=1001.2101.3001.7020)

③根据自己的下载`chromedriver_win32.zip`地址，安装依赖

```
npm install chromedriver --chromedriver_filepath=文件地址
```

④执行npm依赖安装





**具体问题解决2：**

![image-20240307133949458](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240307133949458.png)

文章：

```
https://blog.csdn.net/qq_22182989/article/details/125445485
```

解决

```
npm install --save  --force --legacy-peer-deps
```

1. `--save`:
   - 在早期版本的 npm 中，`--save` 参数用于将安装的包信息保存到 `package.json` 文件的 `dependencies` 部分。从 npm 5 开始，安装包时会自动将其保存到 `package.json` 中，所以 `--save` 参数已经不再需要，但仍然可以使用作为兼容性考虑。
2. `--force`:
   - `--force` 参数用于强制安装依赖包，即使该包已经存在于 `node_modules` 目录中。这可能会覆盖现有的包，潜在地引起冲突或问题，所以需要谨慎使用。
3. `--legacy-peer-deps`:
   - `--legacy-peer-deps` 参数是在 npm 7 中引入的。它用于启用 "legacy" 模式来处理 peer dependencies（对等依赖），即使这可能导致一些依赖关系不符合新的规则。这个参数在遇到 peer dependencies 不兼容或报错时可以尝试使用，但应谨慎考虑。

#### 8、人人开源后台管理系统io.renren.common.exception.RRException: 获取定时任务CronTrigger出现异常

解决：删除数据库里面表名含有qrtz的表的所有数据，删除schedule_job表中所有数据。



#### 9、后台关系系统请求报错

报错内容：

```
org.apache.ibatis.binding.BindingException: Invalid bound statement (not found): com.yjy.tts.manage.modules.sys.dao.SysUserDao.queryByUserName
	at org.apache.ibatis.binding.MapperMethod$SqlCommand.<init>(MapperMethod.java:235)
	at com.baomidou.mybatisplus.core.override.MybatisMapperMethod.<init>(MybatisMapperMethod.java:50)
	at com.baomidou.mybatisplus.core.override.MybatisMapperProxy.lambda$cachedMapperMethod$0(MybatisMapperProxy.java:101)
	at java.util.concurrent.ConcurrentHashMap.computeIfAbsent(ConcurrentHashMap.java:1660)
	at com.baomidou.mybatisplus.core.override.MybatisMapperProxy.cachedMapperMethod(MybatisMapperProxy.java:100)
	at com.baomidou.mybatisplus.core.override.MybatisMapperProxy.invoke(MybatisMapperProxy.java:95)
	at com.sun.proxy.$Proxy88.queryByUserName(Unknown Source)
	at com.yjy.tts.manage.modules.sys.service.impl.SysUserServiceImpl.queryByUserName(SysUserServiceImpl.java:75)
	at com.yjy.tts.manage.modules.sys.service.impl.SysUserServiceImpl$$FastClassBySpringCGLIB$$519a220f.invoke(<
```

原因分析和解决：

xml中的namespace没有和package报名一一对应

![image-20240127145053769](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240127145053769.png)

#### 10、VSCODE快速生成vue模板

文件-->首选项-->用户代码片段-->点击新建代码片段--取名 vue.json 确定

```json
{
    "生成 vue 模板": {
    "prefix": "vue",
    "body": [
        "<template>",
        "<div></div>",
        "</template>",
        "",
        "<script>",
        "//这里可以导入其他文件（比如：组件，工具 js，第三方插件 js，json
        文件，图片文件等等）",
        "//例如：import 《组件名称》 from '《组件路径》';",
        "",
        "export default {",
        "//import 引入的组件需要注入到对象中才能使用",
        "components: {},",
        "props: {},",
        "data() {",
        "//这里存放数据",
        "return {",
        "",
        "};",
        "},",
        "//计算属性 类似于 data 概念",
        "computed: {},",
        "//监控 data 中的数据变化",
        "watch: {},",
        "//方法集合",
        "methods: {",
        "",
        "},",
        "//生命周期 - 创建完成（可以访问当前 this 实例）",
        "created() {",
        "",
        "},",
        "//生命周期 - 挂载完成（可以访问 DOM 元素）",
        "mounted() {",
        "",
        "},",
        "beforeCreate() {}, //生命周期 - 创建之前",
        "beforeMount() {}, //生命周期 - 挂载之前",
        "beforeUpdate() {}, //生命周期 - 更新之前",
        "updated() {}, //生命周期 - 更新之后",
        "beforeDestroy() {}, //生命周期 - 销毁之前",
        "destroyed() {}, //生命周期 - 销毁完成",
        "activated() {}, //如果页面有 keep-alive 缓存功能，这个函数会触发
        ",
        "}",
        "</script>",
        "<style lang='scss' scoped>",
        "//@import url($3); 引入公共 css 类",
        "$4",
        "</style>"
    ],
    	"description": "生成 vue 模板"
    }
}
```



#### 11、跨域问题

为什么我们在这个项目中，不需要进行跨域配置呢？（△，不清楚）

那是因为我们引入的网关依赖，已经帮我们做好了跨域相关的配置

引入依赖：

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-gateway</artifactId>
</dependency>
```

跨域配置：

![image-20240213224706292](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240213224706292.png)

但是查看了，没有默认的跨域配置



于是把后台系统项目中的跨域给注释掉，结果跨域就失败了

因此其跨域是后台管理系统提供的

​	![image-20240213232203243](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240213232203243.png)

![image-20240213232110433](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240213232110433.png)



#### 12、Eslint相关校验关闭

文章：

```
https://blog.csdn.net/qq_34645412/article/details/78974413
```



#### 13、es查询价格区间有问题

原因是es中的结构

skuPrice是keyword

应该是long类型

```
PUT /tts_product
{
  "mappings": {
    "properties": {
      "skuId": {
        "type": "long"
      },
      "spuId": {
        "type": "long"
      },
      "skuTitle": {
        "type": "text",
        "analyzer": "ik_smart"
      },
      "skuPrice": {
        "type": "long"
      },
      "skuImg": {
        "type": "keyword"
      },
      "saleCount": {
        "type": "long"
      },
      "hosStock": {
        "type": "boolean"
      },
      "hotScore": {
        "type": "long"
      },
      "brandId": {
        "type": "long"
      },
      "catalogId": {
        "type": "long"
      },
      "brandName": {
        "type": "keyword"
      },
      "brandImg": {
        "type": "keyword"
      },
      "catalogName": {
        "type": "keyword"
      },
      "attrs": {
        "type": "nested",
        "properties": {
          "attrId": {
            "type": "long"
          },
          "attrName": {
            "type": "keyword"
          },
          "attrValue": {
            "type": "keyword"
          }
        }
      }
    }
  }
}
```



### II、后端

#### 1、关于springboot与springcloud版本不一致导致运行出错问题

**原由：**

当前项目springboot的版本`2.6.6`

在一个项目中引入`spring-cloud-alibaba`后，版本为`2.2.0.RELEASE`

**报错信息：**

```
org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'configurationPropertiesBeans' defined in class path resource [org/springframework/cloud/autoconfigure/ConfigurationPropertiesRebinderAutoConfiguration.class]: Post-processing of merged bean definition failed; nested exception is java.lang.IllegalStateException: Failed to introspect Class [org.springframework.cloud.context.properties.ConfigurationPropertiesBeans] from ClassLoader [sun.misc.Launcher$AppClassLoader@18b4aac2]
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:597)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:542)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:335)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:333)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:213)
	at org.springframework.context.support.PostProcessorRegistrationDelegate.registerBeanPostProcessors(PostProcessorRegistrationDelegate.java:270)
```

**原因：**springboot与springcloud版本不一致

**springboot与springcloud版本匹配关系：**

我们在springcloud的[官方文档](https://spring.io/projects/spring-cloud)中看到和springboot和springcloud的版本匹配关系

![image-20240127221807877](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240127221807877.png)



**注意：**

我是通过降低后台管理系统springboot的版本2.6.6 -> 2.1.8.RELEASE

同时导致了某一个类中的相关内容不可用，进行了修改（实际上结果是一样的）

```java
@Configuration
public class CorsConfig implements WebMvcConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**")
            //如果没有配置该项，Spring Boot 默认会将其设置为 "*"，即允许所有来源进行跨域访问
            /*.allowedOriginPatterns("*")*/
            .allowCredentials(true)
            .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS")
            .maxAge(3600);
    }
}
```

#### 2、多配置无法进入

原写法：

```
spring.cloud.nacos.config.extension-configs[1].data-id=mybatis.yml
spring.cloud.nacos.config.extension-configs[1].group=dev
spring.cloud.nacos.config.extension-configs[1].refresh=true
```

修改成：

```
spring.cloud.nacos.config.ext-config[0].data-id=datasource.yml
spring.cloud.nacos.config.ext-config[0].group=dev
spring.cloud.nacos.config.ext-config[0].refresh=true
```

原因：

Spring Cloud Alibaba 中Nacos配置中心在2.2.1.RELEASE版本中过时的问题，spring.cloud.[nacos](https://so.csdn.net/so/search?q=nacos&spm=1001.2101.3001.7020).config.ext-config[0]已过时
替换为：spring.cloud.nacos.config.extension-configs[0]



#### 3、Rebase Current onto Selected

作用：将从主分支切除去的分支同步最新的主分支更新内容。

具体情况：

当前git情况

![image-20240214213651577](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240214213651577.png)

此时想要B1分支的内容同步A3的内容，就可以切到B1分支，然后RebaseCurrent onto Selected A分支

结果如下图所示，B2的内容就是B1的内容

![image-20240214213806217](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240214213806217.png)

#### 4、后端项目启动报错`cloud.nacos.NacosConfigProperties`的`create config service error`

##### 4.1、报错日志内容：

```
2024-02-24 13:46:03.756 ERROR 16376 --- [           main] c.a.cloud.nacos.NacosConfigProperties    : create config service error!properties=NacosConfigProperties{serverAddr='null', encode='null', group='DEFAULT_GROUP', prefix='null', fileExtension='properties', timeout=3000, endpoint='null', namespace='null', accessKey='null', secretKey='null', contextPath='null', clusterName='null', name='null', sharedDataids='null', refreshableDataids='null', extConfig=null},e=,

com.alibaba.nacos.api.exception.NacosException: java.lang.reflect.InvocationTargetException
	at com.alibaba.nacos.api.config.ConfigFactory.createConfigService(ConfigFactory.java:45) ~[nacos-api-1.1.1.jar:na]
	at com.alibaba.nacos.api.NacosFactory.createConfigService(NacosFactory.java:43) ~[nacos-api-1.1.1.jar:na]
	at com.alibaba.cloud.nacos.NacosConfigProperties.configServiceInstance(NacosConfigProperties.java:346) ~[spring-cloud-alibaba-nacos-config-2.1.0.RELEASE.jar:2.1.0.RELEASE]
	at com.alibaba.cloud.nacos.NacosConfigAutoConfiguration.nacosContextRefresher(NacosConfigAutoConfiguration.java:64) [spring-cloud-alibaba-nacos-config-2.1.0.RELEASE.jar:2.1.0.RELEASE]
	at com.alibaba.cloud.nacos.NacosConfigAutoConfiguration$$EnhancerBySpringCGLIB$$ffaf5f9f.CGLIB$nacosContextRefresher$3(<generated>) [spring-cloud-alibaba-nacos-config-2.1.0.RELEASE.jar:2.1.0.RELEASE]
	at com.alibaba.cloud.nacos.NacosConfigAutoConfiguration$$EnhancerBySpringCGLIB$$ffaf5f9f$$FastClassBySpringCGLIB$$328edbb9.invoke(<generated>) [spring-cloud-alibaba-nacos-config-2.1.0.RELEASE.jar:2.1.0.RELEASE]
```

##### 4.2、原因分析

在项目中引入了一个通用的依赖

```xml
<!--tts基础服务-->
<dependency>
    <groupId>com.yjy.tts</groupId>
    <artifactId>tts-common</artifactId>
    <version>0.0.1-SNAPSHOT</version>
</dependency>
```

在`tts-common`中引入了依赖

```xml
<!--nacos 配置中心依赖-->
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
</dependency>
```

这是由于配置springboot配置文件中，没有配置[nacos](https://so.csdn.net/so/search?q=nacos&spm=1001.2101.3001.7020)配置中心地址、端口导致的。

新建一个配置文件bootstrap.[properties](https://so.csdn.net/so/search?q=properties&spm=1001.2101.3001.7020),输入如下内容， 问题解决：

```
spring.application.name=tinymall-product
spring.cloud.nacos.config.server-addr=127.0.0.1:8848
```

该依赖不是一个普通的API库，而是一个springboot starter, 所以在springboot启动时，会去找相应的配置，如果找不到，就会报错。



#### 5、关于自动配置

可以参考文章：

```
https://blog.csdn.net/zhangjunli/article/details/131053305
```

那么在 Spring Boot 项目中，如果被 Spring 容器管理的 bean 不在 Spring Boot 包扫描路径下，怎么办？

解决 Spring Boot 中不能被默认路径扫描的配置类的方式，有 2 种：

（1）在 Spring Boot 主类上使用 @Import 注解

（2）使用 spring.factories 文件

使用spring.factories进行自动装配的示例：

![image-20240227185630191](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240227185630191.png)

```
# Auto Configure
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
com.yjy.common.exception.GlobalBizExceptionHandler

```

然后在其他项目中依赖`tts-common`，即可自动注册`GlobalBizExceptionHandler`的bean对象，并进行使用。

#### 6、解决自定义校验异常信息乱码问题

![image-20240227212649035](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240227212649035.png)

删除原来的配置文件

![image-20240227212709536](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240227212709536.png)

修改前：

![image-20240227212826353](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240227212826353.png)

修改后：

![image-20240227212848317](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240227212848317.png)

重新创建配置文件

![image-20240227213006335](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240227213006335.png)



再次查看

![image-20240227213033471](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240227213033471.png)



#### 7、Object划分

1.PO（persistant Object）持久对象

PO就是对应数据库中某个表中的一条记录（数据），多个记录可以用PO的集合。PO中应该不包含任何对数据库的操作。



2.DO（Domain Object）领域对象

就是从现实世界中抽象出来的有形或无形的业务实体。



3.TO（Transfer Object）数据传输对象

不同的应用程序之间传输的对象。

例如：远程接口之间调用时，传输发送出去的对象，就可以使用数据传输对象（TO）



4.DTO（Data Transfer Object）数据传输对象

这个概念来源于J2EE的设计模式，原来的目的是为了EJB的分布式应用提供粗粒度的数据实体，以减少分布式调用的次数，从而提高分布式调用的性能和降低网络负载，但在这里，泛指用于展示层与服务层之间的数据传输对象。

例如：DTO通常用于在不同层之间传递数据，如在服务层和控制器层之间，或者在服务层和持久层之间。



5.VO（value object）值对象

通常用于业务层之间的数据传递，和po一样也是仅仅包含数据而已。但应是抽象出的业务对象，可以和表对象，也可以不，这根据业务的需要，用new关键字创建，由GC回收



VO也称为view object：视图对象

- 接受页面传递来的数据，封装对象

- 将业务处理完成的独享，封装成页面要用的数据

（因为如果全部将一些注解标注在实体类Entity上，会很乱，比如说校验注解@NotEmpty等）



6.Bo（business object） 业务对象呢

从业务模型的角度看，见UML原件领域模型中的领域对象。封装业务逻辑的java对象，通过调用DAO方法，结合PO,VO进行业务操作。

business object:业务对象，主要欧勇是吧业务逻辑封装为一个对象。这个对象可以包括一个或多个其他对象。比如一个简历中，有教育经历、工作经历、社会关系等等。我们可以把教育经历对应一个PO，工作经验对应一个PO，社会关系对应一个po，建立一个对应建立的bo对象处理建立，每个bo包含这些po，这样处理业务逻辑时，我们就可以针对bo去进行处理。



7.POJO（plain ordinary java object）简单无规则java对象

传统意义上的java对象



8.DAO(data access object) 数据访问对象



#### 8、关于远程调用数据传输对象的说明

**示例：**

远程调用方法

```java
@FeignClient("tts-coupon")
public interface CouponFeignService {

    /**
     * 保存spu的积分信息远程调用接口
     * @param spuBoundTo spu的积分传输对象
     * @return
     */
    @PostMapping("/coupon/spubounds/save")
    R saveSpuBounds(@RequestBody SpuBoundTo spuBoundTo);
}
```

调用服务的方法

```java
/**
 * 保存
 */
@RequestMapping("/save")
public R save(@RequestBody SpuBoundsEntity spuBounds){
    spuBoundsService.save(spuBounds);
    return R.ok();
}
```

**说明：**

- 首先在进行远程调用的时候，@RequestBody会将这个对象转为json
- 找到对应服务tts-coupon，给发送对应的请求/coupon/spubounds/save，将上一步转到json放在请求体位置，发送请求
- tts-coupon服务收到请求，请求体里有json数据，将json数据转化为SpuBoundsEntity

（只要json数据模型是兼容的，双方服务无须使用同一个vo）



#### 9、设置项目启动和内存配置

![image-20240308105740883](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240308105740883.png)

![image-20240308105842362](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240308105842362.png)

![image-20240308110008192](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240308110008192.png)

设置 JVM 运行时的最大堆内存大小

![image-20240308110152107](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240308110152107.png)



#### 8、设置通过XShell进行连接虚拟机

因为我们是通过vagrant创建的虚拟机，因此其默认没有给我们开启root权限和密码登录功能。

8.1、设置密码登录模式

`vagrant ssh`登录到系统中后，进入到配置文件中

```
vi /etc/ssh/sshd_config
修改 PasswordAuthentication 为yes（原no）
然后重启服务 service sshd restart
```

![image-20240310133534057](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240310133534057.png)

![image-20240310133702638](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240310133702638.png)



8.2、使用xshell连接虚拟机

![image-20240310133825723](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240310133825723.png)

账号密码：root/vagrant

![image-20240310133904359](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240310133904359.png)



#### 9、扩展虚拟机的内存

通过命令查看内存分配情况

```
free -m
```

![image-20240310141609555](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240310141609555.png)

直接在virtualBox中进行配置

首先关闭对应的虚拟机

![image-20240310141705066](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240310141705066.png)

![image-20240310141733096](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240310141733096.png)

重启虚拟机

查看内存信息

![image-20240310141958536](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240310141958536.png)



### III、前端

#### 1、关于ES6export与export default详解

1.1、参考文章

```
https://blog.csdn.net/weixin_56650035/article/details/118879642
```

1.2、作用

export和export default是用来导出常量、函数、文件、模块的。是ES6语言

1.3、具体使用

export：

设置变量，然后使用export导出

```
//--------------第一种方式：定义变量与导出分开------------------------------
var one = "export导出"
var two=["AAA","BBB","CCC"]
export { one, two }
//--------------导出与定义变量直接一起写--------------------------------
export var three="直接导出"
```

在使用该变量的地方引入

```
import {one,two,three} from "../js/test.js"
//打印
console.log(one+","+two+","+three);
```

运行结果：

```
export导出,AAA,BBB,CCC,直接导出
```



export default：

说明：其实export default和export的功能是一样的，但是一个文件里面只能有一个export default语句。
export default是把所有{}中所有的内容都赋值给default，然后当我们导入的时候也可以改变名称，但是其实是把所有的default导入了。

先设置需要导出的数据：

```
var onePart="导出1"
var twoPart="导出2"
var threePart=[
  {
    name:"第一个",
    type:"数组1"
  },
  {
    name:"第二个",
    type:"数组2"
  }
]
export default{
  onePart,twoPart,threePart
}
```

导入数据：

```
//导入数据
import all from "../js/test.js"
//打印数据
console.log(all)
```

显示的结果：

![在这里插入图片描述](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/20200704145706400.png)



1.4、特点

export：

- 导出时需要和导入的变量名称相同
- 如果导出和定义变量分开，导出时变量名加{}
- 导入的时候变量名必须加{}
- 可以有多个export语句

export default：

引入时，可以变成不同的名称
直接把所有内容都导出
引入时，设置的变量名不用加{}
只能有一个export default语句



#### 2、Vue单文件组件

Vue 单文件组件是一种将一个 Vue 组件的模板、样式和逻辑代码封装在一个单独的文件中的方式。这个文件通常以 `.vue` 扩展名为后缀，可以通过构建工具（如 webpack）的打包功能将其编译成可在浏览器中使用的 JavaScript 文件。

Vue 单文件组件由三个部分组成：`<template>`、`<script>` 和 `<style>`。

- `<template>`：定义了组件的模板部分，包含了 HTML 代码和 Vue 的模板语法。
- `<script>`：定义了组件的 JavaScript 部分，包含了组件的选项对象（如 `data`、`methods` 等属性）。
- `<style>`：定义了组件的样式部分，可以使用 CSS、SCSS、LESS 等样式预处理器。

这种组织方式让组件的结构更加清晰，易于维护和扩展。同时，由于每个 Vue 单文件组件都是一个独立的模块，因此可以方便地组合和复用不同的组件。

简单的 Vue 单文件组件的示例：

```vue
<template>
  <div>
    <h2>{{ title }}</h2>
    <p>{{ message }}</p>
  </div>
</template>

<script>
export default {
  data() {
    return {
      title: 'Hello, Vue!',
      message: 'Welcome to Vue.js!'
    }
  }
}
</script>

<style>
h2 {
  color: red;
}
p {
  font-size: 16px;
}
</style>

```

这个单文件组件可以在其他 Vue 应用程序中使用，只需要将其导入并注册为一个组件即可：

```vue
<template>
  <div>
    <my-component></my-component>
  </div>
</template>

<script>
import MyComponent from './MyComponent.vue'

export default {
  components: {
    'my-component': MyComponent
  }
}
</script>

```



#### 3、Vue实例

复习一下，`Vue`实例的创建方式和内容

```html
<body>
    <div id = "app">
        <h1>
            {{name}},非常好看！
        </h1>
    </div>
    
    <!--vue.min.js是Vue.js的压缩版本，用于生产环境的部署-->
    <script src="./node_modules/vue/dist/vue.min.js"></script>
    <script>
        /**
        	通过new Vue()来创建Vue实例
        	构建函数接受一个对象，对象中有一些属性和值（属性不用双引号包围，值如果是字符串类型需要使用字符串类型）
        **/
    	let vm = new Vue({
            el:"#app",	//通过 id 选中要渲染的页面元素，本例中是一个 div
            data:{		//数据，数据是一个对象，里面有很多属性，都可以渲染到视图中
				name:"张三"
            },
            methods: { // 方法
                increment: function() {
                  this.count++;
                }
          	},
          computed: { // 计算属性
            reversedMessage: function() {
              return this.message.split('').reverse().join('');
            }
          },
          watch: { // 监听
            count: function(newValue, oldValue) {
              console.log('count changed from ' + oldValue + ' to ' + newValue);
            }
          },
          mounted: function() { // 生命周期钩子
            console.log('mounted');
          }
        });
    </script>
    
</body>
```



#### 4、Vue组件化

**4.1、前言**

在大型应用开发的时候，页面可以划分成很多部分。往往不同的页面，也会有相同的部分。

例如可能会有相同的头部导航。

但是如果每个页面都独自开发，这无疑增加了我们开发的成本。所以我们会把页面的不同部

分拆分成独立的组件，然后在不同页面就可以共享这些组件，避免重复开发，实现一个共用。

![image-20240212162222674](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240212162222674.png)



**4.2、实现**

最原始的Vue实例方式：

```html
<head>
</head>

<bdoy>
	<div id = "app">
        <button v-on:click="count++">
       		我被点击了{{count}}次
        </button>
    </div>
    
     <!--vue.min.js是Vue.js的压缩版本，用于生产环境的部署-->
    <script src="./node_modules/vue/dist/vue.min.js"></script>
    <script>
    	new Vue(){
            el:"app",
            data:{
                count:1
            }
        }
    </script>
    
</bdoy>
```



实现方式总共可以分为以下三类：

①全局声明的方式

```html
<head>
</head>

<bdoy>
	<div id = "app">
        <button v-on:click="count++">
       		我被点击了{{count}}次
        </button>
        
        <!--组件的使用：直接用声明时候的名字的标签即可-->
        <!--定义好的组件，可以任意复用多次-->
        <counter></counter>
        <counter></counter>
    </div>
    
     <!--vue.min.js是Vue.js的压缩版本，用于生产环境的部署-->
    <script src="./node_modules/vue/dist/vue.min.js"></script>
    <script>
        //1.全局声明注册一个组件
        //能在vue组件中写的东西，都可以在模板中写，唯一和vue实例不同的是：
        //vue实例是通过el挂载页面元素（无法复用）
        //组件是通过template声明组件的模板（可以复用）
        Vue.component("counter",{
        	//模板
            template:"<button v-on:click="count++">我被点击了{{count}}次</button>"，
        	data(){
        		return{
                    count:1
                }
        	}
        }
            
        })
        
        
    	new Vue(){
            el:"app",
            data:{
                count:1
            }
        }
    </script>
    
</bdoy>
```

补充说明：

- 组件其实也是一个 Vue 实例，因此它在定义时也会接收：data、methods、生命周期函数等
- 不同的是组件不会与页面的元素绑定，否则就无法复用了，因此没有 el 属性。
- 但是组件渲染需要 html 模板，所以增加了 template 属性，值就是 HTML 模板
- 全局组件定义完毕，任何 vue 实例都可以直接在 HTML 中通过组件名称来使用组件了
- data 必须是一个函数，不再是一个对象。



②局部声明

```html
<head>
</head>

<bdoy>
	<div id = "app">
        <button v-on:click="count++">
       		我被点击了{{count}}次
        </button>
        
        
        <!--使用局部组件:直接用局部组件的名称-->
        <button-counter></button-counter>
    </div>
    
     <!--vue.min.js是Vue.js的压缩版本，用于生产环境的部署-->
    <script src="./node_modules/vue/dist/vue.min.js"></script>
    <script>
        //2.局部声明注册一个组件
        const buttonCounter = {
            template:"<button v-on:click="count++">我被点击了{{count}}次</button>"，
        	data(){
        		return{
                    count:1
                }
        	}
        };
            
    	new Vue(){
            el:"app",
            data:{
                count:1
            },
            //用来指定该vue实例中需要用到的组件
            //执行方式为对象，内部为k-v，k是组件的名称，v是组件对象
            components:{
                'button-counter': buttonCounter
            }
              
        }
    </script>
    
</bdoy>
```

补充：

一旦全局注册，就意味着即便以后你不再使用这个组件，它依然会随着 Vue 的加载而加载。因此，对于一些并不频繁使用的组件，我们会采用局部注册。

- components 就是当前 vue 对象子组件集合。

  - 其 key 就是子组件名称

  - 其值就是组件对象名

- 效果与刚才的全局注册是类似的，不同的是，这个 counter 组件只能在当前的 Vue 实例使用



**4.3、一些问题的解答**

1.关于Vue实例和组件中的data一个声明的是对象一个声明的是函数式的问题

简单来说，就是组件是可以复用的，防止在复用的过程中，避免数据共享带来的问题，一个组件的 data 选项必须是一个函数，因此每个实例可以维护一份被返回对象的独立的拷贝；

否则：https://cn.vuejs.org/v2/guide/components.html#data-%E5%BF%85%E9%A1%BB%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0

在Vue组件中，可以使用对象形式来定义组件的`data`，也可以使用函数形式来定义。两种方式的区别在于，使用函数形式定义的`data`可以避免数据共享带来的问题。

当你使用对象形式定义`data`时，如果多个该组件的实例共享同一个对象，那么它们会共享相同的数据。这意味着，当一个实例修改了数据，其他实例也会受到影响。这通常不是我们所期望的行为。

而如果你使用函数形式来定义`data`，每个组件实例会返回一个独立的数据对象，从而避免了数据共享带来的问题。因此，推荐在组件中使用函数形式来定义`data`，以确保每个实例都拥有独立的数据。



#### 5、Vue生命周期和钩子函数

5.1、Vue生命周期（生命周期：一个项目从创建到结束的整个过程）

每个 Vue 实例在被创建时都要经过一系列的初始化过程 ：创建实例，装载模板，渲染模板等等。

生命周期：你不需要立马弄明白所有的东西。

![image-20240212170349315](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240212170349315.png)

5.2、钩子函数

Vue 为生命周期中的每个状态都设置了钩子函数（监听函数）。每当 Vue 实例处于不同的生命周期时，对应的函数就会被触发调用，可以帮助我们执行响应的操作。可以将所有的钩子函数都写在vue实例中。

- beforeCreated：我们在用 Vue 时都要进行实例化，因此，该函数就是在 Vue 实例化时调用，也可以将他理解为初始化函数比较方便一点，在 Vue1.0 时，这个函数的名字就是init。
- created：在创建实例之后进行调用。
- beforeMount：页面加载完成，没有渲染。如：此时页面还是{{name}} （即vue实例和页面模板进行挂载前）
- mounted：我们可以将他理解为原生 js 中的 window.onload=function({.,.}),或许大家也在用 jquery，所以也可以理解为 jquery 中的$(document).ready(function(){….})，他的功能就是：在 dom 文档渲染完毕之后将要执行的函数，该函数在 Vue1.0 版本中名字为
- compiled。 此时页面中的{{name}}已被渲染成张三
- beforeDestroy：该函数将在销毁实例前进行调用 。
- destroyed：改函数将在销毁实例时进行调用。
- beforeUpdate：组件更新之前。（当vue实例中的data数据更新，都会触发beforUpdate和updated，虚拟DOM重新渲染并应用更新）
- updated：组件更新之后。

```html
<body>
    <div id="app">
        <span id="num">{{num}}</span>
        <button v-on:click="num++">赞！</button>
        <h2>
            {{name}}，非常帅！！！有{{num}}个人点赞。
        </h2>
    </div>
</body>
<script src="../node_modules/vue/dist/vue.js"></script>
<script>
    let app = new Vue({
        el: "#app",
        data: {
            name: "张三",
            num: 100
        },
        methods: {
            show() {
                return this.name;
            },
            add() {
                this.num++;
            }
        },
        beforeCreate() {
            console.log("=========beforeCreate=============");
            console.log("数据模型未加载：" + this.name, this.num);
            console.log("方法未加载：" + this.show());
            console.log("html 模板未加载：
                        " + document.getElementById("num"));
                        },
        created: function () {
            console.log("=========created=============");
            console.log("数据模型已加载：" + this.name, this.num);
            console.log("方法已加载：" + this.show());
            console.log("html 模板已加载：
                        " + document.getElementById("num"));
                        console.log("html 模板未渲染：
                        " + document.getElementById("num").innerText);
                        },
        beforeMount() {
            console.log("=========beforeMount=============");
            console.log("html 模板未渲染：
                        " + document.getElementById("num").innerText);
                        },
        mounted() {
            console.log("=========mounted=============");
            console.log("html 模板已渲染：
                        " + document.getElementById("num").innerText);
                        },
        beforeUpdate() {
            console.log("=========beforeUpdate=============");
            console.log("数据模型已更新：" + this.num);
            console.log("html 模板未更新：
                        " + document.getElementById("num").innerText);
                        },
        updated() {
            console.log("=========updated=============");
            console.log("数据模型已更新：" + this.num);
            console.log("html 模板已更新：
                        " + document.getElementById("num").innerText);
                        }
    });
</script>
```

补充：

①关于页面加载和页面渲染

**页面加载**：指的是浏览器从服务器获取HTML、CSS、JavaScript等资源，并将这些资源下载到客户端，准备开始渲染页面的过程。页面加载包括以下几个阶段：

1. DNS解析：浏览器通过URL获取服务器的IP地址。
2. 建立TCP连接：浏览器与服务器建立TCP连接，发送HTTP请求。
3. 发送HTTP请求：浏览器向服务器发送请求，请求页面所需的HTML、CSS、JavaScript等资源。
4. 接收响应：服务器响应请求，将页面资源发送给浏览器。
5. 浏览器解析HTML：浏览器开始解析收到的HTML文档，构建DOM（文档对象模型）树。
6. 加载CSS和JavaScript：浏览器接收到CSS和JavaScript文件后开始加载并解析。

**页面渲染**：指的是浏览器根据接收到的HTML、CSS、JavaScript等资源，将页面内容展示给用户的过程。页面渲染包括以下几个阶段：

1. 构建DOM树：浏览器解析HTML文档，构建DOM树，表示页面的结构。
2. 构建CSSOM树：浏览器解析CSS文件，构建CSSOM树，表示页面的样式。
3. 合并DOM树和CSSOM树：将DOM树和CSSOM树合并，形成渲染树（Render Tree）。
4. 布局：根据渲染树计算每个节点在屏幕上的大小和位置。
5. 绘制：根据计算好的布局信息，将页面内容绘制到屏幕上。



#### 6、Vue的模块化开发

我们在开发过程中，可以和上面一样，引入`vue.js`文件，然后使用其中提供的语法功能，简化前端项目的开发。但是在多数情况下，我们通过Vue进行开发的时候，通常使用其模块化的开发环境进行开发。

**6.1、搭建一个Vue模块化开发环境**

①npm install webpack -g

全局（在命令行中安装即可，选择用户还是root都可以）安装webpack，用于项目的打包

![image-20240212185651310](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240212185651310.png)

②npm install -g @vue/cli-init

全局（在命令行中安装即可，选择用户还是root都可以）安装vue脚手架



③初始化vue项目

vue init webpack appname：vue 脚手架使用 webpack 模板初始化一个 appname 项目（需要联网）



④启动vue项目

项目的 package.json 中有 scripts，代表我们能运行的命令

- cd 到指定项目目录
- npm start = npm run dev：启动项目
- npm run build：将项目打包

**6.2、vue模块化开发项目的项目结构和运行流程**

1.项目结构

![image-20240212191015823](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240212191015823.png)



2.运行流程

就renrenfast的vue模块化开发项目进行说明

- 进入页面后，先加载index.html和main.js文件

首先看一下index.html,其实项目的主入口页面，head中引入的先不管，我们可以看到在body标签中只有一个div，并且id为app

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>人人快速开发平台</title>
  <% if (process.env.NODE_ENV === 'production') { %>
    <!-- 生产环境 -->
    <script>document.write('<script src="./config/index.js?t=' + new Date().getTime() + '"><\/script>');</script>
  <% }else { %>
    <!-- 开发环境 -->
    <link rel="shortcut icon" type="image/x-icon" href="./static/img/favicon.ico">
    <script src="./static/config/index.js"></script>
    <script src="./static/plugins/mock-1.0.0-beta3/mock-min.js"></script>
    <script src="./static/plugins/echarts-3.8.5/echarts.common.min.js"></script>
    <script src="./static/plugins/ueditor-1.4.3.3/ueditor.config.js"></script>
    <script src="./static/plugins/ueditor-1.4.3.3/ueditor.all.min.js"></script>
    <script src="./static/plugins/ueditor-1.4.3.3/lang/zh-cn/zh-cn.js"></script>
  <% } %>
</head>
<body>
  <div id="app"></div>
</body>
</html>
```

再是看一下main.js,其是整个项目的主程序，位于src目录下，其中创建了一个vue实例，挂载index.html中的app元素

```html
import Vue from 'vue'
import App from '@/App'
import router from '@/router'                 // api: https://github.com/vuejs/vue-router
import store from '@/store'                   // api: https://github.com/vuejs/vuex
import VueCookie from 'vue-cookie'            // api: https://github.com/alfhen/vue-cookie
import '@/element-ui'                         // api: https://github.com/ElemeFE/element
import '@/icons'                              // api: http://www.iconfont.cn/
import '@/element-ui-theme'
import '@/assets/scss/index.scss'
import httpRequest from '@/utils/httpRequest' // api: https://github.com/axios/axios
import { isAuth } from '@/utils'
import cloneDeep from 'lodash/cloneDeep'

Vue.use(VueCookie)
Vue.config.productionTip = false

// 非生产环境, 适配mockjs模拟数据                 // api: https://github.com/nuysoft/Mock
if (process.env.NODE_ENV !== 'production') {
  require('@/mock')
}

// 挂载全局
Vue.prototype.$http = httpRequest // ajax请求方法
Vue.prototype.isAuth = isAuth     // 权限方法

// 保存整站vuex本地储存初始状态
window.SITE_CONFIG['storeState'] = cloneDeep(store.state)

/* eslint-disable no-new */
new Vue({
  el: '#app',
  router,
  store,
  template: '<App/>',
  components: { App }
})

```

- `router`

使用了vue的路由，其全写形式是`router：router`，当属性名和属性值一样的时候，可以简写，指定了页面的跳转规则，router是从上面进行导入的`import router from '@/router' `，`@`符号在Vue项目中表示`src`目录，其是通过`export default router`将组件导出

- `template: '<App/>'`

其使用的模板是APP组件，通过`import App from '@/App'`导入

`template: '<App/>'`：这里定义了根组件的模板，即指定了根组件的渲染内容为 `<App/>`。在 Vue 中，根组件通常是包裹整个应用程序的最顶层组件，它负责渲染其他子组件，即当前主程序的vue实例中使用了这个app组件

- `components: { App }`

其全写形式是`components: { App ： APP }`

使用了一个组件叫app，其是通过`import App from '@/App'`导入进来的，其是一个单文件组件

```html
<template>
  <transition name="fade">
    <router-view></router-view>
  </transition>
</template>

<script>
  export default {
  }
</script>

```

- `<transition>` 标签：Vue 提供的过渡效果组件，可以用来在元素进入或离开 DOM 时添加动画效果。在这里，`name="fade"` 表示这个过渡效果的名称是 "fade"，具体的动画效果需要在 CSS 中定义。
- `<router-view>` 标签：这是 Vue Router 提供的用于显示匹配当前 URL 的组件的标签。当 URL 发生变化时，`<router-view>` 会根据当前 URL 匹配到的路由对应的组件来动态显示不同的组件内容。

在这个组件中，`<router-view>` 是位于 `<transition>` 标签中的，这意味着在切换路由时，匹配到的组件会在 `<transition>` 定义的过渡效果下进行显示



#### 7、导入element-ui快速开发

**7.1、`element-ui`作用**

`element-ui`的作用就是方便前端项目的快速开发

**7.2、步骤**

①通过npm安装，能够更好地和webpack打包工具配合使用

```vue
nppm i elment-ui -s
```

②在主程序`main.js`中导入`element-ui`和其`css样式`

```vue
import ElementUI from 'element-ui' 
import 'element-ui/lib/theme-chalk/index.css'
```

③让`Vue`使用该`element-ui`插件

`Vue.use()` 方法用于注册 Vue.js 插件，其中插件可以是一个对象或一个函数

在这个特定的代码`Vue.use(ElementUI)`中，`ElementUI` 是一个库或插件，包含了一系列的组件和指令。通过调用 `Vue.use()` 方法将 `ElementUI` 注册为 Vue.js 的插件，就可以在 Vue.js 应用程序中使用 `ElementUI` 库提供的所有组件和指令了。

```vue
Vue.use(ElementUI)
```

扩展：Vue.js 插件和组件的概念，它们在 Vue.js 应用中扮演着不同的角色。

组件（Component）：

- 组件是 Vue.js 应用程序中构建用户界面的基本单元。
- 每个 Vue.js 组件都是一个 Vue 实例，可以包含模板、脚本和样式等。
- 组件可以被复用、嵌套和动态组合，使得应用程序结构清晰、易于维护。
- 组件主要负责定义了应用程序的界面结构和交互逻辑。

插件（Plugin）：

- 插件是一种扩展 Vue.js 功能的方式，通常用于封装一些公共的功能、指令、过滤器或工具方法等。
- Vue.js 插件以函数或对象的形式存在，通过调用 `Vue.use()` 方法注册到 Vue 实例中。
- 插件可以提供全局功能，例如添加实例方法、指令、混入等，从而为应用程序提供更多的能力。
- 插件的作用范围通常是全局的，可以在整个应用程序中访问和使用插件提供的功能。



#### 8、Vue的插槽

##### 8.1、什么是插槽

插槽（Slot）是 Vue 提出来的一个概念，正如名字一样，**插槽用于决定将所携带的内容，插入到指定的某个位置**，从而使模板分块，具有模块化的特质和更大的重用性。插槽就是子组件中的提供给父组件使用的一个占位符，用`<slot></slot> `表示，父组件可以在这个占位符中填充任何模板代码，如 HTML、组件等，填充的内容会替换子组件的`<slot></slot>`标签。简单理解就是子组件中留下个“坑”，父组件可以使用指定内容来补“坑”。以下举例子帮助理解。

##### 8.2、插槽分类

- 默认插槽
- 具名插槽
- 作用域插槽

##### 8.3、具体使用

（1）默认插槽

语法：

```
<slot></slot>
```

详细说明：

子组件`Children.vue`的模板

```html
<template>
  <div class="about">
    <h1>This is an Children page</h1>
  </div>
</template>
```

在父组件中，想要传递一个<p>标签的内容给子组件

```html
<template>
  <div class="about">
    <h1>This is an Parent page</h1>
    <children>
      <!-- 一个p标签的dom结构 -->
      <p>子组件标签之间</p>
    </children>
  </div>
</template>

<script>
import Children from './Children.vue'
export default {
  components: {
    Children
  },
  data () {
    return {
    }
  }
}
</script>

```

结果是父组件中的p标签的内容是不会传递给子组件的

![image-20240215113701885](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240215113701885.png)



在子组件`Children.vue`中的模板中，通过`<slot></slot>`定义一个默认插槽

```html
<template>
  <div class="about">
    <h1>This is an Children page</h1>
    <!-- 定义一个默认插槽 -->
    <slot></slot>
  </div>
</template>
```

结果是父组件中的p标签的内容会填充到子组件的插槽中

![image-20240215113714010](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240215113714010.png)

在子组件中，你可以定义多个默认插槽，并在子组件中决定这些默认插槽的位置，父组件要插入的内容，都会被填充到这些默认的插槽中

```html
<template>
  <div class="about">
    <h1>This is an Children page</h1>
    <!-- 定义一个默认插槽 -->
    <slot></slot>
    <slot></slot>
  </div>
</template>
```

![image-20240215113808117](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240215113808117.png)

当然，父组件定义要插入到子组件插槽的内容，并不一定是dom结构类型，也可以是一个组件，也可以是普通的数据结构，只要子组件有定义插槽，就会把内容填充进去。

如下面，将组件放入到插槽中：

定义一个组件C

```html
<template>
  <div>
    <p>我是C组件</p>
  </div>
</template>
 
<script>
export default {
  name:'C',
  data(){
    return {
 
    }
  }
}
</script>
```

B组件：

```html
<template>
  <div>
    <p>我是B组件</p>
    <slot></slot>     //插槽的使用方式
  </div>
</template>
 
<script>
export default {
  name:'B',
  data(){
    return {
 
    }
  }
}
</script>
```

在A组件中，将B组件包裹的内容换成C组件：

```html
<template>
  <div class="main">
    <p>我是A组件</p>
    <B>
      <!-- <span style="color:red">验证插槽是否生效</span> -->
      <C />         //插入C组件
    </B>
  </div>
</template>
 
<script>
import B from './B.vue'
import C from './C.vue'   //引入C组件
export default {
  name:'A',
  components:{
    B,
    C      //注册C组件
  },
  data(){
    return {
 
    }
  }
}
</script>
```

结果：

![image-20240215121855629](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240215121855629.png)

后备（默认）内容：

有时为一个插槽设置具体的后备 (也就是默认的) 内容是很有用的，它只会在没有提供内容的时候被渲染。例如在B组件中：

```html
<template>
  <div>
    <slot></slot>
  </div>
</template>
```

我们可能希望这个B组件内绝大多数情况下都渲染文本“我是B组件”。为了将“我是B组件”作为后备内容，我们可以将它放在 `<slot>` 标签内：

```html
<template>
  <div>
    <slot><p>我是B组件</p></slot>
  </div>
</template>
```



（2）具名插槽

说明：其实就是在子组件中定义插槽时，给对应的插槽分别起个名字，方便后边插入父组件将根据name来填充对应的内容。

语法：

`<slot>` 元素有一个特殊的 attribute：`name`。这个 attribute 可以用来定义额外的插槽

一个不带 `name` 的 `<slot>` 出口会带有隐含的名字“default”

```
<slot name="名称"></slot>
```

详细说明：

在子组件中，定义两个具名插槽

```html
<template>
  <div class="about">
    <h1>This is an Children page</h1>
    <!-- 给插槽加了个name属性，就是所谓的具名插槽了 -->
    <slot name="one"></slot>
    <slot name="two"></slot>
  </div>
</template>
```

父组件中：为了验证，子组件中的插槽可以填充任何结构的内容，所以我这边专门在one插槽中插入一个组件，而在two插槽就单纯插入一串普通的数据。

在向具名插槽提供内容的时候，我们可以在一个 `<template>` 元素上使用 `slot` 指令，并以 `slot` 的参数的形式提供其名称（当然也可以直接放在标签中，如<div slot="header">）

任何没有被包裹在带有`slot` 的 `<template>` 中的内容都会被视为默认插槽的内容。

```html
<template>
  <div class="about">
    <h1>This is an Parent page</h1>
    <children>
      <template slot="one">
        <p>one插槽</p>
      </template>
      <template  slot="two">
        two插槽
      </template>
    </children>
  </div>
</template>
// 上面这个是 2.6.0 之前的语法，下面这个是  2.6.0 之后的语法。
或
<template>
  <div class="about">
    <h1>This is an Parent page</h1>
    <children>
      <template v-slot:one>
        <p>one插槽</p>
      </template>
      <template v-slot:two>
        two插槽
      </template>
    </children>
  </div>
</template>

<script>
import Children from './Children.vue'
export default {
  components: {
    Children
  },
  data () {
    return {
    }
  }
}
</script>

```

结果：

![image-20240215121152177](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240215121152177.png)

当然，子组件可以定义多个同名的具名插槽：

```html
<template>
  <div class="about">
    <h1>This is an Children page</h1>
    <!-- 给插槽加了个name属性，就是所谓的具名插槽了 -->
    <slot name="one"></slot>
    <slot name="two"></slot>
    <slot name="two"></slot>
  </div>
</template>

```

![image-20240215121216095](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240215121216095.png)

关于缩写：

把参数之前的所有内容 (`v-slot:`) 替换为字符 `#`。例如 [v-slot](https://so.csdn.net/so/search?q=v-slot&spm=1001.2101.3001.7020):header 可以被重写为 #header

```html
<children>
    <template #[dynamicSlotName]="slotProps">
      <h2>{{slotProps.obj.name}}</h2>
    </template>
</children>

```

然而，和其它指令一样，该缩写只在其有参数的时候才可用。这意味着以下语法是无效的

```html
<children>
    <template #="slotProps">
      <h2>{{slotProps.obj.name}}</h2>
    </template>
</children>

```

如果你希望使用缩写的话，你必须始终以明确插槽名取而代之

```html
<children>
    <template #default="slotProps">
      <h2>{{slotProps.obj.name}}</h2>
    </template>
</children>

```



（3）作用域插槽

说明：有时让插槽内容能够访问子组件中才有的数据是很有用的

B组件：

```html
<template>
  <div>
    <p>我是B组件</p>
    <slot>{{obj.firstName}}</slot>
  </div>
</template>
 
<script>
export default {
  name:'B',
  data(){
    return {
      obj:{
        firstName:'leo',
        lastName:'lion'
      }
    }
  }
}
</script>
```

我们可能想换掉备用内容，用“lion”来显示，此时的A组件如下：

```html
<template>
  <div>
    <p>我是A组件</p>
    <B>
      {{obj.lastName}}
    </B>
  </div>
</template>
```

然而上述代码不会正常工作，因为只有B组件可以访问到 obj，而我们提供的内容是在父级渲染的，即在父级作用域中。页面并无变化：

![image-20240215122747843](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240215122747843.png)

为了让 obj在父级的插槽内容中可用，我们可以将 obj作为 `<slot>` 元素的一个 attribute 绑定上去

```html
<template>
  <div>
    <p>我是B组件</p>
    <slot :obj="obj">{{obj.firstName}}</slot>
  </div>
</template>
```

完整写法

在给 `<slot>` 标签添加属性时，可以使用 `v-bind` 或简写语法 `:` 来绑定动态值。在这种情况下，插槽的内容将会获得绑定的值，可以在插槽内部使用

```
<slot v-bind:obj="obj">{{ obj.firstName }}</slot>
```



绑定在 `<slot>` 元素上的 attribute 被称为**插槽 prop**。现在在父级作用域中，我们可以使用带值的 `slot-scope` 来定义我们提供的插槽 prop 的名字：

```html
<template>
  <div class="main">
    <p>我是A组件</p>
    <B>
      <template slot-scope="data">
        {{data.obj.lastName}}
      </template>
    </B>
  </div>
</template>
```

在这个例子中，我们选择将包含所有插槽 prop 的对象命名为 data，但你也可以使用任意你喜欢的名字。此时页面效果如下：

![image-20240215123259819](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240215123259819.png)



如果你有使用过ElementUI里面的表格el-table，当改变某一列展示的字段时，我们经常使用：

```html
<el-table-column>
  <template slot-scope="scope">
    <span>{{scope.row.xxx}}</span>
  </template>
</el-table-column>
```



（4）动态插槽

说明：动态指令参数也可以用在 v-slot 上，来定义动态的插槽名

详细说明：

子组件：

```html
<template>
  <div class="about">
    <h1>This is an Children page</h1>
    <slot :obj="obj1" name="one"></slot>
    <slot :obj="obj2" name="two"></slot>
  </div>
</template>

<script>
export default {
  data () {
    return {
      obj1: {
        name: 'one slot'
      },
      obj2: {
        name: 'two slot'
      }
    }
  }
}
</script>
```

父组件：

```html
<template>
  <div class="about">
    <h1>This is an Parent page</h1>
    <children>
        <template v-slot:[dynamicSlotName]="slotProps">
          <h2>{{slotProps.obj.name}}</h2>
        </template>
    </children>
  </div>
</template>

<script>
import Children from './Children.vue'
export default {
  components: {
    Children
  },
  data () {
    return {
      dynamicSlotName: 'one'
    }
  }
}
</script>


```

显示效果：

![image-20240215123557661](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240215123557661.png)

（5）补充说明

①插槽版本变化

v-slot 指令自 Vue 2.6.0 起被引入，提供更好的支持 slot 和 slot-scope attribute 的 API 替代方案。v-slot 完整的由来参见这份 RFC。在接下来所有的 2.x 版本中 slot 和 slot-scope attribute 仍会被支持，但已经被官方废弃且不会出现在 Vue 3 中。也就是说，在vue2版本中，我们仍可以使用slot跟slot-scope，但是在vue3中就只能使用v-slot了。

原来的带有slot的具名插槽

```html
//B.vue
<template>
  <div>
    <header>
      <slot name="header"></slot>
    </header>
    <main>
      <slot></slot>
    </main>
    <footer>
      <slot name="footer"></slot>
    </footer>
  </div>
</template>
```

写法变化，使用v-slot

```html
<template>
  <div>
    <p>我是A组件</p>
    <B>
      <template v-slot:header>
        <p>我是header部分</p>
      </template>
 
      <p>我是main（默认插槽）部分</p>
 
      <template v-slot:footer>
        <p>我是footer部分</p>
      </template>
    </B>
  </div>
</template>
```

原来的作用域插槽

```html
<template>
  <div class="main">
    <p>我是A组件</p>
    <B>
      <template slot-scope="data">
        {{data.obj.lastName}}
      </template>
    </B>
  </div>
</template>
```

写法变化，使用v-slot

```html
<template>
  <div class="main">
    <p>我是A组件</p>
    <B>
      <template v-slot="data">
        {{data.obj.lastName}}
      </template>
    </B>
  </div>
</template>
```

总结
在 2.6.0 中，为具名插槽和作用域插槽引入了一个新的统一的语法 (即 v-slot 指令)。它取代了 slot 和 slot-scope 这两个目前已被废弃但未被移除且仍在文档中的 attribute。新语法的由来可查阅这份 RFC。注意slot版本变化，vue2中仍可以使用slot与slot-scope，但是vue3只能使用v-slot了，切记，避免踩坑。



#### 9、前端发送请求

httpRequest.js文件：

这段代码是一个封装了 Axios 的 HTTP 请求库，其中包含了请求拦截、响应拦截、请求地址处理、请求参数处理和请求数据处理等功能。它使用了一些第三方库和工具，如 Axios、qs、lodash 等。

首先，它通过 `import` 语句引入了 Vue、Axios、Router、qs 和 lodash 等库，然后，通过 `axios.create()` 方法创建了一个基于 Axios 的 HTTP 实例 `http`，并设置了一些默认配置，如超时时间、是否携带 cookie、请求头的 Content-Type 等。此处的 `Vue.cookie.get('token')` 是从 Vue-cookie 中读取 `token` 值，并添加到了请求头中。

接下来，它通过 `http.interceptors.request.use()` 和 `http.interceptors.response.use()` 方法分别定义了请求拦截和响应拦截函数，用来在请求发送前或响应返回后对请求和响应做出一些操作。

在 `http.adornUrl()` 方法中，根据当前环境和是否开启代理，处理请求地址的前缀，以便在实际发起请求时能正确访问到接口。

在 `http.adornParams()` 和 `http.adornData()` 方法中，对请求参数和请求数据进行了处理，并加入了一些默认参数，如 `t` 参数等

通过 `export default http` 将 HTTP 实例 `http` 导出，以便在其他文件中使用该 HTTP 请求库

```js
import Vue from 'vue'
import axios from 'axios'
import router from '@/router'
import qs from 'qs'
import merge from 'lodash/merge'
import { clearLoginInfo } from '@/utils'

const http = axios.create({
  timeout: 1000 * 30,
  withCredentials: true,
  headers: {
    'Content-Type': 'application/json; charset=utf-8'
  }
})

/**
 * 请求拦截
 */
http.interceptors.request.use(config => {
  config.headers['token'] = Vue.cookie.get('token') // 请求头带上token
  return config
}, error => {
  return Promise.reject(error)
})

/**
 * 响应拦截
 */
http.interceptors.response.use(response => {
  if (response.data && response.data.code === 401) { // 401, token失效
    clearLoginInfo()
    router.push({ name: 'login' })
  }
  return response
}, error => {
  return Promise.reject(error)
})

/**
 * 请求地址处理
 * @param {*} actionName action方法名称
 */
http.adornUrl = (actionName) => {
  // 非生产环境 && 开启代理, 接口前缀统一使用[/proxyApi/]前缀做代理拦截!
  return (process.env.NODE_ENV !== 'production' && process.env.OPEN_PROXY ? '/proxyApi/' : window.SITE_CONFIG.baseUrl) + actionName
}

/**
 * get请求参数处理
 * @param {*} params 参数对象
 * @param {*} openDefaultParams 是否开启默认参数?
 */
http.adornParams = (params = {}, openDefaultParams = true) => {
  var defaults = {
    't': new Date().getTime()
  }
  return openDefaultParams ? merge(defaults, params) : params
}

/**
 * post请求数据处理
 * @param {*} data 数据对象
 * @param {*} openDefaultData 是否开启默认数据?
 * @param {*} contentType 数据格式
 *  json: 'application/json; charset=utf-8'
 *  form: 'application/x-www-form-urlencoded; charset=utf-8'
 */
http.adornData = (data = {}, openDefaultData = true, contentType = 'json') => {
  var defaults = {
    't': new Date().getTime()
  }
  data = openDefaultData ? merge(defaults, data) : data
  return contentType === 'json' ? JSON.stringify(data) : qs.stringify(data)
}

export default http
```



通常情况下，在前端开发中，`$` 符号通常用作引用第三方库（比如 jQuery、Vue.js、Lodash 等）或者框架提供的方法和属性的约定。例如，在 jQuery 中，我们经常会看到使用 `$` 符号来访问 jQuery 的方法和属性，比如 `$.ajax()`、`$.each()` 等。

在 Vue.js 中，也有类似的用法，许多 Vue 插件和扩展会将一些全局方法和属性挂载在 `Vue.prototype` 上，以便在 Vue 实例中通过 `$` 符号来访问。这样可以避免与其他变量名冲突，并提供一种统一的方式来访问全局方法和属性。

因此我们可以在业务代码中通过$去调用一些方法

```js
// 发送get http请求
this.$http({
    url: this.$http.adornUrl('/product/category/list/tree'),
    method: 'get'
}).then(({data}) => {
    console.log('成功获取到商品菜单数据：', data.data)
    this.category = data.data
})

// 发送post http请求
this.$http({
    url: this.$http.adornUrl('/product/category/delete'),
    method: 'post',
    data: this.$http.adornData(ids, false)
})
```



#### 10、前端代码添加git

参考文章：https://blog.csdn.net/kxz_0204/article/details/124685139

私人令牌描述：tts-platform-vue

![image-20240224144824564](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240224144824564.png)

私人令牌

```
66ca1eed9970d8ee07ad63f71efba834
```

创建远程仓库：

![image-20240224145541995](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240224145541995.png)

添加远程仓库：

![image-20240224145340224](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240224145340224.png)



![image-20240224152601404](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240224152601404.png)

![image-20240224152707334](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240224152707334.png)



#### 11、前端代码格式化配置符合eslint

参考文章：

```
https://blog.csdn.net/weixin_45092437/article/details/125645301
https://blog.csdn.net/qq_40192495/article/details/122421289
```

具体过程：

①安装插件：

**ESlint**

**vetur**

**Prettier - Code formatter**

**Manta's Stylus Supremacy**



②配置文件

![image-20200929181746539](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/296d942ad127b4b12dabfca54d23bae8.png)



```
{
  "workbench.iconTheme": "vscode-icons",
  "explorer.confirmDelete": false,
  "code-runner.saveFileBeforeRun": true,
  "code-runner.runInTerminal": true,
  "code-runner.ignoreSelection": true,
  "code-runner.executorMap": {
    "javascript": "node",
    "java": "cd $dir && javac $fileName && java $fileNameWithoutExt",
    "c": "cd $dir && gcc $fileName -o $fileNameWithoutExt && $dir$fileNameWithoutExt && rm $dir$fileNameWithoutExt.exe",
    "cpp": "cd $dir && g++ $fileName -o $fileNameWithoutExt && $dir$fileNameWithoutExt && rm $dir$fileNameWithoutExt.exe",
    "objective-c": "cd $dir && gcc -framework Cocoa $fileName -o $fileNameWithoutExt && $dir$fileNameWithoutExt",
    "php": "php",
    "python": "python -u",
    "perl": "perl",
    "perl6": "perl6",
    "ruby": "ruby",
    "go": "go run",
    "lua": "lua",
    "groovy": "groovy",
    "powershell": "powershell -ExecutionPolicy ByPass -File",
    "bat": "cmd /c",
    "shellscript": "bash",
    "fsharp": "fsi",
    "csharp": "scriptcs",
    "vbscript": "cscript //Nologo",
    "typescript": "ts-node",
    "coffeescript": "coffee",
    "scala": "scala",
    "swift": "swift",
    "julia": "julia",
    "crystal": "crystal",
    "ocaml": "ocaml",
    "r": "Rscript",
    "applescript": "osascript",
    "clojure": "lein exec",
    "haxe": "haxe --cwd $dirWithoutTrailingSlash --run $fileNameWithoutExt",
    "rust": "cd $dir && rustc $fileName && $dir$fileNameWithoutExt",
    "racket": "racket",
    "scheme": "csi -script",
    "ahk": "autohotkey",
    "autoit": "autoit3",
    "dart": "dart",
    "pascal": "cd $dir && fpc $fileName && $dir$fileNameWithoutExt",
    "d": "cd $dir && dmd $fileName && $dir$fileNameWithoutExt",
    "haskell": "runhaskell",
    "nim": "nim compile --verbosity:0 --hints:off --run",
    "lisp": "sbcl --script",
    "kit": "kitc --run",
    "v": "v run",
    "sass": "sass --style expanded",
    "scss": "scss --style expanded",
    "less": "cd $dir && lessc $fileName $fileNameWithoutExt.css",
    "FortranFreeForm": "cd $dir && gfortran $fileName -o $fileNameWithoutExt && $dir$fileNameWithoutExt",
    "fortran-modern": "cd $dir && gfortran $fileName -o $fileNameWithoutExt && $dir$fileNameWithoutExt",
    "fortran_fixed-form": "cd $dir && gfortran $fileName -o $fileNameWithoutExt && $dir$fileNameWithoutExt",
    "fortran": "cd $dir && gfortran $fileName -o $fileNameWithoutExt && $dir$fileNameWithoutExt"
  },
  "editor.fontSize": 16,
  "editor.unicodeHighlight.allowedCharacters": {
    " ": true
  },
  "terminal.integrated.enableMultiLinePasteWarning": false,
  "files.autoGuessEncoding": true,
  "liveServer.settings.CustomBrowser": "chrome",
  "workbench.colorTheme": "Default Light+",
  "npm.enableRunFromFolder": true,
  "lsby_gitee_vscode_plugin.personal_access_tokens": "66ca1eed9970d8ee07ad63f71efba834",
  "[vue]": {
    "editor.defaultFormatter": "octref.vetur"
  },
  // 以下是eslint 配置
  // vscode默认启用了根据文件类型自动设置tabsize的选项
  "editor.detectIndentation": false,
  // 重新设定tabsize
  "editor.tabSize": 2,
  // #每次保存的时候自动格式化
  "editor.formatOnSave": false,
  "eslint.validate": [
    "javascript",
    "javascriptreact",
    "html",
    "vue"
  ],
  // #每次保存的时候将代码按eslint格式进行修复
  "editor.codeActionsOnSave": {
    "source.fixAll.eslint": false
  },
  //  #让prettier使用eslint的代码格式进行校验
  "prettier.eslintIntegration": true,
  //  #去掉代码结尾的分号
  "prettier.semi": false,
  //  #使用单引号替代双引号
  "prettier.singleQuote": true,
  //  #让函数(名)和后面的括号之间加个空格
  "javascript.format.insertSpaceBeforeFunctionParenthesis": true,
  // #让vue中的js按编辑器自带的ts格式进行格式化
  "vetur.format.defaultFormatter.js": "vscode-typescript",
  "vetur.format.defaultFormatterOptions": {
    "js-beautify-html": {
      "wrap_attributes": "force-aligned"
      // #vue组件中html代码格式化样式
    }
  },
  "window.zoomLevel": 0,
  "explorer.confirmDelete": false,
  "explorer.confirmDragAndDrop": false,
  "editor.renderControlCharacters": true,
  "editor.renderWhitespace": "all",
  // 格式化stylus, 需安装Manta's Stylus Supremacy插件
  "stylusSupremacy.insertColons": false, // 是否插入冒号
  "stylusSupremacy.insertSemicolons": false, // 是否插入分好
  "stylusSupremacy.insertBraces": false, // 是否插入大括号
  "stylusSupremacy.insertNewLineAroundImports": false, // import之后是否换行
  "stylusSupremacy.insertNewLineAroundBlocks": false,
  "[javascript]": {
    "editor.defaultFormatter": "vscode.typescript-language-features"
  },
  "eslint.codeActionsOnSave.rules": null // 两个选择器中是否换行
}
```



#### 12、关于父组件和子组件的绑定

子组件：

```html
<script>
export default {
  // import引入的组件需要注入到对象中才能使用
  components: {},
  // 接受父组件传来的值
  props: {
    catelogPath: {
      type: Array,
      default () {
        return []
      }
    }
  }
  // ……
}
```

父组件：

```html
<el-form-item label="所属分类" prop="catelogId">
	<category-cascader :catelogPath.sync="catelogPath"></category-cascader>
</el-form-item>

<script>
import CategoryCascader from '../common/category-cascader'
export default {
  data () {
    return {
      visible: false,
      dataForm: {
        attrId: 0,
        attrName: '',
        searchType: 0,
        valueType: 1,
        icon: '',
        valueSelect: '',
        attrType: 1,
        enable: 1,
        catelogId: '',
        attrGroupId: '',
        showDesc: 0
      },
      catelogPath: [],
      attrGroups: [],
	}
}
</script>
```

①`:catelogPath.sync="catelogPath"`: 

- :catelogPath`：使用 `:` 绑定属性的值，即将 `catelogPath` 当作父组件的数据属性进行绑定。` 
- .sync`：修饰符，用于创建一个具有双向绑定功能的 prop。

在 Vue.js 组件中，props 是用来接收父组件传递的数据的方式。在你提供的代码中，`<category-cascader>` 组件定义了一个 prop 叫做 `catelogPath`，类型为 Array，并设置了默认值为一个空数组。

与你之前提到的模板代码 `<category-cascader :catelogPath.sync="catelogPath">` 相关联的是这个 prop 定义。当你在父组件中使用 `<category-cascader>` 组件时，通过 `:catelogPath.sync="catelogPath"` 这样的语法，你会将父组件中名为 `catelogPath` 的数据属性传递给 `<category-cascader>` 组件的 `catelogPath` prop。

通过这种方式，父组件可以将自己的数据传递给子组件，并且子组件可以在内部使用这些数据。同时，使用 `.sync` 修饰符可以实现双向绑定，即当子组件修改了 `catelogPath` 数据时，父组件的数据也会相应地更新。

因此，`props: { catelogPath: { type: Array, default () { return [] } } }` 这段代码定义了 `<category-cascader>` 组件接收并使用的数据结构，而模板中的绑定则将父组件的数据与该 prop 关联起来，实现了数据的传递和双向绑定功能。

②data和props

在 Vue.js 中，`props` 和 `data` 是两种不同的数据传递和管理方式：

1. **Props**:
   - `props` 是用来接收父组件传递的数据的方式。
   - 父组件可以通过 props 将数据传递给子组件。
   - Props 是单向数据流，子组件不能直接修改 props 接收到的数据，而是应该通过事件来通知父组件修改。
   - 在子组件中，props 是只读的，子组件无法直接修改 props 中的数据。
2. **Data**:
   - `data` 是用来定义组件内部的数据状态的方式。
   - 每个 Vue 组件实例都有一个名为 `data` 的属性，其值是一个函数，返回组件内部的数据对象。
   - 在 data 中定义的数据可以在组件的模板中直接引用，并且组件可以自由地修改这些数据。
   - 当 data 中的数据发生变化时，Vue 会负责响应式地更新视图。

总的来说，`props` 用于父子组件之间的数据传递，而 `data` 用于组件内部的数据管理。



#### 13、关于显示分类的说明（△）



#### 14、选择分类，显示关联的品牌（△）

![image-20240307191650275](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240307191650275.png)

#### 15、关于回显规格的时候，多选单个不显示问题（△）

加上如下内容就可以了

```
if (v.length === 1 && attr.valueType == 0)
```



## 三、详细步骤

### I、后端

#### 1、安装linux虚拟机

①下载&安装 [VirtualBox](https://www.virtualbox.org/),需要开启CPU虚拟化（百度查一下）

②下载&安装`Vagrant`

Vagrant：Vagrant 是一款用于创建和管理虚拟开发环境的工具。它可以帮助开发人员在不同的计算机上快速设置一致的开发环境，使团队成员能够使用相同的配置进行开发。快速连接VirtualBox，通过镜像创建出对应的虚拟机。

相关地址：

- Vagrant官方镜像仓库：https://app.vagrantup.com/boxes/search
- Vagrant下载：https://www.vagrantup.com/downloads.html

验证vagrant安装是否成功：

打开cmd命令窗口，执行vagrant，查看安装结果：

有vagrant的命令提示，则表示安装成功。

![image-20231218222648321](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231218222648321.png)

③打开window cmd窗口，运行Vagrant init centos/7（根据vagrant镜像库的名称来，使用centos/7镜像），即可初始化一个centos7系统

![image-20231220214908282](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231220214908282.png)

首先会在我们当前用户目录下创建了一个`Vagrantfile`文件

`Vagrantfile` 是用于定义和配置 Vagrant 虚拟机环境的 Ruby 脚本。通过 Vagrantfile，你可以指定虚拟机的操作系统、网络设置、共享文件夹、软件配置等

![image-20231220215031460](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231220215031460.png)

使用 "centos/7" 镜像作为基础镜像进行配置

生成一个默认的 Vagrantfile 文件，其中包含了使用 "centos/7" 镜像的配置信息

如果你使用的是 VirtualBox，Vagrant 会将虚拟机实例创建在 VirtualBox 的默认虚拟机目录中。在 Windows 上，默认位置通常是 `C:\Users\Your_Username\VirtualBox VMs`，而在 macOS 上，默认位置通常是 `/Users/Your_Username/VirtualBox VMs`。

![image-20240216001051791](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240216001051791.png)



④运行 vagrant up 即可启动虚拟机（需要去官方下载镜像，根据镜像启动容器，确保执行该命令的文件目录下有Vagrantfile）。系统 root 用户的密码是 vagrant

在cmd执行vagrant up的效果等同于在VirtualBox直接启动

![image-20231220215740424](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231220215740424.png)

其实通过初始化vagrant工作区的时候，生成的.vagrant去记录需要启动的虚拟机

在使用 Vagrant 管理虚拟机时，Vagrant 会在项目根目录下创建一个名为 `.vagrant` 的隐藏文件夹。这个文件夹包含了一些 Vagrant 在管理虚拟机时需要用到的信息和数据，例如虚拟机状态、网络配置、共享文件夹等。

`.vagrant` 文件夹中包含以下文件和子文件夹：

- `machines`：存储每个虚拟机实例的相关信息，例如虚拟机名称、ID、状态等。
- `data`：存储 Vagrant 实例数据，例如 SSH 连接信息、虚拟机配置等。
- `cache`：缓存虚拟机镜像和 box 文件，以便更快地创建虚拟机实例。

`.vagrant` 文件夹是自动生成的，并且通常不需要手动修改或删除。如果需要重新创建虚拟机实例，可以通过执行 `vagrant destroy` 命令来销毁现有虚拟机并删除 `.vagrant` 文件夹，然后再通过 `vagrant up` 命令重新创建虚拟机实例。



在使用 Vagrant 创建虚拟机时，Vagrant 会自动为每个虚拟机实例生成一个唯一的标识符（UUID）。这个标识符是由 Vagrant 内部维护的，用于标识和管理不同的虚拟机实例。Vagrant 为每个虚拟机实例创建的标识符（UUID）是存储在项目目录下的隐藏文件夹 `.vagrant` 中的 `machines` 子目录中。具体来说，`.vagrant/machines` 目录中的每个子目录对应一个虚拟机实例，并以该虚拟机实例的名称命名。

在每个虚拟机实例的子目录中，你会找到一个 `id` 文件，其中包含分配给该虚拟机实例的标识符（UUID）。这个 `id` 文件的完整路径通常是 `.vagrant/machines/<vm_name>/virtualbox/id`，其中 `<vm_name>` 是虚拟机实例的名称。

可以通过查看 `id` 文件来获取虚拟机实例的标识符。但是请注意，Vagrant 不鼓励直接编辑或修改这些文件，因为这可能会导致与 Vagrant 运行时状态不一致的问题。

这个标识符通常作为虚拟机实例的名称的一部分，并且会显示在 Vagrant 命令的输出中。例如，当你运行 `vagrant global-status` 命令查看所有虚拟机实例的状态时，每个虚拟机实例都会显示一个类似于 `abcd123` 的标识符。

这个标识符的目的是确保每个虚拟机实例都有一个唯一的名称，以便在 Vagrant 运行期间进行管理和识别。但是请注意，这个标识符对于大部分用户来说并不是必需的，你可以使用虚拟机实例的名称或 ID 来与 Vagrant 进行交互。



可以通过`vagrant box list`  查看本地box列表

一些相关的命令可以看如下文章：

> https://blog.csdn.net/weixin_44928329/article/details/132695063



⑤vagrant其他常用命令

​	vagrant ssh：自动使用vagrant用户连接虚拟机

```
//显示这个即表示连接成功
[vagrant@localhost ~]$
```

​	vagrant upload source [destination] [name|id]：上传文件

​    https://www.vagrantup.com/docs/cli/init.html Vagrant 命令行

   su root：切换到root用户，密码默认为vagrant

⑥虚拟机网络配置

默认虚拟机的ip地址不是固定ip，开发不方便

虚拟机默认的网络是采用网络地址转换（NAT）的方式，这对我们后来的开发很不方便

![image-20231218224231138](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231218224231138.png)

网络地址转换-端口转发

如我们在windows系统中装了一个virtualbox（其中是liunx系统），在虚拟机中我们会装很多的软件如mysql、redis等，假设当前mysql和redis在liunx中的端口分别是3306、6369，那么如果我们要进行端口转发，我们饿需要将虚拟机中的3306端口和windows中的3333端口绑定，这样别人访问windowos的3333端口就相当于访问到了虚拟机中的3306的mysql，但是我们之后每次在虚拟机中创建一个应用，都要做端口转发，很不方便

![image-20231218224710944](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231218224710944.png)

因此我们想给虚拟机一个固定的ip地址。wnidows能够和virtualbox相互ping通，那么对于一个虚拟机中的软件，我们直接拿该虚拟机固定ip地址加端口号来访问即可。

安装虚拟网卡的地址进行配置，当前虚拟网卡的地址是192.168.56.1，那么我们虚拟机的地址就要设置成192.168.56.几

![image-20231218225007505](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231218225007505.png)



虚拟机是根据Vagrantfile来创建虚拟机信息的，编辑Vagrantfile

打开其中的私有网络，并指定对应的ip

```
config.vm.network "private_network", ip: "192.168.56.10"
```

通过命令`vagrant reload`重启虚拟机

通过命令vagrant ssh以ssh连接虚拟机

通过命令`ip addr`查看网络地址

![image-20231220222753716](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231220222753716.png)

测试主机和虚拟机是否可以ping通

先查看windows地址

![image-20231220222901805](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231220222901805.png)

虚拟机ping 主机windows：

![image-20231220222942919](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231220222942919.png)

windows ping 虚拟机

![image-20231220223018009](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231220223018009.png)



未完成：ubuntu和windows的网络互通 ……

注意点：

1.VirtualBox会与包括但不限于如下软件冲突，需要卸载这些软件，然后重启电脑冲突的软件：红蜘蛛、360、净网大师（有可能）等

2、修改linux的yum源

1）备份原yum源

2）使用新yum源

curl

http://mirrors.163.com/.help/CentOS7-Base-163.repo

3)使用缓存

yum makecache



⑥迁移虚拟机

原因：因为上面的操作是默认将虚拟机内容安装在C盘的，而后期会很大，因此我们需要将虚拟机的内容从C盘中迁移出去。

说明：

首先，[vagrant](https://so.csdn.net/so/search?q=vagrant&spm=1001.2101.3001.7020)的运行是依托于VirtualBox这个虚拟机软件的

那么首先找到VirtualBox的安装位置，我的安装位置是`C:\Program Files\Oracle\VirtualBox`

这个目录下，我们使用命令行查看一下当前安装的虚拟机数量

```
vboxmanage list vms
```

![image-20240215233834564](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240215233834564.png)

当前使用的虚拟机是`23220_default_1703080432995_81503`

进入到vagrant的安装目录`C:\Users\23220`

其虚拟机存储的位置默认也是这里

![image-20240216000052725](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240216000052725.png)





直接在virtual box中通过移动操作移动到指定目录即可

![image-20240216000140460](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240216000140460.png)



关于vagrant中的内容迁移可以看这个文章

> https://blog.csdn.net/glatchen/article/details/83187484



#### 2、docker

dokcer安装相关文档（参考官方文档）：https://docs.docker.com/get-docker/

docker版本：

- Docker Engine - Community 社区版（免费、开源）
- Docker Enterprise 企业版（收费）

步骤：

①卸载之前的docker

```
sudo yum remove docker \
            docker-client \
            docker-client-latest \
            docker-common \
            docker-latest \
            docker-latest-logrotate \
            docker-logrotate \
            docker-engine
```



如果没有安装过docker，如下显示：

![image-20231220224251081](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231220224251081.png)

②安装docker-CE

（1）安装必须的依赖：

```
sudo yum install -y yum-utils \
device-mapper-persistent-data \
lvm2
```

（2）设置 docker repo 的 yum 位置

告诉虚拟机，docker去哪里装

```
sudo yum-config-manager \
--add-repo \
https://download.docker.com/linux/centos/docker-ce.repo
```

![image-20231220224629946](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231220224629946.png)

（3）安装docker，以及docker-cli（客户端）

```
sudo yum install docker-ce docker-ce-cli containerd.io
```

（4）启动docker

```
sudo systemctl start docker
```

检查dokcer命令

通过sudo docker images检查当前虚拟机中的镜像（需要权限，因此加sudo）

![image-20231220224952066](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231220224952066.png)

（5）设置docker开机自启

```
sudo systemctl enable docker
```



（6）其他命令

https://docs.docker.com/engine/reference/commandline/docker/

```
Docker启动命令1: sudo systemctl start docker
Docker启动命令2: sudo service docker start

Docker重启命令1: sudo systemctl restart docker
Docker重启命令2: sudo service docker restart

docker关闭命令1: sudo systemctl stop docker
docker关闭命令2: sudo service docker stop

守护进程重启: sudo systemctl daemon-reload

设置Docker开机自启动方式1: systemctl enable docker.service
设置Docker开机自启动方式2: chkconfig docker on

关闭Docker开机启动: systemctl disable docker.service

查看是否设置开机启动列表: systemctl list-unit-files | grep enable

```



（7）配置docker镜像加速

阿里云镜像网站：https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors

选择centos

![image-20231220230055885](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231220230055885.png)

```
阿里云，容器镜像服务
针对 Docker 客户端版本大于 1.10.0 的用户
您可以通过修改 daemon 配置文件/etc/docker/daemon.json 来使用加速器
sudo mkdir -p /etc/docker
sudo tee /etc/docker/daemon.json <<-'EOF' { "registry-mirrors": ["https://82m9ar63.mirror.aliyuncs.com"]
}
EOF
sudo systemctl daemon-reload
sudo systemctl restart docker
```

配置完aliyun加速，之后dokcer在下载镜像的时候，都是通过aliyun镜像进行的，速度会更快





报错：

```
Job for docker.service failed because start of the service was attempted too often
```

进入docker修改其中的配置文件后缀

```
cd /etc/docker
mv daemon.json daemon.conf
```

#### 3、docker安装mysql

①从中央镜像仓库拉取镜像文件

```
sudo docker pull mysql:[版本号]
省略版本号默认拉取最新的lasted
可以在docker网站中点击对应的镜像查看tag
```

![image-20231225185910787](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231225185910787.png)

通过sudo docker images查看当前安装的docker镜像

![image-20231225185923847](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231225185923847.png)



②创建实例并启动

```ssh
docker run -p 3306:3306 --name mysql \
-v /mydata/mysql/log:/var/log/mysql \
-v /mydata/mysql/data:/var/lib/mysql \
-v /mydata/mysql/conf:/etc/mysql/config.d \
-e MYSQL_ROOT_PASSWORD=root \
-d mysql:5.7

参数说明：
docker run： 每执行一次docker run都会创建一个容器，容器和容器相互隔离
-p 3306:3306：将容器的 3306 端口映射到主机的 3306 端口
--privileged=true：是 Docker 命令的一个选项，用于在容器内部提供特权访问，Docker 将为容器启用所有的 Linux 内核功能，这样容器将拥有与主机操作系统相同的权限，包括访问所有设备和文件系统
--name mysql： 是为我们当前启动的浏览器创建一个名称，这里为mysql
-v /mydata/mysql/conf:/etc/mysql：将配置文件夹挂载到主机
-v /mydata/mysql/log:/var/log/mysql：将日志文件夹挂载到主机
-v /mydata/mysql/data:/var/lib/mysql/：将配置文件夹挂载到主机
-e MYSQL_ROOT_PASSWORD=root：初始化 root 用户的密码
-d mysql:5.7: -d表示后台启动，mysql:5.7表示使用的是mysql:5.7这个镜像
```

执行结果：

![image-20231225191457432](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231225191457432.png)

通过命令`docker ps`可以查看已经正在运行中的容器：

可以看到其中的参数内容

`CONTAINER ID`: 容器的唯一标识符

`IMAGE`：容器所使用镜像名称

`COMMAND`：容器启动使用的命令

`CREATED`：容器创建的时间

`STATUS`：容器的状态

`PORTS`:容器映射到主机的端口信息

`NAMES`:当前容器名称

![image-20231225191640673](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231225191640673.png)



我们通过本机的3306端口去连接虚拟机映射的3306端口：

如果一开始是连不上的

![image-20231225192256593](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231225192256593.png)

关闭防火墙

```
详情见：https://blog.csdn.net/m0_57076217/article/details/121845648
```

![image-20231225192516028](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231225192516028.png)



![image-20231225193614527](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231225193614527.png)



③具体详解

1、`docker run`

我们启动的mysql容器一个完整的mysql运行环境，因为mysql是装载linux中的，因此这个mysql容器就是一个linux

我们按照如下的脚本命令进入到容器中：

```
docker exec -it  [容器的ID||容器的名字（确定唯一即可）]
```

进入到该容器的/bin/bash中

```
docker exec -it mysql /bin/bash
```

![image-20231225194114609](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231225194114609.png)



我们在该目录下，通过`ls`，可以看到其就是一个linux目录，就说明我们现在的mysql被装到了一个小小的linux中

![image-20231225194153885](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231225194153885.png)

通过命令`exit`退出当前小小linux



2、`-p 3306:3306`

表示当前mysql容器是在一个小小linux中，其占用自己小小linux的3306端口，我们还需要将其与linux的端口3306进行映射，这样我们在访问大Linux的3306端口的时候，就能访问到小小linux的3306端口中的mysql

![image-20231225194937337](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231225194937337.png)

3、目录挂载

我们指定我们的mysql都是被装载容器中

我们不可能每次创建一个容器都要去进入到容器的目录下去修改其配置文件，因此我们把配置文件放到大linux中，容器去进行一个挂载即可

```
/*
我们将大容器中的/mydata/mysql/log映射到小容器中的/var/log/mysql 
即小容器中产生了日志，我们在大容器中的/mydata/mysql/log就可以看到对应的日志信息
相当于把容器中的/var/log/mysql的快捷方式放到了大linux中的/mydata/mysql/log位置
*/
-v /mydata/mysql/log:/var/log/mysql \
//将mysql的数据库文件挂载到外面，相当于一个备份
-v /mydata/mysql/data:/var/lib/mysql \
-v /mydata/mysql/conf:/etc/mysql/config.d \
```

![image-20231225195819844](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231225195819844.png)



④修改mysql的配置文件

在外部挂载的目录下，修改配置文件

```
vi /mydata/mysql/conf/my.cnf
```

将如下内容粘贴到配置文件中（主要修改mysql的字符编码）

```
[client]
default-character-set=utf8
[mysql]
default-character-set=utf8
[mysqld]
init_connect='SET collation_connection = utf8_unicode_ci' init_connect='SET NAMES utf8' character-set-server=utf8
collation-server=utf8_unicode_ci
skip-character-set-client-handshake
skip-name-resolve
```

进入到容器内部去查看是否成功生成配置文件，可以看到生成配置文件成功

![image-20231225200658582](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231225200658582.png)



⑤重启mysql

通过如下命令重启mysql

```
docker restart [容器名称]
```

![image-20231225200154448](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231225200154448.png)



通过`docker ps`可以看到我们的mysql容器是刚刚重启起来的

![image-20231225200217196](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231225200217196.png)



注意：

1、如果已经启动过容器，尽管ps中会看不到，在启动会报错

```
docker: Error response from daemon: Conflict. The container name "/mysql" is already in use by container "d3871742e99ba4762e616cbcdb88374dddbc815aa49b017668bbc8d9c5b54aa1". You have to remove (or rename) that container to be able to reuse that name.
```

解决：

移除原来的`container ID`

```ssh
docker rm [container ID] 
```

例如eg:

```
docker rm d3871742e99ba4762e616cbcdb88374dddbc815aa49b017668bbc8d9c5b54aa1
```

2、mysql连接慢

在配置文件中加入如下，并重启 mysql

[mysqld]

skip-name-resolve

解释：

skip-name-resolve：跳过域名解析



#### 4、docker安装redis

①从docker中央仓库中下载redis镜像

输入命令`docker pull redis`不加`：`后面就是下载最新的`latest`

![image-20231225200931522](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231225200931522.png)  

通过`docker images`查看当前的镜像，可以发现成功下载了对应的`redis`镜像 

![image-20231225201003922](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231225201003922.png)



②创建并启动容器

```
//这里通过-d redis 指定通过redis镜像进行后端启动
//redis-server /etc/redis/redis.conf 表示redis服务器每次启动都去加载/etc/redis/redis.conf中的配置文件

docker run -p 6379:6379 --name redis 
//设置redis中的数据挂载
-v /mydata/redis/data:/data \
-v /mydata/redis/conf/redis.conf:/etc/redis/redis.conf \
-d redis redis-server /etc/redis/redis.conf
```

创建目录结构

```
mkdir -p /mydata/redis/conf
```

进入到redis目录，创建redis的配置文件

![image-20231225201652898](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231225201652898.png)

启动redis容器

```
docker run -p 6379:6379 --name redis -v /mydata/redis/data:/data \
-v /mydata/redis/conf/redis.conf:/etc/redis/redis.conf \
-d redis redis-server /etc/redis/redis.conf
```

![image-20231225201721242](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231225201721242.png)

通过`docker ps`可以看到`redis`服务已经成功启动了

![image-20231225201803160](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231225201803160.png)

③通过redis执行redis-cli命令连接

```
docker exec -it redis redis-cli
```

![image-20231225202003720](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231225202003720.png)

但是redis默认的数据都是存储在内存中的，不支持持久化的，如果重启redis，在连接客户端，获取a的值就获取不到了



④配置redis可持久化

在redis配置文件中修改

![image-20231225202213230](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231225202213230.png)

在配置文件中输入`appendonly yes  `，即支持AOF的可持久化设置“

![image-20231225202516334](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231225202516334.png)

⑤通过RedisDesktopManager连接redis容器

![image-20231225203001861](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231225203001861.png)

可以在其中看到我们刚刚创建的a

![image-20231225203024957](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231225203024957.png)



注意：

1、可以去redis的官方查看对应的配置文件配置内容





docker扩展：

如果需要让容器启动docker后自动启动（即虚拟机启动，自动启动docker，docker自动启动容器），通过如下命令

```
docker update redis --restart=always
docker update mysql --restart=always
```



#### 5、Maven配置

找到maven的配置文件目录

```
D:\tool\develop\apache-maven-3.6.1\conf
```

创建对应的配置文件`settings-TTS.xml`

在其中配置响应的内容

```xml
<?xml version="1.0" encoding="UTF-8"?>

<settings xmlns="http://maven.apache.org/SETTINGS/1.2.0"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.2.0 https://maven.apache.org/xsd/settings-1.2.0.xsd">

<!-- 配置阿里镜像 -->
<mirrors>
    <mirror>
        <id>nexus-aliyun</id>
        <mirrorOf>central</mirrorOf>
        <name>Nexus aliyun</name>
        <url>http://maven.aliyun.com/nexus/content/groups/public</url>
    </mirror>
</mirrors>

<!-- 配置jdk1.8编译项目 -->
<profiles>
    <profile>
        <id>jdk-1.8</id>
        <activation>
            <activeByDefault>true</activeByDefault>
            <jdk>1.8</jdk>
        </activation>
        <properties>
            <maven.compiler.source>1.8</maven.compiler.source>
            <maven.compiler.target>1.8</maven.compiler.target>
            <maven.compiler.compilerVersion>1.8</maven.compiler.compilerVersion>
        </properties>
    </profile>
</profiles>

</settings>

```



配置idea的maven，就是在`setting`中的`maven`中设置，这里不展开介绍了



#### 6、IDEA安装响应的插件

①`lombok`

②`mybatisX`



#### 7、安装配置git

①下载git（略）：https://git-scm.com

②配置git，进入git bash

通过`git config user.name`和`git config user.email`先看一下当前git配置的用户名和邮箱，可以看到我们配置过了，说明我们用过马源了

![image-20231225205423510](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231225205423510.png)

通过`git config --global user.name`和`git config --global user.email`看一下当前git配置的全局用户名和邮箱

![image-20231225205604668](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231225205604668.png)

如果需要修改可以使用如下命令

```
# 配置用户名
git config --global user.name "username" //（名字）
# 配置邮箱
git config --global user.email "username@email.com" //(注册账号时用的邮箱)
```



③ 配置`ssh`免密码登录

```
相关文章：
https://gitee.com/help/articles/4181#article-header0
Git+码云教程：
https://gitee.com/help/articles/4104
```

进入 git bash；使用：ssh-keygen -t rsa -C "xxxxx@xxxxx.com"（邮箱地址）命令。 连续三次回车，就会在用户目录下生成对应的秘钥：

![image-20231225205848572](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231225205848572.png)

通过`cat ~/.ssh/id_rsa.pub`查看生成的对应的秘钥内容

![image-20231225205920154](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231225205920154.png)

登录进入 gitee，在设置里面找到 SSH KEY 将.pub 文件的内容粘贴进去

![image-20231225210358116](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231225210358116.png)

使用 `ssh -T git@gitee.com` 测试是否成功即可

![image-20231225210454226](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231225210454226.png)



#### 8、创建项目微服务

①登录自己的码源，创建对应的仓库

![image-20231225211524179](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231225211524179.png)

②在idea中创建项目，选择版本来自于git

![image-20231225212800960](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231225212800960.png)

![image-20231225212828287](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231225212828287.png)

后来将父模块的名称修改为`tts-platform`

③创建各个模块

模块：商品服务、仓储服务、订单服务、优惠券服务、用户服务

共同点：

1）都通过spring的初始化向导添加了web、、openfeign

2） 每一个服务，报名：com.yjy.tts.xxx(product/order/ware/coupon/member)

3）模块名：tts-xxx（product/order/ware/coupon/member）



具体示例：

（1）存储服务

使用spring的初始化向导

![image-20231225212939475](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231225212939475.png)

![image-20231225214125239](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231225214125239.png)

![image-20231225214133617](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231225214133617.png)

![image-20231225214159868](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231225214159868.png)



④配置总项目模块（模块聚合，聚合各个微服务模块）

**聚合的作用：** 聚合用于快速构建maven工程，一次性构建多个项目/模块。

**多模块的构建维护：**在进行模块拆分后，如果某一个模块更新后，那么其他的模块都会因为该模块的原因而无法成功运行。那么我们这个时候就需要一个模块去统一管理这些模块，去负责这些模块的编译等功能（由该模块的功能执行，来对这些拆分的模块进行统一的功能执行），一个模块的活动对其他模块透明。

为了方便对这些微服务的管理，需要有一个聚合模块去统一管理这些微服务模块，通过设置集合模块的`packing`打包方式为`pom`，并且通过`modules`指定微服务模块，其`pom.xml`文件内容如下所示：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <!--当前项目信息-->
    <groupId>com.yjy.tts</groupId>
    <artifactId>tts</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>tts</name>
    <description>海的味道电商平台-聚合服务</description>
    <packaging>pom</packaging>

    <!--定义当前模块进行构建操作的时候关联的其他模块的名称-->
    <modules>
        <!--优惠券服务-->
        <module>tts-coupon</module>
        <!--会员服务-->
        <module>tts-member</module>
        <!--订单服务-->
        <module>tts-order</module>
        <!--商品服务-->
        <module>tts-product</module>
        <!--仓储服务-->
        <module>tts-ware</module>
    </modules>

</project>

```

![image-20231231111351936](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231231111351936.png)

我们执行该聚合服务的构建命令`clean`，可以看到关联的模块依次执行

![image-20231231111441989](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231231111441989.png)

打包方式说明：

1. JAR（Java Archive）：JAR是一种将Java类、资源文件和元数据打包成一个文件的标准格式。它可以包含可执行代码、库文件和配置文件等。JAR文件可以作为独立的应用程序运行，也可以作为库文件供其他项目使用。
2. WAR（Web Application Archive）：WAR是一种将Web应用程序打包成部署包的格式。它包含了Web应用程序的所有相关文件，如HTML、CSS、JavaScript、Servlet、JSP等。WAR文件可以被部署到支持Java Web容器的服务器上。
3. POM（Project Object Model）：打包方式为pom通常是指Maven项目管理工具中使用的一种打包方式，即将项目打包成一个POM文件。POM（Project Object Model）文件是Maven项目管理工具中使用的XML文件，用于描述项目的结构、依赖关系和构建配置等。例如当我们对聚合模块执行`package`服务，相当于所有的关联模块都会执行`package`命令，其他同理。



⑤修改`.gitignore`文件

`.gitignore`用于指明哪些文件不需要进行版本管理

我们的目的是只给码原中提交我们的代码`src`和`pom`文件

聚合模块的`.gitignore`内容如下

```
target/
pom.xml.tag
pom.xml.releaseBackup
pom.xml.versionsBackup
pom.xml.next
release.properties
dependency-reduced-pom.xml
buildNumber.properties
.mvn/timing.properties
# https://github.com/takari/maven-wrapper#usage-without-binary-jar
.mvn/wrapper/maven-wrapper.jar

# 需要忽略的版本控制文件
**/mvnw
**/mvnw.cmd
**/.mvn
**/target/
.idea

# 子模块的gitignore忽略
**/.gitignore
```



⑥提交代码到远程仓库

![image-20231231113255610](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231231113255610.png)

![image-20231231113325987](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231231113325987.png)

![image-20231231113401595](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231231113401595.png)



#### 9、数据库初始化

通过`powerDesigner`打开对应的数据库设计，目前每一个服务对应自己的数据库

![image-20231231141359904](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231231141359904.png)

注意：在所有表中不设计到外键的设计，因为对于电商平台，数据量巨大，如果设计外键，十分消耗性能（几百万条数据，每插入一条数据，都要进行外键的检查，保持数据一致性）



启动虚拟机中docker的mysql容器，并通过navicat进行连接

将数据表的sql文件放入到对应的数据库中进行执行，创建对应的数据表

![image-20231231144442249](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231231144442249.png)

①创建商品管理系统的数据库

![image-20231231143717355](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231231143717355.png)

![image-20231231144948805](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231231144948805.png)

②创建订单系统数据库

![image-20231231143829655](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231231143829655.png)

![image-20231231144731031](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231231144731031.png)

③创建营销系统数据库

![image-20231231143945630](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231231143945630.png)

![image-20231231145240286](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231231145240286.png)

④创建用户系统数据库

![image-20231231144012658](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231231144012658.png)

![image-20231231145303774](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231231145303774.png)

⑤创建库存系统

![image-20231231144058690](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231231144058690.png)

![image-20231231145331661](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231231145331661.png)



#### 10、创建后台管理系统（通过gitee上的人人开源进行快速搭建）

![image-20231231145920446](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231231145920446.png)

我们选择人人开源的前后端分离的项目作为后台管理系统，`renren-fast`后端，`renren-fast-vue`是前端。

将人人网这两个项目通过git克隆下来

![image-20231231150636598](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231231150636598.png)

然后将其中的的`.git`删掉,取消原来的版本控制，使用自己的`git`去进行版本控制

然后将后端的项目整个拖到我们当前项目中

 ![image-20231231150802749](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231231150802749.png)

将后台管理系统加入到当前的管理模块中

```xml
<!--定义当前模块进行构建操作的时候关联的其他模块的名称-->
<modules>
    <!--优惠券服务-->
    <module>tts-coupon</module>
    <!--会员服务-->
    <module>tts-member</module>
    <!--订单服务-->
    <module>tts-order</module>
    <!--商品服务-->
    <module>tts-product</module>
    <!--仓储服务-->
    <module>tts-ware</module>
    <!--后台管理系统-->
    <module>renren-fast</module>
</modules>
```

根据renren项目中的mysql去创建对应的数据表

![image-20231231151025764](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231231151025764.png)

创建管理系统的数据库

![image-20231231151104394](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231231151104394.png)

根据mysql.sql创建对应的数据表

![image-20231231151201432](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231231151201432.png)

修改`renrenfast`项目的配置文件

首先看到其application.yml中使用的是dev

![image-20231231161957250](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231231161957250.png)

我们找到application-dev.yml，然后修改其数据库连接信息

```java
spring:
    datasource:
        type: com.alibaba.druid.pool.DruidDataSource
        druid:
            driver-class-name: com.mysql.cj.jdbc.Driver
            url: jdbc:mysql://192.168.56.10:3306/tts_admin?useUnicode=true&characterEncoding=UTF-8&serverTimezone=Asia/Shanghai
            username: root
            password: root

```



#### 10、代码生成器

克隆人人开源的`renren-generator`到本地

![image-20231231181936888](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231231181936888.png)

同样将代码生成器导入到我们的项目中，并在聚合服务中进行关联

![image-20231231182809971](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231231182809971.png)

```xml
<!--定义当前模块进行构建操作的时候关联的其他模块的名称-->
<modules>
    <!--优惠券服务-->
    <module>tts-coupon</module>
    <!--会员服务-->
    <module>tts-member</module>
    <!--订单服务-->
    <module>tts-order</module>
    <!--商品服务-->
    <module>tts-product</module>
    <!--仓储服务-->
    <module>tts-ware</module>
    <!--后台管理系统-->
    <module>renren-fast</module>
    <!--代码生成器-->
    <module>renren-generator</module>
</modules>
```

修改配置文件中的信息

```yml
driverClassName: com.mysql.cj.jdbc.Driver
# 需要生成哪个数据库，就连接哪一个
url: jdbc:mysql://192.168.56.10:3306/tts_pms?useUnicode=true&characterEncoding=UTF-8&useSSL=false&serverTimezone=Asia/Shanghai
username: root
password: root
```

配置代码生成器的相关配置信息

```yml
#代码生成器，配置信息

mainPath=com.yjy
#包名
package=com.yjy.tts
moduleName=product
#作者
author=yjy
#Email
email=2322092442@qq.com
#表前缀(类名不会包含表前缀)
tablePrefix=pms_

#类型转换，配置信息
tinyint=Integer
smallint=Integer
mediumint=Integer
int=Integer
integer=Integer
bigint=Long
float=Float
double=Double
decimal=BigDecimal
bit=Boolean

char=String
varchar=String
tinytext=String
text=String
mediumtext=String
longtext=String


date=Date
datetime=Date
timestamp=Date

NUMBER=Integer
INT=Integer
INTEGER=Integer
BINARY_INTEGER=Integer
LONG=String
FLOAT=Float
BINARY_FLOAT=Float
DOUBLE=Double
BINARY_DOUBLE=Double
DECIMAL=BigDecimal
CHAR=String
VARCHAR=String
VARCHAR2=String
NVARCHAR=String
NVARCHAR2=String
CLOB=String
BLOB=String
DATE=Date
DATETIME=Date
TIMESTAMP=Date
TIMESTAMP(6)=Date

int8=Long
int4=Integer
int2=Integer
numeric=BigDecimal

nvarchar=String
```

访问80端口，显示代码生成器页面，可以看到其把我们当前连接数据库中的所有数据表都显示出来了

![image-20231231185310595](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231231185310595.png)

我们选择需要生成代码的表，然后点击生成代码即可获得对应的压缩包

![image-20231231185733146](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231231185733146.png)

![image-20231231185802146](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231231185802146.png)

将main直接覆盖对应的项目的main目录

![image-20231231190149074](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231231190149074.png)



代码生成器的核心就是通过template中的模板，然后动态注入生成的，我们可以在这里修改代码生成器产生的模板

![image-20240103210800684](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240103210800684.png)



但是其中有很多通用的地方都是没有的，如返回类型R，因此我们需要开一个服务，专门用于放这些通用的内容（公共的类、公共的依赖），然后让每个微服务都来依赖这个common

初步的配置文件：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <artifactId>tts</artifactId>
        <groupId>com.yjy.tts</groupId>
        <version>0.0.1-SNAPSHOT</version>
    </parent>
    <modelVersion>4.0.0</modelVersion>

    <artifactId>tts-common</artifactId>
    <description>每一个微服务公共的依赖服务</description>

    <!--公共依赖-->
    <dependencies>
        <!--①数据源相关-->
        <!--mybatis-plus快速启动依赖-->
        <dependency>
            <groupId>com.baomidou</groupId>
            <artifactId>mybatis-plus-boot-starter</artifactId>
            <version>3.2.0</version>
        </dependency>



        <!--②其他依赖-->
        <!--lombok 简化注解提供-->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>1.18.8</version>
        </dependency>
        <!--用于在Java中进行HTTP通信的Apache HttpCore库-->
        <dependency>
            <groupId>org.apache.httpcomponents</groupId>
            <artifactId>httpcore</artifactId>
            <version>4.4.12</version>
        </dependency>
        <!--Commons Lang提供了一组通用的工具类，用于处理字符串、数组、日期、数字等方面的编程任务-->
        <dependency>
            <groupId>commons-lang</groupId>
            <artifactId>commons-lang</artifactId>
            <version>2.6</version>
        </dependency>


        <!--③其他服务/项目相关依赖-->


    </dependencies>

</project>
```



#### 11、测试商品服务的CRUD功能

经过上面common通用服务的搭建，现在商品服务已经不报错了

首先我们对商品服务整合mybatis-plus

1、导入依赖

我们已经在common服务中导入了关于mybatis-plus的依赖，并且商品服务导入了common服务的依赖，即间接导入了mybatis-plus的依赖

```xml
<!--①数据源相关-->
<!--mybatis-plus快速启动依赖-->
<dependency>
    <groupId>com.baomidou</groupId>
    <artifactId>mybatis-plus-boot-starter</artifactId>
    <version>3.2.0</version>
</dependency>
```

2、配置

2.1 配置数据源

①导入mysql的驱动

由于其他服务也是需要导入mysql的驱动的，因此我们直接在common服务中导入mysql的驱动，其他服务直接依赖common服务即可

根据自己mysql的服务，选择对应的mysql驱动的依赖版本，官方中的对应关系如下：

```
https://dev.mysql.com/doc/connector-j/en/connector-j-versions.html
```

![image-20240103213941425](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240103213941425.png)

```
以下是连接器/J 8.2的一些兼容性信息：
JDBC版本：连接器/J 8.2实现JDBC 4.2。虽然Connector/J 8.2与更高JDBC版本的库一起工作，但对于仅JDBC 4.3及更高版本支持的方法的任何调用，它都会返回SQLFeatureNotSupportedException。
MySQL Server版本：连接器/J 8.2支持MySQL 5.7及以上版本。
JRE版本：连接器/J 8.2支持JRE 8或更高版本。
编译需要JDK：编译连接器/J 8.2需要JDK 8.0或更高版本。此外，在连接到MySQL服务器时，可能需要自定义的JSSE提供程序使用一些更高版本的TLS和密码套件。例如，由于Oracle在8u261之前的Java 8版本附带的JSSE实现仅支持1.2版以下的TLS，因此您需要自定义的JSSE实施才能在这些Java 8平台上使用TLSv1.3。Oracle Java 8u261及以上版本确实支持TLSv1.3，因此不需要定制的JSSE实现。
```

我们当前的mysql版本是5.7，因此我们选择的mysql驱动是8.0.17，在common中导入mysql驱动的依赖

```xml
 <!--mysql驱动-->
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>8.0.17</version>
</dependency>
```

②在application.yml配置文件中配置数据源

![image-20240103215353414](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240103215353414.png)

配置数据源信息

```yml
spring:
  # 配置数据源相关信息
  datasource:
    username: root
    data-password: root
    url: jdbc:mysql//192.168.56.10:3306/tts_pms
    driver-class-name: com.mysql.cj.jdbc.Driver
```

2.2 配置mybatis-plus

①使用@MapperScan

指定要变成实现类的接口所在的包，包下面的所有接口在编译之后都会生成相应的实现类，即扫描mapper层的接口，在编译之后会生成相应的接口实现类

@MapperScan通常可以放在启动类上，也可以放在配置类上

```java
@MapperScan("com.yjy.tts.product.mapper")
@SpringBootApplication
public class TtsProductApplication {

    public static void main(String[] args) {
        SpringApplication.run(TtsProductApplication.class, args);
    }

}

```

在不使用@MapperScan前，我们需要直接在Mapper类上面添加注解@Mapper，也可以为对应接口生成实现类。但是这种方式要求每一个Mapper类都需要添加此注解，非常麻烦，属于重复劳动。通过使用@MapperScan注解，可以让我们不用为每个Mapper类都添加@Mapper注解。



②告诉Mybatis-plus，sql映射文件位置

在配置文件中进行配置

```
#配置mybatis-plus映射文件的路径
mybatis-plus:
  mapper-locations: classpath:/mapper/**/*.xml
```

其中classpath`*`的`*`表示不止扫描当前项目的类路径，其他依赖的jar包中的类路径也一起扫描

默认路径配置：

```
private String[] mapperLocations = new String[]{"classpath*:/mapper/**/*.xml"};
```



③调整主键

在实体中的主键字段上有一个@TableId字段，用来指明该字段是主键

```java
@TableId
private Long id;
```

其源码如下

```java
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD})
public @interface TableId {
    String value() default "";

    IdType type() default IdType.NONE;
}

```

其中有个`type`类型用来指定主键生成规则

```java
public enum IdType {
    AUTO(0),
    NONE(1),
    INPUT(2),
    ID_WORKER(3),
    UUID(4),
    ID_WORKER_STR(5);

    private final int key;

    private IdType(int key) {
        this.key = key;
    }

    public int getKey() {
        return this.key;
    }
}
```

如果我们想要让主键自增，可以设置为

```java
@TableId(type = IdType.AUTO)
private Long id;
```

但这样太麻烦了，每个实体类上都要进行设置，因此我们可以在配置文件中进行配置

```yml
mybatis-plus:
  #配置mybatis-plus映射文件的路径
  mapper-locations: classpath:/mapper/**/*.xml
  # 设置主键自增规则
  global-config:
    db-config:
      id-type: auto
```



2.3 测试

在单元测试中编写对应对应的代码，并运行

```java
@SpringBootTest
class TtsProductApplicationTests {

    @Autowired
    private BrandService brandService;

    @Test
    void contextLoads() {
        BrandEntity brandEntity = new BrandEntity();
        brandEntity.setName("测试数据");
        brandService.save(brandEntity);
        System.out.println("保存成功");
    }

}
```

运行结果，可以发现成功将数据插入了，但是数据乱码

![image-20240108205821969](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240108205821969.png)

为数据源配置添加`&characterEncoding=utf8`，指定MySQL数据库连接时使用的字符编码为UTF-8，以避免出现乱码或无法处理特殊字符的问题

```yml
spring:
  # 配置数据源相关信息
  datasource:
    username: root
    password: root
    url: jdbc:mysql://192.168.56.10:3306/tts_pms?&characterEncoding=utf8
    driver-class-name: com.mysql.cj.jdbc.Driver
```

再次运行对应单元测试，可以发现成功解析了

![image-20240108210139038](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240108210139038.png)

后面的一些增删改操作就不一一演示了。



#### 12、其他服务的CRUD功能的生成

通过代码生成器生成对应的类，然后去进行相关的配置，总的过程和前面一样，就不冗余介绍了。



#### 13、微服务 

本项目的注册中心选用`SpringCloud Alibaba`

##### 13.1、SpringCloud Alibaba简介

Spring Cloud Alibaba 致力于提供**微服务开发的****一站式解决方案**。此项目包含开发分布式应用

微服务的必需组件，方便开发者通过 Spring Cloud 编程模型轻松使用这些组件来开发分布式应用服务。

依托 Spring Cloud Alibaba，您只需要添加一些注解和少量配置，就可以将 Spring Cloud 应用接入阿里微服务解决方案，通过阿里中间件来迅速搭建分布式应用系统。

```
https://github.com/alibaba/spring-cloud-alibaba
```

##### 13.2 为什么使用SpringCloud Alibaba

对于原生的SpringCloud中的Eruka

![image-20240109212613272](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240109212613272.png)

![image-20240109212620733](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240109212620733.png)

**SpringCloud** **的几大痛点**

SpringCloud 部分组件停止维护和更新，Netflix（在Spring Cloud中，Netflix是一个开源项目集合，它提供了许多用于构建分布式系统的工具和库，这些工具和库旨在简化和加速开发人员在云环境中构建可伸缩、弹性和高可用的应用程序，其有几个核心组件：Eureka、Ribbon、Hystrix、Feign、Zuul）也停止了开源，给开发带来不便；

SpringCloud 部分环境搭建复杂，没有完善的可视化界面，我们需要大量的二次开发和定制

SpringCloud 配置复杂，难以上手，部分配置差别难以区分和合理应用



**SpringCloud Alibaba** **的优势：**

阿里使用过的组件经历了考验，性能强悍，设计合理，现在开源出来大家用

成套的产品搭配完善的可视化界面给开发运维带来极大的便利

搭建简单，学习曲线低。



**结合** **SpringCloud Alibaba** **我们最终的技术搭配方案：**

SpringCloud Alibaba - Nacos：注册中心（服务发现/注册

SpringCloud Alibaba - Nacos：配置中心（动态配置管理）

SpringCloud - Ribbon：负载均衡

SpringCloud Alibaba -OpenFeign：声明式 HTTP 客户端（调用远程服务）（原SpringCloud Netflix中的feign闭源）

SpringCloud Alibaba - Sentinel：服务容错（限流、降级、熔断）

SpringCloud - Gateway：API网关（webflux编程模式，SpringCloud最新开源的，比zule有更好）

SpringCloud - Sleuth：调用链监控

SpringCloud Alibaba - Seata：原 Fescar，即分布式事务解决方案



##### 13.3 版本选择

项目的版本号格式为 x.x.x 的形式，其中 x 的数值类型为数字，从 0 开始取值，且不限于 0~9 这个范围。项目处于孵化器阶段时，第一位版本号固定使用 0，即版本号为 0.x.x 的格式。

由于 Spring Boot 1 和 Spring Boot 2 在 Actuator 模块的接口和注解有很大的变更，且 spring-cloud-commons 从 1.x.x 版本升级到 2.0.0 版本也有较大的变更，因此我们采取跟 SpringBoot 版本号一致的版本:

- 1.5.x 版本适用于 Spring Boot 1.5.x
- 2.0.x 版本适用于 Spring Boot 2.0.x
- 2.1.x 版本适用于 Spring Boot 2.1.x
- 2.2.x 版本适用于 Spring Boot 2.2.x
- 2020.x 版本适用于 Spring Boot 2.4.x
- 2021.x 版本适用于 Spring Boot 2.6.x
- 2022.x 版本适用于 Spring Boot 3.0.x



##### 13.4 为项目添加依赖

因为我们之后每一个项目都有可能用到spring cloud alibaba的组件，因此我们在common项目中导入该依赖

```xml
<!--依赖管理-->
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>com.alibaba.cloud</groupId>
            <artifactId>spring-cloud-alibaba-dependencies</artifactId>
            <version>2.2.0.RELEASE</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
```

依赖管理及之后项目中引入的时候，就不用加版本号了，直接从父模块中继承。

 `<dependencyManagement>` 允许你在父项目中统一管理依赖版本和其他配置，确保项目中所有模块使用相同的依赖版本，并提供了更灵活的配置方式，提供的版本信息适用于当前项目以及其子模块，主要目的是将版本号的管理从子模块中移至父项目中，实现版本的统一控制。



`<type>` 元素用于定义 Maven 依赖的类型：

- `pom`：表示依赖是 Maven 的 POM 文件，它本身并不包含任何代码或资源，而是用于传递性依赖管理。
- `war`：表示依赖是一个 Web 应用程序归档文件（WAR），用于部署到 Servlet 容器。
- `ear`：表示依赖是一个企业应用程序归档文件（EAR），用于部署到 Java EE 应用服务器。
- `zip`、 `tar.gz` 等：表示依赖是一个压缩文件。
- `test-jar`：表示依赖是一个测试 JAR 文件，通常包含测试类和资源。

`<scope>` 元素用于定义 Maven 依赖的范围：

- `compile`：默认的依赖范围，表示依赖在编译、测试和运行时都可见。它会被包含在项目的 classpath 中，并且会传递给依赖的项目。
- `provided`：表示依赖在编译和测试时可见，但在运行时由容器或环境提供。比如，Java EE 容器通常会提供 Servlet 和 JSP API 等依赖，因此可以将其设置为 `provided`。
- `runtime`：表示依赖在运行时可见，但在编译和测试时不可见。这意味着它们不会被包含在项目的 classpath 中，但会传递给依赖的项目。
- `test`：表示依赖仅在测试编译和执行期间可见。它们不会被包含在项目的类路径中，也不会传递给其他依赖模块。
- `system`：表示依赖与项目一起使用，但不是通过 Maven 的依赖机制进行管理。你需要明确指定 `<systemPath>` 元素来指定依赖的路径。
- `import`：并不是常见的 Maven 依赖范围之一，而是在 `<dependencyManagement>` 中用于导入其他 POM 文件中定义的依赖范围



#### 14、微服务 —— 注册中心（Nacos）

Nacos 是阿里巴巴开源的一个更易于构建云原生应用的动态服务发现、配置管理和服务管理

平台。他是使用 java 编写。需要依赖 java 环境

Nacos 文档地址： https://nacos.io/zh-cn/docs/quick-start.html



##### 14.1、下载nacos-server（nacos服务器）

```
https://github.com/alibaba/nacos/releases
```

目录结果

![image-20240110144346240](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240110144346240.png)



##### 14.2、启动nacos-server

- 双击 bin 中的 startup.cmd 文件

- 访问 http://localhost:8848/nacos/  

  根据其中对应的ip地址进行访问

  ![image-20240110144648795](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240110144648795.png)

- 使用默认的 nacos/nacos 进行登录

![image-20240110144628072](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240110144628072.png)



##### 14.3、 将微服务注册到nacos中

①首先修改pom.xml文件，引入nacos discovery starter（nacos发现注册中心快速启动）

```xml
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
</dependency>
```

由于每个服务都需要nacos，因此将其放到common中。并且因为上面导入了spring cloud alibaba的依赖库，因此这里不用再指定版本了。

②在应用的`/src/main/resources/application.properties` 配置文件中配置 Nacos Server 地址

```
spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848
```

以`tts-coupo`项目为例

```yml
spring:
  # 配置数据源相关信息
  datasource:
    username: root
    password: root
    url: jdbc:mysql://192.168.56.10:3306/tts_sms?&useUnicode=true&characterEncoding=utf8
    driver-class-name: com.mysql.cj.jdbc.Driver
  # 配置 nacos server注册中心地址
  cloud:
    nacos:
      discovery:
        server-addr: 127.0.0.1:8848

# tomcat端口设置
server:
  port: 7000

mybatis-plus:
  #配置mybatis-plus映射文件的路径
  mapper-locations: classpath:/mapper/**/*.xml
  # 设置主键自增规则
  global-config:
    db-config:
      id-type: auto
```

③使用`@EnableDiscoveryClient`注解开启服务注册与发现功能

```java
@SpringBootApplication
@EnableDiscoveryClient
public class TtsCouponApplication {

    public static void main(String[] args) {
        SpringApplication.run(TtsCouponApplication.class, args);
    }

}
```

④为服务配置nacos注册服务中的名称

以后在nacos中就会以配置的服务名称进行注册

```yml
spring:
  # 配置数据源相关信息
  datasource:
    username: root
    password: root
    url: jdbc:mysql://192.168.56.10:3306/tts_sms?&useUnicode=true&characterEncoding=utf8
    driver-class-name: com.mysql.cj.jdbc.Driver
  # 配置 nacos server注册中心地址
  cloud:
    nacos:
      discovery:
        server-addr: 127.0.0.1:8848
  # 配置服务注册中心的应用名称
  application:
    name: tts-coupon
    
# tomcat端口设置
server:
  port: 7000

mybatis-plus:
  # 配置mybatis-plus映射文件的路径
  mapper-locations: classpath:/mapper/**/*.xml
  # 设置主键自增规则
  global-config:
    db-config:
      id-type: auto
```



##### 14.4 测试

启动coupon服务

打开nacos，查看服务注册情况，可以看到coupon服务已经成功注册进来

![image-20240110154304612](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240110154304612.png)



##### 14.5 同理，将其他微服务注册到nacos中

具体操作，略

![image-20240110155711039](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240110155711039.png)

![image-20240110155719474](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240110155719474.png)



总结：nacos注册的步骤

1、导包 nacos-discovery

2、写配置，指定 nacos 地址，指定应用的名字

3、开启服务注册发现功能@EnableDiscoveryClient





#### 14、微服务 —— openFeign

##### 14.1、总步骤说明

1、导包 openfeign

2、开启@EnableFeignClients 功能

3、编写接口，进行远程调用

```
**@FeignClient("stores")**

public interface StoreClient {

**@RequestMapping(method = RequestMethod.GET, value = "/stores")**

List<Store> getStores();**@RequestMapping(method = RequestMethod.POST, value = "/stores/{storeId}",** 

**consumes = "application/json")**

Store update(@PathVariable("storeId") Long storeId, Store store);

}
```



##### 14.2、具体步骤说明

测试会员服务（member）远程调用优惠券服务（coupon）

①在会员服务（member）中导入open-feign的依赖包

```xml
 <dependencyManagement>
     <dependencies>
         <!--spring cloud 依赖版本管理-->
         <dependency>
             <groupId>org.springframework.cloud</groupId>
             <artifactId>spring-cloud-dependencies</artifactId>
             <version>${spring-cloud.version}</version>
             <type>pom</type>
             <scope>import</scope>
         </dependency>
     </dependencies>
</dependencyManagement>

<dependencies>
	<!--openfeign 远程调用依赖-->
    <dependency>
    	<groupId>org.springframework.cloud</groupId>
    	<artifactId>spring-cloud-starter-openfeign</artifactId>
	</dependency>
</dependencies>
```

版本号可参考：

![在这里插入图片描述](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/c19c38a8a978498ab4339d8c42a0a3dd.png)

②在优惠券服务中编写对应的远程服务

```java
@RestController
@RequestMapping("coupon/coupon")
public class CouponController {
    @Autowired
    private CouponService couponService;

    //open-feign 远程接口调用测试
    @RequestMapping("/member/list")
    public R memberCoupons(){
        CouponEntity couponEntity = new CouponEntity();
        couponEntity.setCouponName("满100减10");
        return R.ok().put("coupons", Arrays.asList(couponEntity));
    }
}
```

③编写一个接口，告诉SpringCloud这个接口需要调用远程服务

在会员服务中创建一个feign包，专门用来存放声明式远程接口

创建一个远程接口类，添加@FeignClient

```java
package com.yjy.tts.member.feign;

import org.springframework.cloud.openfeign.FeignClient;

/**
 * @author banana
 * @create 2024-01-10 18:35
 */
//通过@FeignClient告诉sringcloud这个接口是一个远程客户端，需要调用远程服务
//其中的名字就是需要调用服务在服务注册中心的名称
@FeignClient("tts-coupon")
public interface CouponFeignService {
    

}

```

为了确定调用的远程接口，在接口中声明每一个方法都是调用哪一个远程服务的哪个请求

那么远程接口首先会根据@FeignClient中配置的服务名称找到对应的服务，再根据@RequestMapping中配置的访问地址找到对应的接口进行调用

```java
//通过@FeignClient告诉sringcloud这个接口是一个远程客户端，需要调用远程服务
//其中的名字就是需要调用服务在服务注册中心的名称
@FeignClient("tts-coupon")
public interface CouponFeignService {

    @RequestMapping("/coupon/coupon/member/list")
    public R memberCoupons();

}
```

④开启远程调用功能

在启动类上添加注解`@EnableFeignClients`

并通过basePackages属性指定基础包

即在服务启动的时候，会自动扫描远程接口的包，将远程接口包下所有标注了@FeignClient注解的接口生成对应的bean对象

```java
@SpringBootApplication
@EnableDiscoveryClient
@EnableFeignClients(basePackages = "com.yjy.tts.member.feign")
public class TtsMemberApplication {

    public static void main(String[] args) {
        SpringApplication.run(TtsMemberApplication.class, args);
    }

}

```

⑤在会员服务中调用该远程接口

在`MemberController`中编写对应的测试远程接口的代码

```java
@RestController
@RequestMapping("member/member")
public class MemberController {
    @Autowired
    private MemberService memberService;

    @Autowired
    CouponFeignService couponFeignService;

    @RequestMapping("/coupons")
    public R test(){
        MemberEntity memberEntity = new MemberEntity();
        memberEntity.setNickname("张三");

        R membercoupons = couponFeignService.memberCoupons();

        return R.ok().put("member", memberEntity)
                .put("coupons", membercoupons.get("coupons"));
    }
    
}
```

⑥测试远程接口

启动会员服务和优惠价服务

![image-20240110190010625](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240110190010625.png)

![image-20240110190024674](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240110190024674.png)

访问会员服务的`member/member/coupons`，从而调用远程服务，可以看到远程服务调用成功。

![image-20240110190230775](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240110190230775.png)



#### 15、微服务 —— 配置中心

如何将nacos作为配置中心，我们可以在官方文档中进行查看

```
https://nacos.io/zh-cn/docs/quick-start-spring-cloud.html
```



##### 15.1、简单应用

①首先，修改pom.xml文件，引入`nacos config starter`依赖

因为每一个服务都需要配置中心的功能，因此我们直接在common中导入即可

```xml
 <dependency>
     <groupId>com.alibaba.cloud</groupId>
     <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
 </dependency>
```

②在应用/项目的`/src/main/resources/bootstrap.properties`配置文件中配置`nacos config`元数据 

`bootstrap.properties`该文件是springboot中的，且其加载的优先级要高于`application.properties`

![image-20240110191920498](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240110191920498.png)

```properties
# 当前应用/项目名称
spring.application.name=tts-coupon
# nacos 配置中心服务地址
spring.cloud.nacos.config.server-addr=127.0.0.1:8848
```

③完成以上两个步骤后，应用程序将从Nacos Server获得外部化的配置，并将其放入Spring环境的PropertySources中。我们使用@Value注释将相应的配置注入SampleController的userName和age字段，并添加@RefreshScope以启用动态刷新

```java
@RestController
@RequestMapping("coupon/coupon")
@RefreshScope
public class CouponController {
    @Autowired
    private CouponService couponService;

    @Value("${coupon.user.name}")
    String name;

    @Value("${coupon.user.age}")
    int age;

    @RequestMapping("/test")
    public R test(){
        return R.ok().put("name",name).put("age", age);
    }
}
```



④我们首先在`application.properties`配置

```properties
coupon.user.name=yjy
coupon.user.age=18
```

启动服务，访问对应接口，查看结果

![image-20240110193516952](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240110193516952.png)

⑤在配置中心进行配置

其中Data Id（数据集）就是我们在`bootstrap.properties`中配置的应用名称

默认规则 应用名.properties

![image-20240110194220422](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240110194220422.png)

重新启动服务，访问对应接口，查看结果

![image-20240110194237150](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240110194237150.png)

通过@RefreshScope注解，当我们在配置中心修改对应的配置信息后，可以动态更新项目中的配置信息，而不用重新启动项目,实现动态获取配置。

并且由上可以看出，当配置中心和当前应用的配置文件中都配置了相同的项，优先使用配置中心的配置。



⑥补充：

Nacos Config数据结构：

Nacos Config 主要通过 dataId 和 group 来唯一确定一条配置。

Nacos Client 从 Nacos Server 端获取数据时，调用的是此接口 ConfigService.getConfig(String dataId, String group, long timeoutMs)



Spring Cloud应用获取数据：

dataID：

在 Nacos Config Starter 中，dataId 的拼接格式如下

${prefix} - ${spring.profiles.active} . ${file-extension} prefix 默认为 spring.application.name

的值，也可以通过配置项 spring.cloud.nacos.config.prefix 来配置。

spring.profiles.active 即为当前环境对应的 profile

注意，当 activeprofile 为空时，对应的连接符 - 也将不存在，dataId 的拼接格式变成

${prefix}.${file-extension}

file-extension 为配置内容的数据格式，可以通过配置项

spring.cloud.nacos.config.file-extension 来配置。 目前只支持 properties 类型。

Group：

Group 默认为 DEFAULT_GROUP，可以通过 spring.cloud.nacos.config.group 配置。



##### 15.2、细节

1）命名空间

目的：配置隔离

默认：public(保留空间)；默认新增的所有配置都在public空间

命名空间应用场景如下：

1、开发，测试，生词：利用命名空间来做环境隔离

注意：在bootstrap.properties：配置上，需要使用哪个命名空间下的配置声明如下

```
spring.cloud.nacos.config.namespace=7e1ccf68-c069-4910-90e5-275509d88e2a（命名空间id）
```

2、每一个微服务之间互相隔离配置，每一个微服务都创建自己的命名空间，只加载自己命名空间下的所有配置



2）配置集

即所有配置的集合

一组相关或者不相关的配置项的集合称为配置集。在系统中，一个配置文件通常就是一个配置集，包含了系统各个方面的配置。例如，一个配置集可能包含了数据源、线程池、日志级别等配置项。

3）配置集ID

即Data ID， 类似文件名

4）配置分组

Nacos 中的一组配置集，是组织配置的维度之一。通过一个有意义的字符串（如 Buy 或Trade ）对配置集进行分组，从而区分 Data ID 相同的配置集。当您在 Nacos 上创建一个配置时，如果未填写配置分组的名称，则配置分组的名称默认采用 DEFAULT_GROUP 。配置分组的常见场景：不同的应用或组件使用了相同的配置类型，如 database_url 配置和MQ_topic 配置。

默认偶有的配置集都属于：DEFAULT_GROUP



最好使用方式：

每个微服务创建自己的命名空间。使用配置分组区分环境，是dev、test、prod

我们这里以`coupon`为例

![image-20240110203019127](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240110203019127.png)







##### 15.3、加载多配置文件

我们一般不会把所有的配置都写在一个配置文件中，这样会很乱

我们可以将配置文件的内容分为数据源、mybatis、其他，专门为他们提供一个配置文件

![image-20240110203311224](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240110203311224.png)

![image-20240110203317777](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240110203317777.png)

![image-20240110203325915](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240110203325915.png)



在bootstrap.properties中进行扩展配置

```properties
# 当前应用/项目名称
spring.application.name=tts-coupon
# nacos 配置中心服务地址
spring.cloud.nacos.config.server-addr=127.0.0.1:8848
# 命名空间
spring.cloud.nacos.config.namespace=a20064b6-09ce-4ce4-88fd-e6bd170557cd
# 分组
spring.cloud.nacos.config.group=dev

# 扩展配置
# 数据源配置文件
spring.cloud.nacos.config.extension-configs[0].data-id=datasource.yml
spring.cloud.nacos.config.extension-configs[0].group=dev
# 配置中心的配置修改后刷新微服务（默认false）
spring.cloud.nacos.config.extension-configs[0].refresh=true

# mybatis配置
spring.cloud.nacos.config.extension-configs[1].data-id=mybatis.yml
spring.cloud.nacos.config.extension-configs[1].group=dev
spring.cloud.nacos.config.extension-configs[1].refresh=true

# 其他配置
spring.cloud.nacos.config.extension-configs[2].data-id=other.yml
spring.cloud.nacos.config.extension-configs[2].group=dev
spring.cloud.nacos.config.extension-configs[2].refresh=true
```

"spring.cloud.nacos.config.ext-config"已经被废弃，建议使用“spring.cloud.nacos.config.extension-configs”



看到nacos启动的时候，读取配置成功

![image-20240110204011328](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240110204011328.png)





补充：

1.微服务任何配置信息，任何配置文件都可以放在配置中心

2.只需要在bootstrap.properties说明加载配置中心哪些配置文件即可

3.@Value @ConfigurationProperties

以前SpringBoot任何方法从配置文件中获取值，都能使用，配置中心有的优先使用配置中心的配置

4、为什么要在`bootstrap.properties`进行配置

其实在application.yml中配置也是可以的，如下所示

```yml
spring:
  # 配置数据源相关信息
  datasource:
    username: root
    password: root
    url: jdbc:mysql://192.168.56.10:3306/tts_sms?&useUnicode=true&characterEncoding=utf8
    driver-class-name: com.mysql.cj.jdbc.Driver
  # 配置 nacos server注册中心地址
  cloud:
    nacos:
      discovery:
        server-addr: 127.0.0.1:8848
      config:
        server-addr: 127.0.0.1:8848
        namespace: a20064b6-09ce-4ce4-88fd-e6bd170557cd
        extension-configs:
          - data-id: datasource.yml
            group: dev
            refresh: true
          - data-id: mybatis.yml
            group: dev
            refresh: true
          - data-id: other.yml
            group: dev
            refresh: true

  # 配置服务注册中心的应用名称
  application:
    name: tts-coupon
    
# tomcat端口设置
server:
  port: 7000

```

`bootstrap.properties` 是一个特殊的配置文件，它的加载顺序早于 `application.properties` 或 `application.yml`。它通常用于加载一些在应用程序启动前就需要使用的配置项，例如连接 Nacos 服务端的配置信息。

将 Nacos 配置中心的配置放在 `bootstrap.properties` 而不是直接放在 `application.yml` 是为了确保配置能够在应用程序启动时就被加载和使用。这涉及到 Spring Boot 的配置加载机制。

Spring Boot 在启动过程中会先加载 `bootstrap.properties` 文件，然后再加载 `application.yml` 或 `application.properties` 文件。这个分离的机制允许我们在应用程序的早期阶段就可以加载一些关键的配置，比如配置中心的相关配置。

将 Nacos 配置中心的配置放在 `bootstrap.properties` 中有以下几个好处：

1. 优先级高：`bootstrap.properties` 文件的加载优先级高于 `application.yml` 文件，这意味着配置中心的配置能够在其他配置之前被加载和使用，确保了配置的优先级。
2. 提前加载：将配置中心的配置放在 `bootstrap.properties` 中可以确保它们在应用程序的早期阶段就被加载。这对于一些基础配置，比如数据源、日志、分布式锁等非常重要。
3. 避免循环依赖：如果将配置中心的配置放在 `application.yml` 中，并且应用程序的某些组件依赖于这些配置，可能会导致循环依赖的问题。将配置中心的配置放在 `bootstrap.properties` 中可以避免这种问题。

需要注意的是，`bootstrap.properties` 文件中的配置项通常比较少，主要用于引导应用程序的启动过程。而其他的应用程序配置则可以放在 `application.yml` 或 `application.properties` 文件中。

总之，将 Nacos 配置中心的配置放在 `bootstrap.properties` 中是为了确保配置能够在应用程序早期被加载和使用，并且避免一些潜在的问题。这是 Spring Boot 的一种最佳实践。



##### 15.4、原理

①自动注入：

NacosConfigStarter 实现了 org.springframework.cloud.bootstrap.config.PropertySourceLocator

接口，并将优先级设置成了最高。

在 Spring Cloud 应用启动阶段，会主动从 Nacos Server 端获取对应的数据，并将获取到的

数据转换成 PropertySource 且注入到 Environment 的 PropertySources 属性中，所以使用

@Value 注解也能直接获取 Nacos Server 端配置的内容。



②动态刷新

Nacos Config Starter 默认为所有获取数据成功的 Nacos 的配置项添加了监听功能，在监听

到服务端配置发生变化时会实时触发

org.springframework.cloud.context.refresh.ContextRefresher 的 refresh 方法 。

如果需要对 Bean 进行动态刷新，请参照 Spring 和 Spring Cloud 规范。推荐给类添加@RefreshScope **或** @ConfigurationProperties 注解



③小结：

1)、微服务任何配置信息，任何配置文件都可以放在配置中心；

2)、只需要在bootstrap.properties中，说明加载配置中心的哪些配置文件即可；

3)、@Value, @ConfigurationProperties。都可以用来获取配置中心中所配置的信息；

4)、配置中心有的优先使用配置中心中的，没有则使用本地的配置。



#### 16、微服务——网关

使用Spring Cloud提供的gateway来作为网关的功能。

##### 16.1、简介

网关作为流量的入口，常用功能包括路由转发、权限校验、限流控制等。而 springcloud gateway

作为 SpringCloud 官方推出的第二代网关框架，取代了 Zuul 网关（Zuul2.0是SpringCloud Netflix旗下的，没有应用到SpringCloud，SpringCloud官方自己创建了一个网关gateway）。

网关请求数量，可以看出gateway的优势：

![image-20240115210646343](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240115210646343.png)

网关提供 API 全托管服务，丰富的 API 管理功能，辅助企业管理大规模的 API，以降低管理成本和安全风险，包括协议适配、协议转发、安全策略、防刷、流量、监控日志等功能。

Spring Cloud Gateway 旨在提供一种简单而有效的方式来对 API 进行路由，并为他们提供切面，例如：安全性，监控/指标 和弹性等

相关文档：

```
https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.1.3.RELEASE/single/spring-cloud-gateway.html
```



Spring Cloud Gateway 特点：

- 基于 Spring5，支持响应式编程和 SpringBoot2.0
- 支持使用任何请求属性进行路由匹配
- 特定于路由的断言和过滤器
- 集成 Hystrix 进行断路保护
- 集成服务发现功能
- 易于编写 Predicates 和 Filters
- 支持请求速率限制
- 支持路径重写



为什么使用 API 网关？

API 网关出现的原因是微服务架构的出现，不同的微服务一般会有不同的网络地址，而外部

客户端可能需要调用多个服务的接口才能完成一个业务需求，如果让客户端直接与各个微服

务通信，会有以下的**问题**：

- 客户端会多次请求不同的微服务，增加了客户端的复杂性。
- 存在跨域请求，在一定场景下处理相对复杂。
- 认证复杂，每个服务都需要独立认证。
- 难以重构，随着项目的迭代，可能需要重新划分微服务。例如，可能将多个服务合并成一个或者将一个服务拆分成多个。如果客户端直接与微服务通信，那么重构将会很难实施。
- 某些微服务可能使用了防火墙 / 浏览器不友好的协议，直接访问会有一定的困难。

以上这些问题可以借助 API 网关解决。API 网关是介于客户端和服务器端之间的中间层，

所有的外部请求都会先经过 API 网关这一层。也就是说，API 的实现方面更多的考虑业务

逻辑，而安全、性能、监控可以交由 API 网关来做，这样既提高业务灵活性又不缺安全性：

使用 API 网关后的**优点**如下：

- 易于监控。可以在网关收集监控数据并将其推送到外部系统进行分析。
- 易于认证。可以在网关上进行认证，然后再将请求转发到后端的微服务，而无须在每个微服务中进行认证。
- 减少了客户端与各个微服务之间的交互次数。



##### 16.2、核心概念

- 路由。路由是网关最基础的部分，路由信息有一个 ID、一个目的 URL、一组断言和一组Filter 组成。如果断言路由为真，则说明请求的 URL 和配置匹配
- 断言。Java8 中的断言函数。Spring Cloud Gateway 中的断言函数输入类型是 Spring5.0 框架中的 ServerWebExchange。Spring Cloud Gateway 中的断言函数允许开发者去定义匹配来自于 http request 中的任何信息，比如请求头和参数等。
- 过滤器。一个标准的 Spring webFilter。Spring cloud gateway 中的 filter 分为两种类型的Filter，分别是 Gateway Filter 和 Global Filter。过滤器 Filter 将会对请求和响应进行修改处理



工作原理：

![image-20240115211638774](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240115211638774.png)

客户端发送请求给网关，弯管 HandlerMapping 判断是否请求满足某个路由，满足就发给网

关的 WebHandler。这个 WebHandler 将请求交给一个过滤器链，请求到达目标服务之前，会

执行所有过滤器的 pre 方法。请求到达目标服务处理之后再依次执行所有过滤器的 post 方

法，一句话：满足某些断言（predicates）就路由到指定的地址（uri），使用指定的过滤器（filter）



相关的过滤器的配置方式可以在官方文档中进行查看和学习。



##### 16.3、使用

①创建一个Module，作为我们的网关服务

![image-20240115212242371](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240115212242371.png)

选中网关服务

![image-20240115212314911](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240115212314911.png)

创建对应的服务

![image-20240115212807051](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240115212807051.png)

②pom配置文件的配置

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.2.1.RELEASE</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>
    <groupId>com.yjy.tts</groupId>
    <artifactId>tts-gateway</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>tts-gateway</name>
    <description>API网关</description>
    <properties>
        <java.version>8</java.version>
        <spring-cloud.version>Hoxton.RELEASE</spring-cloud.version>
    </properties>

    <dependencyManagement>
        <dependencies>
            <!--spring cloud 依赖版本管理-->
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>${spring-cloud.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>

    <dependencies>
        <!--①数据源相关-->

        <!--②其他依赖-->
        <!--gateway网关-->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-gateway</artifactId>
        </dependency>
        <!--单元测试-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>

        <!--③其他服务/项目相关依赖-->
        <dependency>
            <groupId>com.yjy.tts</groupId>
            <artifactId>tts-common</artifactId>
            <version>0.0.1-SNAPSHOT</version>
        </dependency>

    </dependencies>


    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>

</project>

```



③开启网关的服务的注册和发现

通过注解`@EnableDiscoveryClient`打开服务的注册和发现

```java
@EnableDiscoveryClient
@SpringBootApplication
public class TtsGatewayApplication {

    public static void main(String[] args) {
        SpringApplication.run(TtsGatewayApplication.class, args);
    }

}

```

在application.properties配置服务的注册地址

```
# 服务名称
spring.application.name=tts-gateway
# 注册中心地址
spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848
# 端口号
server.port=88
```

配置中心服务配置

在配置中心，为网关创建对应的命名空间

![image-20240115213351642](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240115213351642.png)

![image-20240115213456301](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240115213456301.png)

![image-20240115213505506](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240115213505506.png)



在bootstrap.properties中进行配置

```
# 服务名称
spring.application.name=tts-gateway
# 配置中心地址
spring.cloud.nacos.config.server-addr=127.0.0.1:8848
# 配置中心命名空间
spring.cloud.nacos.config.namespace=c3f99ebb-170b-4886-88cd-29f6966c5ab1
```



④排除数据库相关的配置

```
@EnableDiscoveryClient
@SpringBootApplication(exclude={DataSourceAutoConfiguration.class})
public class TtsGatewayApplication {

    public static void main(String[] args) {
        SpringApplication.run(TtsGatewayApplication.class, args);
    }

}

```



⑤启动网关

![image-20240115214025293](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240115214025293.png)



⑥测试

配置相关的网关转发断言和url信息，创建一个application.yml

```
spring:
  cloud:
    gateway:
      routes:
        # 断言表示请求有baidu，url就跳转到https://www.baidu.com
        - id: test_route
          uri: https://www.baidu.com
          predicates:
            - Query=url,baidu

        # 断言表示请求有qq，url就跳转到https://www.qq.com
        - id: qq_route
          uri: https://www.qq.com
          predicates:
            - Query=url,qq
```



请求路径：

```
http://localhost:88/hello?url=qq
```

请求结果：

![image-20240115214835682](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240115214835682.png)



请求路径：

```
http://localhost:88/?url=baidu
```

请求结果：

![image-20240115214910254](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240115214910254.png)



#### 17、商品服务-API-三级分类

##### 17.1、三级分类概念

对于电商平台中的商品的分配一共可以分成如下三级

![image-20240123211420589](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240123211420589.png)

##### 17.2、准备工作

其对应的表是`tts_pms`下的`pms_category`表

```sql
CREATE TABLE `pms_category` (
  `cat_id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '分类id',
  `name` char(50) DEFAULT NULL COMMENT '分类名称',
  `parent_cid` bigint(20) DEFAULT NULL COMMENT '父分类id',
  `cat_level` int(11) DEFAULT NULL COMMENT '层级',
  `show_status` tinyint(4) DEFAULT NULL COMMENT '是否显示[0-不显示，1显示]',
  `sort` int(11) DEFAULT NULL COMMENT '排序',
  `icon` char(255) DEFAULT NULL COMMENT '图标地址',
  `product_unit` char(50) DEFAULT NULL COMMENT '计量单位',
  `product_count` int(11) DEFAULT NULL COMMENT '商品数量',
  PRIMARY KEY (`cat_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='商品三级分类';
```

从资料中获取相关的数据，进行导入，导入后登机结果如下所示：

![image-20240123212112775](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240123212112775.png)

##### 17.3、查询-递归树形结构数据获取

① 控制层

```java
/**
 * 商品三级分类
 *
 * @author yjy
 * @email 2322092442@qq.com
 * @date 2024-01-03 21:11:20
 */
@RestController
@RequestMapping("product/category")
public class CategoryController {
    @Autowired
    private CategoryService categoryService;


    @RequestMapping("/list/tree")
    public R list(){

        List<CategoryEntity> entities = categoryService.listWithTree();

        return R.ok().put("data", entities);
    }
    
}

```

② 业务层

```java
public interface CategoryService extends IService<CategoryEntity> {

    /**
     * 以树形结构返回所有的分类与子分类
     * @return 树形结构的商品分类信息
     */
    List<CategoryEntity> listWithTree();
}

```



```java
@Service("categoryService")
public class CategoryServiceImpl extends ServiceImpl<CategoryMapper, CategoryEntity> implements CategoryService {

    @Override
    public List<CategoryEntity> listWithTree() {
        //1. 获取所有的商品的分类信息
        List<CategoryEntity> allCategory = baseMapper.selectList(null);

        //2. 递归构造商品分类的树形结构
        List<CategoryEntity> level1Category = allCategory.stream()
                // 过滤出所有父级商品分类信息（parentCid == 0）
                .filter(r -> r.getParentCid().equals(0L))
                // 设置当前商品分类的子分类
                .map(category -> {
                    category.setChildren(getCategoryChildrens(category, allCategory));
                    return category;
                })
                //根据商品分类的category字段进行排序
                .sorted((category1, category2) -> {
                    return (ObjectUtils.isNull(category1.getSort()) ? 0 : category1.getSort()) -
                            (ObjectUtils.isNull(category2.getSort()) ? 0 : category2.getSort());
                })
                // 转化为列表
                .collect(Collectors.toList());
        return level1Category;
    }

    /**
     * 递归获取当前商品分类的子分类信息
     * @param root 当前商品分类信息
     * @param all 所有的商品分类信息
     * @return 当前商品分类的子分类信息
     */
    private List<CategoryEntity> getCategoryChildrens(CategoryEntity root, List<CategoryEntity> all){
        //获取以root为父级的所有商品分类信息
        List<CategoryEntity> childrenCategory = all.stream()
                // 过滤出所有以root为父级商品的分类信息
                .filter(category -> category.getParentCid().equals(root.getCatId()))
                // 设置当前商品分类的子分类
                .map(category -> {
                    category.setChildren(getCategoryChildrens(category, all));
                    return category;
                })
                //根据商品分类的category字段进行排序
                .sorted((category1, category2) -> {
                    return (ObjectUtils.isNull(category1.getSort()) ? 0 : category1.getSort()) -
                            (ObjectUtils.isNull(category2.getSort()) ? 0 : category2.getSort());
                })
                // 转化为列表
                .collect(Collectors.toList());

        return childrenCategory;
    }
}
```



③ 数据操作层

/

④ 运行结果

![image-20240123222000145](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240123222000145.png)



##### 17.4、删除-树形结构数据逻辑删除

1.配置mybatis-plus的全局逻辑删除规则（采用逻辑删除，而不是物理删除）

如果和默认配置的一样，就可以不用配置

```yml
mybatis-plus:
  global-config:
    db-config:
      logic-delete-field: flag # 全局逻辑删除的实体字段名(since 3.3.0,配置后可以忽略不配置步骤2)
      logic-delete-value: 1 # 逻辑已删除值(默认为 1)
      logic-not-delete-value: 0 # 逻辑未删除值(默认为 0)
```

为了学习，我们在配置中心进行配置

![image-20240215003628097](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240215003628097.png)

```yml
mybatis-plus:
  # 配置mybatis-plus映射文件的路径
  mapper-locations: classpath:/mapper/**/*.xml
  # 设置主键自增规则
  global-config:
    db-config:
      id-type: auto
      logic-delete-value: 1
      logic-not-delete-value: 0
```

2.配置逻辑删除的组件Bean

3.1.1版本开始就不用了，我们当前使用的是3.2.0版本

```xml
<dependency>
    <groupId>com.baomidou</groupId>
    <artifactId>mybatis-plus-boot-starter</artifactId>
    <version>3.2.0</version>
</dependency>
```

配置Bean

```java
@Bean
public ISqlInjector sqlInjector(){
	return new LogicSqlInjector();
}
```

3.在实体类字段上添加`@TableLogic`注解

在分类实体类中，指定showStatus为逻辑删除的字段，并且通过注解的属性手动指定删除是0，不删除是1

```java
@Data
@TableName("pms_category")
public class CategoryEntity implements Serializable {
	private static final long serialVersionUID = 1L;

	/**
	 * 是否显示[0-不显示，1显示]
	 */
	@TableLogic(value = "1", delval = "0")
	private Integer showStatus;
	
}

```

4.为了测试，将日志的打印级别设置为debug

![image-20240215004701137](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240215004701137.png)

```yml
# 设置日志打印级别
logging:
  level:
    com.yjy.tts: debug
```



删除前数据：

![image-20240215005156543](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240215005156543.png)

发送删除请求：

![image-20240215005220138](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240215005220138.png)

执行打印的sql语句：

![image-20240215005316495](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240215005316495.png)

结果：

![image-20240215005335126](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240215005335126.png)

##### 17.5、新增-树形结构数据逻辑新增

控制层：

```java
package com.yjy.tts.product.controller;

import java.util.Arrays;
import java.util.List;
import java.util.Map;


import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import com.yjy.tts.product.entity.CategoryEntity;
import com.yjy.tts.product.service.CategoryService;
import com.yjy.common.utils.PageUtils;
import com.yjy.common.utils.R;

/**
 * 商品三级分类
 *
 * @author yjy
 * @email 2322092442@qq.com
 * @date 2024-01-03 21:11:20
 */
@RestController
@RequestMapping("product/category")
public class CategoryController {

    @Autowired
    private CategoryService categoryService;

    //以树形结构返回所有的分类与子分类
    @GetMapping("/list/tree")
    public R listCategory(){
        List<CategoryEntity> entities = categoryService.listWithTree();
        return R.ok().put("data", entities);
    }

    //删除指定ids的分类数据
    @PostMapping("/delete")
    public R deleteCategory(@RequestBody List<Long> catIds){
        categoryService.removeCategoryByIds(catIds);
        return R.ok();
    }

    //保存分类
    @PostMapping("/save")
    public R saveCategory(@RequestBody CategoryEntity categoryEntity){
        categoryService.save(categoryEntity);
        return R.ok();
    }

}

```

业务层：

无

数据层：

无



##### 17.6、修改-树形结构数据逻辑修改

1、获取单个结点的信息，用于回显

控制层：

```java
package com.yjy.tts.product.controller;

import java.util.Arrays;
import java.util.List;
import java.util.Map;


import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import com.yjy.tts.product.entity.CategoryEntity;
import com.yjy.tts.product.service.CategoryService;
import com.yjy.common.utils.PageUtils;
import com.yjy.common.utils.R;

/**
 * 商品三级分类
 *
 * @author yjy
 * @email 2322092442@qq.com
 * @date 2024-01-03 21:11:20
 */
@RestController
@RequestMapping("product/category")
public class CategoryController {

    @Autowired
    private CategoryService categoryService;

    //以树形结构返回所有的分类与子分类
    @GetMapping("/list/tree")
    public R listCategory(){
        List<CategoryEntity> entities = categoryService.listWithTree();
        return R.ok().put("data", entities);
    }

    //删除指定ids的分类数据
    @PostMapping("/delete")
    public R deleteCategory(@RequestBody List<Long> catIds){
        categoryService.removeCategoryByIds(catIds);
        return R.ok();
    }

    //保存分类
    @PostMapping("/save")
    public R saveCategory(@RequestBody CategoryEntity categoryEntity){
        categoryService.save(categoryEntity);
        return R.ok();
    }

    //获取单个分类信息
    @GetMapping("/info/{catId}")
    public R getCateGoryInfoByCatId(@PathVariable("catId") Long catId){
        CategoryEntity category = categoryService.getById(catId);
        return R.ok().put("data", category);
    }
}

```

业务层：无

数据层：无



2、修改接口

控制层：

```java
//修改分类
@PostMapping("/update")
public R update(@RequestBody CategoryEntity category){
    categoryService.updateById(category);
    return R.ok();
}
```

业务层：无

数据层：无

##### 17.7、拖拽数据的同步

监听拖拽成功的动作：更新拖拽节点的父亲节点id（parent_id）、层级（cat_level）、排序（sort）

1、批量修改

控制层：

```java
//批量修改分类排序
@PostMapping("/update/sort")
public R updateCategorySort(@RequestBody List<CategoryEntity> category){
    categoryService.updateBatchById(category);
    return R.ok();
}
```

业务层：无

数据层：无





#### 18、商品服务-品牌管理功能

##### 18.1、逆向工程生成前后端代码

修改代码生成器连接的数据库为商品服务

```xml
spring:
  datasource:
    type: com.alibaba.druid.pool.DruidDataSource
    #MySQL配置
    driverClassName: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://192.168.56.10:3306/tts_pms?useUnicode=true&characterEncoding=UTF-8&useSSL=false&serverTimezone=Asia/Shanghai
    username: root
    password: root
```

修改`generator.properties`中的一些配置

```yml
#代码生成器，配置信息

mainPath=com.yjy
#包名
package=com.yjy.tts
moduleName=product
#作者
author=yjy
#Email
email=2322092442@qq.com
#表前缀(类名不会包含表前缀)
tablePrefix=pms_

```

UI中生成代码

![image-20240224141218355](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240224141218355.png)

结果：

![image-20240224141714818](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240224141714818.png)



##### 18.2、效果优化与快速显示开关

更新显示功能的接口使用代码器生成的update即可

```java
/**
 * 修改
 */
@RequestMapping("/update")
public R update(@RequestBody BrandEntity brand){
    brandService.updateById(brand);
    return R.ok();
}
```

##### 18.3、云存储开通与使用（附件上传）

**(1) 第三方调用微服务的创建**

创建一个新的模块

![image-20240224232159228](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240224232159228.png)

![image-20240224232230927](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240224232230927.png)

修改其配置文件：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.2.1.RELEASE</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>
    <groupId>com.yjy.tts</groupId>
    <artifactId>tts-third-party</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>tts-third-party</name>
    <description>第三方调用服务</description>

    <properties>
        <java.version>8</java.version>
        <spring-cloud.version>Hoxton.RELEASE</spring-cloud.version>
        <spring-clound-alibaba.version>2.1.0.RELEASE</spring-clound-alibaba.version>
    </properties>

    <dependencies>
        <!--①数据源相关-->

        <!--②其他依赖-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <!--阿里云对象存储的starter依赖-->
        <dependency>
            <groupId>com.alibaba.cloud</groupId>
            <artifactId>spring-cloud-starter-alicloud-oss</artifactId>
        </dependency>

        <!--③其他服务/项目相关依赖-->
        <dependency>
            <groupId>com.yjy.tts</groupId>
            <artifactId>tts-common</artifactId>
            <version>0.0.1-SNAPSHOT</version>
        </dependency>
    </dependencies>

    <!--依赖版本管理-->
    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>com.alibaba.cloud</groupId>
                <artifactId>spring-cloud-alibaba-dependencies</artifactId>
                <version>${spring-clound-alibaba.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>


    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>

</project>

```

将其注册到注册中心和配置中心



配置中心创建命名空间

![image-20240224233041751](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240224233041751.png)

![image-20240224233059022](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240224233059022.png)



在该命名空间下，创建一个oss的配置：

![image-20240224233640110](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240224233640110.png)

```yml
spring:
  cloud:
    # 配置 nacos server注册中心地址
    nacos:
      discovery:
        server-addr: 127.0.0.1:8848
    # 配置阿里云存储对象的accessKey、secretKey和endpoint
    alicloud:
      access-key: LTAI5tHuankvMPQUGd8SHDnZ
      secret-key: js03wmaZMbFUtWteo807C0GaeH8Twf
      oss:
        endpoint: oss-cn-hangzhou.aliyuncs.com
        bucket: tts-platform-oss
```

![image-20240224233657236](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240224233657236.png)



在微服务中进行配置中心的配置，创建一个`bootstrap.properties`,进行相关内容的配置

![image-20240224233830307](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240224233830307.png)

```properties
# 当前应用/项目名称
spring.application.name=tts-third-party
# nacos 配置中心服务地址
spring.cloud.nacos.config.server-addr=127.0.0.1:8848
# 命名空间
spring.cloud.nacos.config.namespace=1b39c644-ee68-43ce-9619-ade2d1ef7648
# 默认配置
# 分组
spring.cloud.nacos.config.group=dev
# 指定前缀名称
spring.cloud.nacos.config.prefix=tts-third-party
# 指定后缀为yaml
spring.cloud.nacos.config.file-extension=yml

# 扩展配置
# 阿里云对象存储配置文件
spring.cloud.nacos.config.ext-config[0].data-id=oss.yml
spring.cloud.nacos.config.ext-config[0].group=dev
# 配置中心的配置修改后刷新微服务（默认false）
spring.cloud.nacos.config.ext-config[0].refresh=true

```



在注册中心配置默认的信息

创建`tts-third-party.yml`

![image-20240224234138720](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240224234138720.png)

```yml
spring:
    cloud:
        nacos:
            discovery:
                # 注册中心地址
                server-addr: 127.0.0.1:8848
    application:
        # 微服务名称
        name:   tts-third-party

# 指定端口
server:
    port: 30000
```





最后我们这个项目不许要连接数据库，因此需要把mybatis快速启动依赖排除掉：

```xml
<dependency>
    <groupId>com.yjy.tts</groupId>
    <artifactId>tts-common</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <exclusions>
        <exclusion>
            <groupId>com.baomidou</groupId>
            <artifactId>mybatis-plus-boot-starter</artifactId>
        </exclusion>
    </exclusions>
</dependency>
```



在启动类上添加服务的注册发现注解

```java
package com.yjy.tts.thirdparty;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;

@EnableDiscoveryClient
@SpringBootApplication
public class TtsThirdPartyApplication {

    public static void main(String[] args) {
        SpringApplication.run(TtsThirdPartyApplication.class, args);
    }

}

```



启动服务，启动成功

![image-20240224234934562](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240224234934562.png)





**（2）OSS获取服务端签名应用服务器核心代码解析**

官方文档见：

```
https://help.aliyun.com/zh/oss/use-cases/java-1?spm=a2c4g.11186623.0.i10#concept-ahk-rfz-2fb
```

应用服务器源码包含了签名直传服务以及上传回调服务两个功能。



- 签名只传服务

创建一个控制层`OssController`

![image-20240225152427675](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240225152427675.png)

```java
package com.yjy.tts.thirdparty.controller;

import com.aliyun.oss.OSS;
import com.aliyun.oss.OSSClient;
import com.aliyun.oss.common.utils.BinaryUtil;
import com.aliyun.oss.model.MatchMode;
import com.aliyun.oss.model.PolicyConditions;
import com.yjy.common.utils.R;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.Date;
import java.util.LinkedHashMap;
import java.util.Map;

/**
 * @author banana
 * @create 2024-02-24 23:58
 */
@RestController
@RequestMapping("")
public class OssController {

    @Autowired
    private OSS ossClient;

    @Value("${spring.cloud.alicloud.oss.endpoint}")
    private String endpoint;

    @Value("${spring.cloud.alicloud.oss.bucket}")
    private String bucket;

    @Value("${spring.cloud.alicloud.access-key}")
    private String accessId;

    @GetMapping("/oss/policy")
    public R getPlocy(){


        // 填写Host名称，格式为https://bucketname.endpoint。
        String host = "https://" + bucket + "." + endpoint;
        // 设置上传回调URL，即回调服务器地址，用于处理应用服务器与OSS之间的通信。OSS会在文件上传完成后，把文件上传信息通过此回调URL发送给应用服务器。
        // String callbackUrl = "https://192.168.0.0:8888";
        // 设置上传到OSS文件的前缀，可置空此项。置空后，文件将上传至Bucket的根目录下。
        // 统一以日期为格式，放在指定的日期下面
        String format = LocalDate.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd"));
        String dir = format + "/";

        // 响应参数
        Map<String, String> respMap = null;

        try {
            long expireTime = 30;
            long expireEndTime = System.currentTimeMillis() + expireTime * 1000;
            Date expiration = new Date(expireEndTime);
            // PostObject请求最大可支持的文件大小为5 GB，即CONTENT_LENGTH_RANGE为5*1024*1024*1024。
            PolicyConditions policyConds = new PolicyConditions();
            policyConds.addConditionItem(PolicyConditions.COND_CONTENT_LENGTH_RANGE, 0, 1048576000);
            policyConds.addConditionItem(MatchMode.StartWith, PolicyConditions.COND_KEY, dir);

            String postPolicy = ossClient.generatePostPolicy(expiration, policyConds);
            byte[] binaryData = postPolicy.getBytes("utf-8");
            String encodedPolicy = BinaryUtil.toBase64String(binaryData);
            String postSignature = ossClient.calculatePostSignature(postPolicy);

            respMap = new LinkedHashMap<String, String>();
            respMap.put("accessid", accessId);
            respMap.put("policy", encodedPolicy);
            respMap.put("signature", postSignature);
            respMap.put("dir", dir);
            respMap.put("host", host);
            respMap.put("expire", String.valueOf(expireEndTime / 1000));
            // respMap.put("expire", formatISO8601Date(expiration));

            // 跨域方式响应出去
            /*JSONObject jasonCallback = new JSONObject();
            jasonCallback.put("callbackUrl", callbackUrl);
            jasonCallback.put("callbackBody",
                    "filename=${object}&size=${size}&mimeType=${mimeType}&height=${imageInfo.height}&width=${imageInfo.width}");
            jasonCallback.put("callbackBodyType", "application/x-www-form-urlencoded");
            String base64CallbackBody = BinaryUtil.toBase64String(jasonCallback.toString().getBytes());
            respMap.put("callback", base64CallbackBody);

            JSONObject ja1 = JSONObject.fromObject(respMap);
            // System.out.println(ja1.toString());
            response.setHeader("Access-Control-Allow-Origin", "*");
            response.setHeader("Access-Control-Allow-Methods", "GET, POST");
            response(request, response, ja1.toString());*/

        } catch (Exception e) {
            // Assert.fail(e.getMessage());
            System.out.println(e.getMessage());
        } finally {
            ossClient.shutdown();
        }

        return R.ok().put("data", respMap);
    }
}

```



这里要注意注入的`ossClient`需要是接口类型`OSS`，不能用实现类`OSSClient`，因为在其自动配置类`OssContextAutoConfiguration`中可以看到，其注册Bean返回的是接口类型：

```java
EnableConfigurationProperties({OssProperties.class})
@ImportAutoConfiguration({AliCloudContextAutoConfiguration.class})
public class OssContextAutoConfiguration {
    public OssContextAutoConfiguration() {
    }

    @ConditionalOnMissingBean
    @Bean
    public OSS ossClient(AliCloudProperties aliCloudProperties, OssProperties ossProperties) {    
        // ....
    }
}
```



浏览器发送请求测试，可以看到成功获取对应的数据

![image-20240225153236935](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240225153236935.png)



我们需要将其统一配置为从网关进行访问，在网关微服务中配置路由过滤器信息

![image-20240225153958009](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240225153958009.png)

```yml
# 第三方请求的路由重写
# http://localhost:88/api/thirdparty/oss/policy -->
# http://localhost:30000/oss/policy
- id: third_party_route
  uri: lb://tts-third-party
  predicates:
    - Path=/api/thirdparty/**
  filters:
    - RewritePath=/api/thirdparty/(?<segment>.*),/$\{segment}
```

通过网关访问测试：

![image-20240225153830483](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240225153830483.png)





##### 18.4、JSR303数据校验

直接给实体类加上注解：

![image-20240226221932543](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240226221932543.png)

控制层：

```java
 /**
 * 保存
 *      * @param brand 品牌信息入参
 *      * @param result 品牌信息校验结果内容
 *      * @return
 */
@PostMapping("/save")
public R save(@Validated @RequestBody BrandEntity brand){
    /*if(result.hasErrors()){
        // 如果当前校验结果有问题
        // 获取校验错误结果
        Map<String, String> map = new HashMap<>();
        result.getFieldErrors().forEach(r -> {
            // 获取错误提示
            String message = r.getDefaultMessage();
            // 获取错误的属性的名字
            String field = r.getField();
            map.put(field, message);
        });
        // 返回错误信息
        return R.error(1, "提交的数据不合法").put("data", map);
    }else{
        // 如果当前校验通过，保存数据
        brandService.save(brand);
    }*/
    brandService.save(brand);
    return R.ok();
}
```

入参：

```
{
    "brandId":1
}
```

报错提示：

```
{
    "timestamp": "2024-02-26T14:16:05.620+0000",
    "status": 400,
    "error": "Bad Request",
    "errors": [
        {
            "codes": [
                "NotBlank.brandEntity.name",
                "NotBlank.name",
                "NotBlank.java.lang.String",
                "NotBlank"
            ],
            "arguments": [
                {
                    "codes": [
                        "brandEntity.name",
                        "name"
                    ],
                    "arguments": null,
                    "defaultMessage": "name",
                    "code": "name"
                }
            ],
            "defaultMessage": "品牌名不能为空",
            "objectName": "brandEntity",
            "field": "name",
            "rejectedValue": null,
            "bindingFailure": false,
            "code": "NotBlank"
        }
    ],
    "message": "Validation failed for object='brandEntity'. Error count: 1",
    "path": "/product/brand/save"
}
```

相关的消息提示内容在`ValidationMessages.properties`中进行配置





完整写法：

实体类：

```java
package com.yjy.tts.product.entity;

import com.baomidou.mybatisplus.annotation.TableId;
import com.baomidou.mybatisplus.annotation.TableName;

import java.io.Serializable;
import java.util.Date;
import lombok.Data;
import org.hibernate.validator.constraints.URL;

import javax.validation.constraints.*;

/**
 * 品牌
 * 
 * @author yjy
 * @email 2322092442@qq.com
 * @date 2023-12-31 18:57:34
 */
@Data
@TableName("pms_brand")
public class BrandEntity implements Serializable {
	private static final long serialVersionUID = 1L;

	/**
	 * 品牌id
	 */
	@TableId
	private Long brandId;

	/**
	 * 品牌名
	 */
	@NotBlank(message = "品牌名不能为空")
	private String name;
	/**
	 * 品牌logo地址
	 */
	@NotEmpty(message = "品牌log地址不能为空")
	@URL(message = "logo必须是一个合法的url地址")
	private String logo;

	/**
	 * 介绍
	 */
	@Pattern(regexp = "/^[a-zA-Z]$/", message = "检索首字母必须是一个字母")
	private String descript;

	/**
	 * 显示状态[0-不显示；1-显示]
	 */
	@NotNull(message = "显示状态不能为空")
	private Integer showStatus;

	/**
	 * 检索首字母
	 */
	@NotNull(message = "检索首字母不能为空")
	private String firstLetter;

	/**
	 * 排序
	 */
	@NotNull(message = "排序不能为空")
	@Min(value = 0, message = "排序必须大于等于0")
	private Integer sort;

}

```

控制层：

```java
/**
 * 保存
 * @param brand 品牌信息入参
 * @param result 品牌信息校验结果内容
 * @return
 */
@PostMapping("/save")
public R save(@Validated @RequestBody BrandEntity brand, BindingResult result){
    if(result.hasErrors()){
        // 如果当前校验结果有问题
        // 获取校验错误结果
        Map<String, String> map = new HashMap<>();
        result.getFieldErrors().forEach(r -> {
            // 获取错误提示
            String message = r.getDefaultMessage();
            // 获取错误的属性的名字
            String field = r.getField();
            map.put(field, message);
        });
        // 返回错误信息
        return R.error(1, "提交的数据不合法").put("data", map);
    }else{
        // 如果当前校验通过，保存数据
        brandService.save(brand);
    }
    brandService.save(brand);
    return R.ok();
}
```

入参：

```
{
    "brandId":1
}
```

出参：

```
{
    "msg": "提交的数据不合法",
    "code": 1,
    "data": {
        "name": "品牌名不能为空",
        "logo": "品牌log地址不能为空",
        "showStatus": "显示状态不能为空",
        "sort": "排序不能为空",
        "firstLetter": "检索首字母不能为空"
    }
}
```





##### 18.5、统一异常处理

针对上面的处理情况，我们每一个校验都要写一个处理，是很麻烦的

![image-20240226223432011](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240226223432011.png)

因此我们可以统一进行异常的处理

将异常处理器放在`tts-common`下

![image-20240227185807702](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240227185807702.png)

```java
package com.yjy.common.exception;

import com.yjy.common.utils.R;
import lombok.extern.slf4j.Slf4j;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import java.util.HashMap;
import java.util.Map;

/**
 * 全局异常处理器
 * @author banana
 * @create 2024-02-26 22:39
 */
@Slf4j
@RestControllerAdvice
public class GlobalBizExceptionHandler {

    // 校验失败异常
    @ExceptionHandler(value = MethodArgumentNotValidException.class)
    public R handleVaildException(MethodArgumentNotValidException ex){
        log.error("数据校验出现问题:{}", ex.getMessage());
        log.error("异常类型：{}", ex.getClass());

        BindingResult bindingResult = ex.getBindingResult();
        Map<String, String> errorMap = new HashMap<>();

        bindingResult.getFieldErrors().forEach( r -> {
            errorMap.put(r.getField(), r.getDefaultMessage());
        });
        return R.error(BizCodeEnum.VAILD_EXCEPTION.getCode(), BizCodeEnum.VAILD_EXCEPTION.getMsg())
                .put("data", errorMap);
    }

    @ExceptionHandler(value = Throwable.class)
    public R handleException(Throwable throwable){
        return R.error();
    }

}

```

并且定义错误码枚举类`BizCodeEnum`：

```java
package com.yjy.common.exception;

import lombok.AllArgsConstructor;
import lombok.Getter;

/**
 * 错误代码枚举类
 * @author banana
 * @create 2024-02-26 22:50
 */
@Getter
@AllArgsConstructor
public enum BizCodeEnum {

    UNKNOW_EXCEPTION(10000, "系统未知异常"),

    VAILD_EXCEPTION(10001, "参数格式校验失败");

    private int code;

    private String msg;

}

```

在`resources`下配置`META-INF.spring.factories `开启自动配置功能 

![image-20240227185908973](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240227185908973.png)

```
# Auto Configure
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
com.yjy.common.exception.GlobalBizExceptionHandler

```

再次进行访问，发现异常可以被统一处理了

![image-20240227190034723](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240227190034723.png)



##### 18.6、JSR303分组校验

1.伪代码说明：

① 添加一个空的接口类，用来表示分组

```java
class AddGroup{
    // ……
}
```

② 在字段属性上，添加@NotBlank(message = "品牌名必须提交", groups = {AddGroup.class})  给校验注解标注什么情况需要进行校验

③ 控制层方法中的入参，添加 @Validated({AddGroup.class})

④ 默认没有指定分组的校验注解@NotBlank， 在分组校验@Validated({AddGroup.class})情况下不生效，只有在@Validated生效（没有指定分组）

因此其可以帮助我们完成多场景的复杂校验。



2.具体实现：

创建校验分组类：

在`tts-common`中统一创建校验分组类（需要是接口）

![image-20240227195747793](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240227195747793.png)

```java
public interface AddGroup {
}
```

```java
public interface UpdateGroup {
}
```

控制层：

```java
/**
 * 保存
 * @param brand 品牌信息入参
 * @return 
 */
@PostMapping("/save")
public R save(@Validated(AddGroup.class) @RequestBody BrandEntity brand){
    brandService.save(brand);
    return R.ok();
}

/**
 * 修改
 */
@RequestMapping("/update")
public R update(@Validated(UpdateGroup.class) @RequestBody BrandEntity brand){
    brandService.updateById(brand);
    return R.ok();
}

/**
 * 修改品牌信息状态
 * @param brand 品牌信息
 * @return
 */
@RequestMapping("/update/status")
public R updateStatus(@Validated(UpdateStatusGroup.class) @RequestBody BrandEntity brand){
    brandService.updateById(brand);
    return R.ok();
}
```

实体类：

```java
package com.yjy.tts.product.entity;

import com.baomidou.mybatisplus.annotation.TableId;
import com.baomidou.mybatisplus.annotation.TableName;

import java.io.Serializable;
import java.util.Date;

import com.yjy.common.valid.AddGroup;
import com.yjy.common.valid.CustomValue;
import com.yjy.common.valid.UpdateGroup;
import com.yjy.common.valid.UpdateStatusGroup;
import lombok.Data;
import org.hibernate.validator.constraints.URL;

import javax.validation.constraints.*;

/**
 * 品牌
 * 
 * @author yjy	
 * @email 2322092442@qq.com
 * @date 2023-12-31 18:57:34
 */
@Data
@TableName("pms_brand")
public class BrandEntity implements Serializable {
	private static final long serialVersionUID = 1L;

	/**
	 * 品牌id
	 */
	@NotNull(message = "修改必须指定品牌id", groups = {UpdateGroup.class})
	@Null(message = "新增不能指定品牌id", groups = {AddGroup.class})
	@TableId
	private Long brandId;

	/**
	 * 品牌名
	 */
	@NotBlank(message = "品牌名不能为空", groups = {AddGroup.class, UpdateGroup.class})
	private String name;

	/**
	 * 品牌logo地址
	 */
	@NotEmpty(message = "品牌log地址不能为空", groups = {AddGroup.class})
	@URL(message = "logo必须是一个合法的url地址", groups = {AddGroup.class, UpdateGroup.class})
	private String logo;

	/**
	 * 介绍
	 */
	private String descript;

	/**
	 * 显示状态[0-不显示；1-显示]
	 */
	@NotNull(message = "显示状态不能为空", groups = {AddGroup.class, UpdateStatusGroup.class})
	@CustomValue(vals={0,1}, groups = {AddGroup.class, UpdateStatusGroup.class})
	private Integer showStatus;

	/**
	 * 检索首字母
	 */
	@NotEmpty(message = "检索首字母不能为空", groups = {AddGroup.class})
	@Pattern(regexp = "^[a-zA-Z]$", message = "检索首字母必须是一个字母", groups = {AddGroup.class, UpdateGroup.class})
	private String firstLetter;

	/**
	 * 排序
	 */
	@NotNull(message = "排序不能为空", groups = {AddGroup.class})
	@Min(value = 0, message = "排序必须大于等于0", groups = {AddGroup.class, UpdateGroup.class})
	private Integer sort;

}

```



##### 18.7、JSR303自定义校验

1.自动校验步骤

- 编写一个自定义的校验注解

- 编写一个自定义的校验器

- 关联自定义的校验器和自定义的校验注解



2.具体分析

这里完成对显示状态（showStatus）的校验

引入依赖：

```xml
<!--校验注解相关api-->
<dependency>
    <groupId>javax.validation</groupId>
    <artifactId>validation-api</artifactId>
    <version>2.0.1.Final</version>
</dependency>
```

自定义校验注解：

![image-20240227212147226](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240227212147226.png)

```java
package com.yjy.common.valid;

import javax.validation.Constraint;
import javax.validation.Payload;
import java.lang.annotation.Documented;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;

import static java.lang.annotation.ElementType.*;
import static java.lang.annotation.ElementType.TYPE_USE;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

/**
 * 自定义注解
 * @author banana
 * @create 2024-02-27 20:30
 */

@Documented
// 指定校验器（可以有多个校验器）
@Constraint(validatedBy = { CustomValueConstraintValidator.class })
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
@Retention(RUNTIME)
public @interface CustomValue {

    // 校验失败抛出异常信息
    // 指定默认的异常信息（在配置文件中进行配置）
    String message() default "{com.yjy.common.valid.CustomValue.message}";

    Class<?>[] groups() default { };

    Class<? extends Payload>[] payload() default { };

    int[] vals() default { };
}

```

配置自定义异常信息：

![image-20240227212248475](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240227212248475.png)



```
com.yjy.common.valid.CustomValue.message=当前输入值不正确
```

自定义校验器：

```java
package com.yjy.common.valid;

import javax.validation.ConstraintValidator;
import javax.validation.ConstraintValidatorContext;
import java.util.HashSet;
import java.util.Set;

/**
 * @author banana
 * @create 2024-02-27 20:44
 */
public class CustomValueConstraintValidator implements ConstraintValidator<CustomValue, Integer> {

    private Set<Integer> set = new HashSet<>();

    // 初始化方法
    @Override
    public void initialize(CustomValue constraintAnnotation) {
        int[] vals = constraintAnnotation.vals();
        for(int val : vals){
            set.add(val);
        }
    }

    /**
     * 判断是否校验成功
     * @param value 需要校验的值
     * @param context
     * @return
     */
    @Override
    public boolean isValid(Integer value, ConstraintValidatorContext context) {
        return set.contains(value);
    }
}

```

但是访问的时候乱码了：

![image-20240227212443277](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240227212443277.png)

解决请看二、技术相关II、后端 6、解决自定义校验异常信息乱码问题。

#### 19、商品服务-平台属性

##### 19.1、全量数据库导入

获取菜单数据sql

![image-20240227234529579](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240227234529579.png)

在数据库中执行

```sql
/*
SQLyog Ultimate v11.25 (64 bit)
MySQL - 5.7.27 : Database - gulimall_admin
*********************************************************************
*/


/*!40101 SET NAMES utf8 */;

/*!40101 SET SQL_MODE=''*/;

/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;
CREATE DATABASE /*!32312 IF NOT EXISTS*/`mall_admin` /*!40100 DEFAULT CHARACTER SET utf8mb4 */;

USE `mall_admin`;

/*Table structure for table `sys_menu` */

DROP TABLE IF EXISTS `sys_menu`;

CREATE TABLE `sys_menu` (
  `menu_id` bigint(20) NOT NULL AUTO_INCREMENT,
  `parent_id` bigint(20) DEFAULT NULL COMMENT '父菜单ID，一级菜单为0',
  `name` varchar(50) DEFAULT NULL COMMENT '菜单名称',
  `url` varchar(200) DEFAULT NULL COMMENT '菜单URL',
  `perms` varchar(500) DEFAULT NULL COMMENT '授权(多个用逗号分隔，如：user:list,user:create)',
  `type` int(11) DEFAULT NULL COMMENT '类型   0：目录   1：菜单   2：按钮',
  `icon` varchar(50) DEFAULT NULL COMMENT '菜单图标',
  `order_num` int(11) DEFAULT NULL COMMENT '排序',
  PRIMARY KEY (`menu_id`)
) ENGINE=InnoDB AUTO_INCREMENT=76 DEFAULT CHARSET=utf8mb4 COMMENT='菜单管理';

/*Data for the table `sys_menu` */

insert  into `sys_menu`(`menu_id`,`parent_id`,`name`,`url`,`perms`,`type`,`icon`,`order_num`) values (1,0,'系统管理',NULL,NULL,0,'system',0),(2,1,'管理员列表','sys/user',NULL,1,'admin',1),(3,1,'角色管理','sys/role',NULL,1,'role',2),(4,1,'菜单管理','sys/menu',NULL,1,'menu',3),(5,1,'SQL监控','http://localhost:8080/renren-fast/druid/sql.html',NULL,1,'sql',4),(6,1,'定时任务','job/schedule',NULL,1,'job',5),(7,6,'查看',NULL,'sys:schedule:list,sys:schedule:info',2,NULL,0),(8,6,'新增',NULL,'sys:schedule:save',2,NULL,0),(9,6,'修改',NULL,'sys:schedule:update',2,NULL,0),(10,6,'删除',NULL,'sys:schedule:delete',2,NULL,0),(11,6,'暂停',NULL,'sys:schedule:pause',2,NULL,0),(12,6,'恢复',NULL,'sys:schedule:resume',2,NULL,0),(13,6,'立即执行',NULL,'sys:schedule:run',2,NULL,0),(14,6,'日志列表',NULL,'sys:schedule:log',2,NULL,0),(15,2,'查看',NULL,'sys:user:list,sys:user:info',2,NULL,0),(16,2,'新增',NULL,'sys:user:save,sys:role:select',2,NULL,0),(17,2,'修改',NULL,'sys:user:update,sys:role:select',2,NULL,0),(18,2,'删除',NULL,'sys:user:delete',2,NULL,0),(19,3,'查看',NULL,'sys:role:list,sys:role:info',2,NULL,0),(20,3,'新增',NULL,'sys:role:save,sys:menu:list',2,NULL,0),(21,3,'修改',NULL,'sys:role:update,sys:menu:list',2,NULL,0),(22,3,'删除',NULL,'sys:role:delete',2,NULL,0),(23,4,'查看',NULL,'sys:menu:list,sys:menu:info',2,NULL,0),(24,4,'新增',NULL,'sys:menu:save,sys:menu:select',2,NULL,0),(25,4,'修改',NULL,'sys:menu:update,sys:menu:select',2,NULL,0),(26,4,'删除',NULL,'sys:menu:delete',2,NULL,0),(27,1,'参数管理','sys/config','sys:config:list,sys:config:info,sys:config:save,sys:config:update,sys:config:delete',1,'config',6),(29,1,'系统日志','sys/log','sys:log:list',1,'log',7),(30,1,'文件上传','oss/oss','sys:oss:all',1,'oss',6),(31,0,'商品系统','','',0,'editor',0),(32,31,'分类维护','product/category','',1,'menu',0),(34,31,'品牌管理','product/brand','',1,'editor',0),(37,31,'平台属性','','',0,'system',0),(38,37,'属性分组','product/attrgroup','',1,'tubiao',0),(39,37,'规格参数','product/baseattr','',1,'log',0),(40,37,'销售属性','product/saleattr','',1,'zonghe',0),(41,31,'商品维护','product/spu','',0,'zonghe',0),(42,0,'优惠营销','','',0,'mudedi',0),(43,0,'库存系统','','',0,'shouye',0),(44,0,'订单系统','','',0,'config',0),(45,0,'用户系统','','',0,'admin',0),(46,0,'内容管理','','',0,'sousuo',0),(47,42,'优惠券管理','coupon/coupon','',1,'zhedie',0),(48,42,'发放记录','coupon/history','',1,'sql',0),(49,42,'专题活动','coupon/subject','',1,'tixing',0),(50,42,'秒杀活动','coupon/seckill','',1,'daohang',0),(51,42,'积分维护','coupon/bounds','',1,'geren',0),(52,42,'满减折扣','coupon/full','',1,'shoucang',0),(53,43,'仓库维护','ware/wareinfo','',1,'shouye',0),(54,43,'库存工作单','ware/task','',1,'log',0),(55,43,'商品库存','ware/sku','',1,'jiesuo',0),(56,44,'订单查询','order/order','',1,'zhedie',0),(57,44,'退货单处理','order/return','',1,'shanchu',0),(58,44,'等级规则','order/settings','',1,'system',0),(59,44,'支付流水查询','order/payment','',1,'job',0),(60,44,'退款流水查询','order/refund','',1,'mudedi',0),(61,45,'会员列表','member/member','',1,'geren',0),(62,45,'会员等级','member/level','',1,'tubiao',0),(63,45,'积分变化','member/growth','',1,'bianji',0),(64,45,'统计信息','member/statistics','',1,'sql',0),(65,46,'首页推荐','content/index','',1,'shouye',0),(66,46,'分类热门','content/category','',1,'zhedie',0),(67,46,'评论管理','content/comments','',1,'pinglun',0),(68,41,'spu管理','product/spu','',1,'config',0),(69,41,'发布商品','product/spuadd','',1,'bianji',0),(70,43,'采购单维护','','',0,'tubiao',0),(71,70,'采购需求','ware/purchaseitem','',1,'editor',0),(72,70,'采购单','ware/purchase','',1,'menu',0),(73,41,'商品管理','product/manager','',1,'zonghe',0),(74,42,'会员价格','coupon/memberprice','',1,'admin',0),(75,42,'每日秒杀','coupon/seckillsession','',1,'job',0);

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

```

查看结果：

![image-20240227235428521](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240227235428521.png)



##### 19.2、获取分类属性分组

控制层：

```java
/**
 * 属性分组
 *
 * @author yjy
 * @email 2322092442@qq.com
 * @date 2024-01-03 21:11:20
 */
@RestController
@RequestMapping("product/attrgroup")
public class AttrGroupController {
    @Autowired
    private AttrGroupService attrGroupService;

    /**
     *
     * @param params 入参
     * @param catelogId 三级分类属性id
     * @return
     */
    @RequestMapping("/list/{catelogId}")
    public R list(@RequestParam Map<String, Object> params,
                  @PathVariable("catelogId") Long catelogId){
        PageUtils page = attrGroupService.queryPage(params, catelogId);
        return R.ok().put("page", page);
    }
}

```

实现层：

```java
 @Override
    public PageUtils queryPage(Map<String, Object> params, Long catelogId) {
        // 声明出参
        IPage<AttrGroupEntity> page = null;

        // 获取筛选内容
        String key = (String) params.get("key");

        // 条件构造器
        LambdaQueryWrapper<AttrGroupEntity> wrapper = Wrappers.<AttrGroupEntity>lambdaQuery();

        if(StringUtils.isNotBlank(key)){
            // 筛选内容不为空，对条件构造器进行改造
            wrapper.and(r -> {
                r.eq(AttrGroupEntity::getAttrGroupId, key)
                        .or()
                        .like(AttrGroupEntity::getAttrGroupName, key);
            });
        }

        if(catelogId == 0){
            // 当前三级分类传递0，显示所有的属性
            // 根据传入的内容进行分页查询 & 条件构造器中的条件没有
            page = this.page(new Query().getPage(params), wrapper);
        } else {
            wrapper.eq(AttrGroupEntity::getCatelogId, catelogId);
            page = this.page(new Query().getPage(params), wrapper);
        }

        // 返回出参
        return new PageUtils(page);
    }

```

实体层：

无



##### 19.3、分组&级联选择器

三级分类字段添加`@JsonInclude(JsonInclude.Include.NON_EMPTY)`

防止后面有空的`children`,即`[]`

```java
// 指定当前不为空时才有
@JsonInclude(JsonInclude.Include.NON_EMPTY)
//指定当前不为数据表中的字段
@TableField(exist = false)
private List<CategoryEntity> children;
```



##### 19.4、分组修改回显

实体类：

```
package com.yjy.tts.product.entity;

import com.baomidou.mybatisplus.annotation.TableField;
import com.baomidou.mybatisplus.annotation.TableId;
import com.baomidou.mybatisplus.annotation.TableName;

import java.io.Serializable;
import java.util.Date;
import java.util.List;

import lombok.Data;

/**
 * 属性分组
 * 
 * @author yjy
 * @email 2322092442@qq.com
 * @date 2023-12-31 18:57:34
 */
@Data
@TableName("pms_attr_group")
public class AttrGroupEntity implements Serializable {
	private static final long serialVersionUID = 1L;

	/**
	 * 分组id
	 */
	@TableId
	private Long attrGroupId;
	/**
	 * 组名
	 */
	private String attrGroupName;
	/**
	 * 排序
	 */
	private Integer sort;
	/**
	 * 描述
	 */
	private String descript;
	/**
	 * 组图标
	 */
	private String icon;
	/**
	 * 所属分类id
	 */
	private Long catelogId;

	// 分类的完整路径
	@TableField(exist = false)
	private Long[] catelogPath;

}

```

控制层：

```
 /**
     * 信息
     */
    @RequestMapping("/info/{attrGroupId}")
    public R info(@PathVariable("attrGroupId") Long attrGroupId){
		AttrGroupEntity attrGroup = attrGroupService.getById(attrGroupId);

		// 组装路径详情
        // 获取当前三级分类的id
        Long catelogId = attrGroup.getCatelogId();
        Long[] catelogPath = categoryService.findCatelogPath(catelogId);
        attrGroup.setCatelogPath(catelogPath);

        return R.ok().put("attrGroup", attrGroup);
    }
```

实现层：

```
 @Override
    public Long[] findCatelogPath(Long catelogId) {

        List<Long> paths = new ArrayList<>();

        // 递归查询是否还有父结点
        List<Long> parentPath = findParentPath(catelogId, paths);

        return (Long[]) parentPath.toArray(new Long[parentPath.size()]);

    }

    // 递归查询父路径
    private List<Long> findParentPath(Long catelogId, List<Long> paths) {

        //根据当前分类id查询信息
        CategoryEntity byId = this.getById(catelogId);

        //如果当前不是父分类，继续向上查询
        if (byId.getParentCid() != 0) {
            findParentPath(byId.getParentCid(), paths);
        }
        paths.add(catelogId);

        return paths;
    }
```



#### 20、安装nginx

- 启动并下载nginx镜像（当前的作用只是为了复制出配置文件）

如果此时没有nginx镜像，会自动取下载

```
docker run -p 8081:80 --name nginx -d nginx:1.10   
```

![image-20240310142623902](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240310142623902.png)

![image-20240310142634726](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240310142634726.png)

- 将容器内的配置文件拷贝到/mydata/nginx/conf/ 下

当前目录位置为/mydata

```
mkdir -p /mydata/nginx/html
mkdir -p /mydata/nginx/logs
mkdir -p /mydata/nginx/conf
docker container cp nginx:/etc/nginx .  #拷贝到当前文件夹
#由于拷贝完成后会在config中存在一个nginx文件夹，所以需要将它的内容移动到conf中
mv nginx conf
mkdir nginx
mv conf nginx/
```

![image-20240310143137203](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240310143137203.png)

- 终止原nginx容器

```
docker stop nginx
```

- 删除原容器

```
docker rm nginx
```

- 创建新的Nginx，执行以下命令

```
docker run -p 80:80 --name nginx \
 -v /mydata/nginx/html:/usr/share/nginx/html \
 -v /mydata/nginx/logs:/var/log/nginx \
 -v /mydata/nginx/conf/:/etc/nginx \
 -d nginx:1.10
```

- 设置开机启动nginx

```
docker update nginx --restart=always
```

- 创建nginx默认的访问页面

nginx默认的访问页面时nginx中的html的index.html文件

因此我们对其进行修改

```
vi /mydata/nginx/html/index.html
```

![image-20240310145113725](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240310145113725.png)

- 测试



![image-20240310144035889](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240310144035889.png)

访问nginx对应的端口

![image-20240310145143058](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240310145143058.png)

### II、前端

#### 1、给VSCODE安装相关的插件

Vetur —— 语法高亮、智能感知、Emmet 等

包含格式化功能， Alt+Shift+F （格式化全文），Ctrl+K Ctrl+F（格式化选中代码，两个 Ctrl

需要同时按着）

EsLint —— 语法纠错

Auto Close Tag —— 自动闭合 HTML/XML 标签

Auto Rename Tag —— 自动完成另一侧标签的同步修改

JavaScript(ES6) code snippets — — ES6 语 法 智 能 提 示 以 及 快 速 输 入 ， 除 js 外 还 支

持.ts，.jsx，.tsx，.html，.vue，省去了配置其支持各种包含 js 代码文件的时间

HTML CSS Support —— 让 html 标签上写 class 智能提示当前项目所支持的样式

HTML Snippets —— html 快速自动补全

Open in browser —— 浏览器快速打开

Live Server —— 以内嵌服务器方式打开

Chinese (Simplified) Language Pack for Visual Studio Code —— 中文语言包

![image-20231225204440948](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231225204440948.png)

#### 2、安装Node.js

前端开发，少不了 node.js；Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。

http://nodejs.cn/api/

我们关注与 node.js 的 npm 功能就行；

**NPM** 是随同 NodeJS 一起安装的**包管理**工具，类似：JavaScript-NPM，Java-Maven；

1）、官网下载安装 node.js，并使用 node -v 检查版本

2）、配置 npm 使用淘宝镜像

npm config set registry http://registry.npm.taobao.org/

3）、大家如果 npm install 安装依赖出现 chromedriver 之类问题，先在项目里运行下面命令

npm install chromedriver --chromedriver_cdnurl=http://cdn.npm.taobao.org/dist/chromedriver

然后再运行 npm install





#### 3、NVM

NVM：Node Version Manage，即Node的版本管理工具。使用NVM，可以很方便地在多个NodeJS版本之间进行切换，可以通过nvm对node.js进行一个统一的管理

由于项目开发当中，不同的项目可能依赖不同版本的NodeJS，这种情况下，NodeJS版本的切换将会是一件非常麻烦的事情。因此，使用NVM管理NodeJS版本就显得尤为重要。



切换到指定的node.js后，才可以通过node -v 查看到对应的使用的node.js的版本

并且可以通过`npm config set registry http://registry.npm.taobao.org/`配置淘宝镜像



一些常用命令：

①查看已经安装的版本

该命令将列出所有已经安装在系统上的 Node.js 版本，并在当前使用的版本前面标记 `->`

```
nvm ls
```

②查看可用的远程版本

```
nvm list available
```

③查看当前正在使用的版本

```
nvm current
```

④使用某个版本的node.js

```
nvm use 版本号
```

⑤切换npm版本

```
nvm use <version> --npm
```

⑥Vue脚手架版本

```
vue -V
```

⑦npm映射网址

```
npm config get registry
```

并且可以通过`npm config set registry http://registry.npm.taobao.org/`配置淘宝镜像

⑧node版本

```
node -v
```

⑨npm版本

```
npm -v
```



#### 4、人人开源前端项目的启动

经过上面我们配置完成了node.js（通过命令行node -v 查看版本号是否配置成功）

通过VScode打开我们的前端项目

![image-20231231164241893](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231231164241893.png)

在前端项目的`package.json`类似于后端的maven，描述各个依赖的版本

![image-20231231164259229](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231231164259229.png)

前端项目第一次启动，打开终端，输入`npm install`安装相关的依赖

![image-20231231164419111](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231231164419111.png)

最后依赖的信息都会在前端项目的`node_modules`中进行显示

![image-20231231164557034](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231231164557034.png)

依赖安装结束

![image-20231231165846534](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231231165846534.png)

接着我们通过`npm run dev`运行前端项目

![image-20231231165952009](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231231165952009.png)

用默认的账号密码：admin/admin

![image-20231231170330331](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20231231170330331.png)

前后端联调成功

#### 5、商品服务-API-三级分类（前端）

##### 5.1、配置网关路由与路径重写

首先是为我们的商品服务的三级分类添加对应的前端管理界面

打开人人fast的后台管理系统，在系统管理-菜单管理中添加商品系统的目录

![image-20240127154350471](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240127154350471.png)

添加后的结果如下图所示

![image-20240127154431682](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240127154431682.png)

再是添加商品分类的菜单

![image-20240127154628045](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240127154628045.png)

![image-20240127154654403](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240127154654403.png)



我们现在期望我们在点击商品系统-分类维护中可以显示出所有的商品分类的显示，目前界面如下

![image-20240127154752577](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240127154752577.png)

首先我们来看一下后台管理系统显示的规则，拿角色管理来说明

角色管理在菜单管理中配置的`url`是`sys/role`

![image-20240127155048429](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240127155048429.png)

我们在请求角色管理的时候，访问的路径是`sys-role`

![image-20240127155124076](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240127155124076.png)

该页面的内容与项目中`src/views/modules/sys`的role.vue相对应

![image-20240127155241990](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240127155241990.png)

我们修改其中的按钮，并保存

![image-20240127155722893](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240127155722893.png)

可以看到对应的角色管理的按钮也修改了

![image-20240127155823407](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240127155823407.png)

因此对于`product/category`我们可以参照上面，在`src/views/modules`中创建`product`目录，并在其中创建一个`category.vue`

![image-20240127160457087](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240127160457087.png)

我们测试一下，在其中编写相关的代码

```html
<template>
  <div>nihao</div>
</template>

<script>
export default {

}
</script>

<style>

</style>
```

看对应的页面可以展示出对应的内容

![image-20240127162721972](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240127162721972.png)

我们这里使用element-UI中的Tree树形控件对这块内容进行显示，代码&分析如下

```vue
<template>
  <!-- element-UI树形tree控件 -->
  <el-tree :data="data" :props="defaultProps" @node-click="handleNodeClick"></el-tree>
</template>

<script>
  export default {
    data () {
      return {
        data: [{
          label: '一级 1',
          children: [{
            label: '二级 1-1',
            children: [{
              label: '三级 1-1-1'
            }]
          }]
        }, {
          label: '一级 2',
          children: [{
            label: '二级 2-1',
            children: [{
              label: '三级 2-1-1'
            }]
          }, {
            label: '二级 2-2',
            children: [{
              label: '三级 2-2-1'
            }]
          }]
        }, {
          label: '一级 3',
          children: [{
            label: '二级 3-1',
            children: [{
              label: '三级 3-1-1'
            }]
          }, {
            label: '二级 3-2',
            children: [{
              label: '三级 3-2-1'
            }]
          }]
        }],
        defaultProps: {
          children: 'children',
          label: 'label'
        }
      }
    },
    methods: {
      handleNodeClick (data) {
        console.log(data)
      }
    }
  }
</script>

<style>
</style>
```

props：配置选项

- label：指定节点标签为节点对象的某个属性值（string, function(data, node)）
- children：指定子树为节点对象的某个属性值（string）

node-click：节点被点击时的回调



运行结果：

![image-20240127195041298](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240127195041298.png)



如果我们需要获取我们三级分类商品的信息，需要对此进行改造，改造后的代码如下

```vue
<template>
    <!-- element-UI树形tree控件 -->
    <el-tree :data="data" :props="defaultProps" @node-click="handleNodeClick"></el-tree>
</template>

<script>
  export default {
    data () {
      return {
        data: [],
        defaultProps: {
          children: 'children',
          label: 'label'
        }
      }
    },
    methods: {
      handleNodeClick (data) {
        console.log(data)
      },
      // 获取商品服务的三级分类信息
      getCategory () {
        // 发送http请求
        this.$http({
          url: this.$http.adornUrl('/product/category/list/tree'),
          method: 'get'
        }).then(data => {
          console.log('成功获取到商品菜单数据：', data)
        })
      }
    },
    // vue生命周期 - 创建完成（可以访问当前this实例）
    created () {
      this.getCategory()
    }
  }
</script>

<style>
</style>
```



我们运行一下可以发现，其请求的ip地址和端口是不正确的，我们需要从我们的商品服务中去获取分类信息，就必须调用商品服务的ip地址和端口，而现在调用的仍然是管理系统后端服务的地址

![image-20240127203735985](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240127203735985.png)

在`static/config/index.js`中定义了api接口请求的地址

![image-20240127204101053](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240127204101053.png)

为了统一地址，我们只需要统一地址，给网关发请求，通过网关路由到指定的地址

```html
// api接口请求地址
window.SITE_CONFIG['baseUrl'] = 'http://localhost:88';
```

经过上述配置后，我们发现在重新登录的时候，申请验证码的接口也统一走网关了（原本应该走人人fast后端的项目）

![image-20240127205104116](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240127205104116.png)

因此我们先让网关统一转发到后台管理服务服务上

我们将后台管理服务注册到注册中心（nacos）

我们在后端管理服务的pom.xml中，加上我们基础服务的依赖，简介引入nacos注册中心的依赖（已经在基础服务中配置过）

![image-20240127205539159](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240127205539159.png)

```xml
<!--tts基础服务-->
<dependency>
    <groupId>com.yjy.tts</groupId>
    <artifactId>tts-common</artifactId>
    <version>0.0.1-SNAPSHOT</version>
</dependency>
```



配置文件`application.yml`配置注册中心的相关配置

```xml
spring:
	application:
    	name: tts-manage
	cloud:
        nacos:
          discovery:
            server-addr: 127.0.0.1:8848
```

在后台管理服务的启动类上添加nacos注册注解`@EnableDiscoveryClient`

```java
@EnableDiscoveryClient
@SpringBootApplication
public class TtsManageApplication {

	public static void main(String[] args) {
		SpringApplication.run(TtsManageApplication.class, args);
	}

}
```

启动`nacos`看服务注册情况

可以看到管理服务成功注册到注册中心

![image-20240213195816240](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240213195816240.png)

并且后台管理服务的端口号为8080

![image-20240213201414963](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240213201414963.png)



在网关的配置文件`application.yml`中配置网关路由，进行请求路由的重写

![image-20240213211700544](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240213211700544.png)

```yml
spring:
  application:
    # 服务名称
    name: tts-gateway
  cloud:
    # nacos 注册中心地址配置
    nacos:
      discovery:
        server-addr: 127.0.0.1:8848
    # 网关配置
    gateway:
      routes:
   		# 管理服务请求的路由重写
        - id: admin_route
          uri: lb://tts-manage
          predicates:
            - Path=/api/**
          filters:
          	# 将请求/api/(?<segment>.*)转化为/tts-manage/$\{segment}
          	# 示例：
          	# http://localhost:88/api/captcha.jpg -->
        	# http://localhost:88/tts-manage/captcha.jpg
            - RewritePath=/api/(?<segment>.*), /tts-manage/$\{segment}
```

修改后端服务项目的配置文件`application.yml`中的上下文路径为`tts-manage`，与上面的转换路径保持统一

![image-20240213213855027](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240213213855027.png)

修改前端项目的统一请求路径

原：

```
// api接口请求地址
window.SITE_CONFIG['baseUrl'] = 'http://localhost:88';
```

现：

```
// api接口请求地址
window.SITE_CONFIG['baseUrl'] = 'http://localhost:88/api';
```



我们再次进行访问验证码的请求，可以发现请求通了

即通过网关将请求路径

从http://localhost:88/api/captcha.jpg?uuid=……

转化为http://localhost:8080/tts-manage/captcha.jpg?uuid=……

![image-20240213221215931](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240213221215931.png)



此时我们登录后台管理系统，可以发现是可以登录成功的

![image-20240213222128776](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240213222128776.png)

但是有时候我访问不成功，提示403，访问被阻止/拒绝，如下图所示

![image-20240213222226508](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240213222226508.png)

原因：

已拦截跨源请求：当前是localhost:8001,同源策略禁止读取位于 http://localhost:88/api/sys/login 的远程资源。（原因：CORS 头缺少 'Access-Control-Allow-Origin'）

这是一种跨域问题。访问的域名和端口和原来的请求不同，请求就会被限制,出于安全考虑。

![image-20240213222339690](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240213222339690.png)

跨域流程：

![image-20240213222507633](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240213222507633.png)

解决跨域方法：

（1）使用nginx部署为同一域

对于前端和后端的项目的任何访问请求路径都通过nginx去指定同一域

直接访问nginx监听的ip和端口（服务地址）

通过nginx去做一个动态的转发

![image-20240213222757607](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240213222757607.png)

（2）配置当前请求允许跨域

![image-20240213222948773](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240213222948773.png)

解决方法：在网关中定义“GulimallCorsConfiguration”类，该类用来做过滤，允许所有的请求跨域。

```
@Configuration
public class GulimallCorsConfiguration {

    @Bean
    public CorsWebFilter corsWebFilter(){
        UrlBasedCorsConfigurationSource source=new UrlBasedCorsConfigurationSource();
        CorsConfiguration corsConfiguration = new CorsConfiguration();
        corsConfiguration.addAllowedHeader("*");
        corsConfiguration.addAllowedMethod("*");
        corsConfiguration.addAllowedOrigin("*");
        corsConfiguration.setAllowCredentials(true);
        
        source.registerCorsConfiguration("/**",corsConfiguration);
        return new CorsWebFilter(source);
    }
}
```





我们在当前项目中采用第二种跨域的方式

因为我们当前是通过网关去代理到其他服务中，因此我们只需要将跨域的配置放到网关中即可。

在网关服务中创建`config - TtsCorsConfiguration.class`

```
package com.yjy.tts.gateway.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.cors.CorsConfiguration;

import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.reactive.CorsWebFilter;
import org.springframework.web.cors.reactive.UrlBasedCorsConfigurationSource;

/**
 * @author banana
 * @create 2024-02-13 23:06
 */
@Configuration
public class TtsCorsConfiguration{

    //将CorsWebFilter放到容器中即可生效
    @Bean
    public CorsWebFilter corsWebFilter(){
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();

        CorsConfiguration corsConfiguration = new CorsConfiguration();

        //1.配置跨域
        //允许所有头进行跨域
        corsConfiguration.addAllowedHeader("*");
        //允许所有请求方式进行跨域
        corsConfiguration.addAllowedMethod("*");
        //允许任意请求来源进行跨域
        corsConfiguration.addAllowedOrigin("*");
        //允许携带cookie进行跨域
        corsConfiguration.setAllowCredentials(true);

        //2.注册跨域配置（对所有oath生效）
        source.registerCorsConfiguration("/**", corsConfiguration);

        return new CorsWebFilter(source);
    }

}

```



为防止重复配置跨域

需要将后台管理系统中配置的块注释掉，统一在网关中进行跨域的配置

```java
@Configuration
public class CorsConfig implements WebMvcConfigurer {

    /*@Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**")
            //如果没有配置该项，Spring Boot 默认会将其设置为 "*"，即允许所有来源进行跨域访问
            *//*.allowedOriginPatterns("*")*//*
            .allowCredentials(true)
            .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS")
            .maxAge(3600);
    }*/
}
```

否则结果如下：

再次访问：http://localhost:8001/#/login

![image-20200425195437299](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20200425195437299.png)

http://localhost:8001/renre已拦截跨源请求：同源策略禁止读取位于 http://localhost:88/api/sys/login 的远程资源。（原因：不允许有多个 'Access-Control-Allow-Origin' CORS 头）n-fast/captcha.jpg?uuid=69c79f02-d15b-478a-8465-a07fd09001e6

出现了多个请求，并且也存在多个跨源请求。

为了解决这个问题，需要修改renren-fast项目，注释掉“io.renren.config.CorsConfig”类。然后再次进行访问。



到此就完成了跨域的配置，我们能够成功访问对应的页面。



##### 5.2、树形展示三级分类数据

我们访问商品系统的分类维护

可以看此时跨域的问题解决了，但是该请求找不到

![image-20240214204951740](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240214204951740.png)

因为对于当前的请求`http://localhost:88/api/product/category/list/tree`都是通过网关转给`renren-fast`即我们的后台管理系统

而此时我们的这个请求应该转给我们的商品服务`tts-product`



我们在网关中进行路由配置，将商品的请求转发到商品服务中

```yml
# 商品服务请求的路由重写
# http://localhost:88/api/product/captcha.jpg -->
# http://localhost:12000/product/renren-fast/captcha.jpg
- id: product_route
  uri: lb://tts-product
  predicates:
    - Path=/api/product/**
  filters:
    - RewritePath=/api/(?<segment>.*), /$\{segment}
```

并将精确匹配的路由放到上面

![image-20240214212122686](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240214212122686.png)





将商品服务加入到注册中心，并将配置放到到配置中心



在商品服务中创建配置文件`bootstrap.properties`,并编写注册中心和配置内容

```properties
# 当前应用/项目名称
spring.application.name=tts-product
# nacos 配置中心服务地址
spring.cloud.nacos.config.server-addr=127.0.0.1:8848
# 命名空间
spring.cloud.nacos.config.namespace=fd7f2fb5-bb2d-4666-98a6-ce5302a47bdb
# 分组
spring.cloud.nacos.config.group=dev
# 指定前缀名称
spring.cloud.nacos.config.prefix=tts-product
# 指定后缀为yaml
spring.cloud.nacos.config.file-extension=yml

# 扩展配置
# 数据源配置文件
spring.cloud.nacos.config.ext-config[0].data-id=datasource.yml
spring.cloud.nacos.config.ext-config[0].group=dev
# 配置中心的配置修改后刷新微服务（默认false）
spring.cloud.nacos.config.ext-config[0].refresh=true

# mybatis配置
spring.cloud.nacos.config.ext-config[1].data-id=mybatis.yml
spring.cloud.nacos.config.ext-config[1].group=dev
spring.cloud.nacos.config.ext-config[1].refresh=true

# 其他配置
spring.cloud.nacos.config.ext-config[2].data-id=other.yml
spring.cloud.nacos.config.ext-config[2].group=dev
spring.cloud.nacos.config.ext-config[2].refresh=true
```

在配置中心中进行配置

![image-20240214210939385](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240214210939385.png)

`other.yml`配置文件中是注册中心的内容

```yml
spring:
  # 配置 nacos server注册中心地址
  cloud:
    nacos:
      discovery:
        server-addr: 127.0.0.1:8848
  # 配置服务注册中心的应用名称
  application:
    name: tts-product

# tomcat端口设置
server:
  port: 12000
```

并在商品服务的启动类上添加注册发现的注解`@EnableDiscoveryClient`

![image-20240214211039024](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240214211039024.png)

到此，完成了商品服务的注册中心的注册以及配置中心的配置



我们再次通过浏览器调用tree接口，可以发现可以请求成功，并且拿取到对应的数据

![image-20240214214213963](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240214214213963.png)

查看前端代码有对应的打印语句

```html
console.log('成功获取到商品菜单数据：', data)
```

![image-20240214214910732](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240214214910732.png)



我们可以将返回的数据进行解构赋值，直接打印返回的数据即可

原：

```
then(({data}) => {
          console.log('成功获取到商品菜单数据：', data.data)
        })
```

现：

```
then(data => {
          console.log('成功获取到商品菜单数据：', data.data)
        })
```

结果：

![image-20240214215528149](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240214215528149.png)

说明：

- 对于`then(({data}) => {})`，回调函数使用了解构赋值的方式，从返回的响应对象中提取`data`属性，并将其作为回调函数的参数。这种写法适用于使用`axios`等工具发送请求时，通常会返回包含响应数据的对象，其中`data`属性存储着实际的数据内容。通过使用解构赋值，可以方便地直接获取到需要的数据。
- 而对于`then(data => {})`，回调函数直接接收完整的响应数据作为参数。这种写法适用于直接使用`fetch`等原生的浏览器API发送请求时，返回的是完整的响应对象，没有经过封装的`data`属性。因此，需要通过参数获取完整的响应数据，然后再从中提取出需要的数据。



- 解构赋值：

  `({})`的作用是创建一个空的对象字面量。在JavaScript中，使用大括号 `{}` 可以创建一个对象。

  在给定的上下文中，`({})`常常用于解构赋值操作。比如，如果有一个函数返回一个包含多个属性的对象，你可以使用解构赋值的方式轻松获取其中的某个属性或多个属性

  ```javascript
  const obj = {
    name: 'Alice',
    age: 25,
    gender: 'female'
  };
  
  // 使用解构赋值获取对象的属性
  const { name, age } = obj;
  console.log(name); // 输出: 'Alice'
  console.log(age); // 输出: 25
  
  // 如果没有使用括号，将会被视为代码块
  // const name = obj; // 错误：SyntaxError: Duplicate declaration "name"
  
  ```

  在上述示例中，我们使用解构赋值从`obj`对象中提取属性`name`和`age`。注意，在解构赋值的语法中，大括号 `{}` 表示要提取的属性，而不是一个代码块。如果没有使用括号，那么会被解析为代码块导致语法错误。



接下去是配置数据的显示

设置获得的数据给组件实例（Vue实例是通过Vue构造函数创建的根实例，它是Vue应用的起点；组件实例是由Vue实例创建的，它是Vue应用中的一个独立单元，负责处理特定的功能或UI组件）中的category，并指定显示的对象

```html
<template>
    <!-- element-UI树形tree控件 -->
    <el-tree :data="category" :props="defaultProps" @node-click="handleNodeClick"></el-tree>
</template>

<script>
  export default {
    data () {
      return {
        category: [],
        defaultProps: {
          children: 'children',
          label: 'name'
        }
      }
    },
    methods: {
      handleNodeClick (data) {
        console.log(data)
      },
      // 获取商品服务的三级分类信息
      getCategory () {
        // 发送http请求
        this.$http({
          url: this.$http.adornUrl('/product/category/list/tree'),
          method: 'get'
        }).then(({data}) => {
          console.log('成功获取到商品菜单数据：', data.data)
          this.category = data.data
        })
      }
    },
    // vue生命周期 - 创建完成（可以访问当前this实例）
    created () {
      this.getCategory()
    }
  }
</script>

<style>
</style>
```

结果显示：

![image-20240214220824981](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240214220824981.png)





##### 5.3、三级分类删除

1.规范：没有子菜单并且没有在其他地方被应用的分类可以进行删除操作



2.具体操作：

这里采用的是element-ui的 scoped slot方式

![image-20240214222257315](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240214222257315.png)

加入相应的组件代码

我们可以看到其在span中添加了两个按钮，通过vue的插槽机制slot-scope

在插槽中传了一个对象，一个node属性，和data属性

- node表示当前的结点

- data表示当前结点的数据

当我们点击append或remove按钮的时候，会传入对应的参数

```html
<template>
    <!-- element-UI树形tree控件 -->
    <el-tree :data="category" :props="defaultProps" @node-click="handleNodeClick">
      <span class="custom-tree-node" slot-scope="{ node, data }">
        <span>{{ node.label }}</span>
        <span>
          <el-button
            type="text"
            size="mini"
            @click="() => append(data)">
            Append
          </el-button>
          <el-button
            type="text"
            size="mini"
            @click="() => remove(node, data)">
            Delete
          </el-button>
        </span>
      </span>
    </el-tree>
</template>
```

添加具体的append方法和remove方法，将原来的方法内容删除

```javascript
append (data) {
    console.log('append', data)
},
remove (node, data) {
    console.log('remove', node, data)
}
```

我们点击一下，打印一下看一下响应的data和node内容

点击append，打印data的内容，就是当前节点的数据信息

![image-20240215000341979](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240215000341979.png)

点击remove，打印node，就是当前节点的一些内容

![image-20240215000502041](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240215000502041.png)





为了在点击按钮的时候不展开或收缩，我们通过expandd-on-click-node=false对其进行控制

```html
<el-tree :data="category" :props="defaultProps" @node-click="handleNodeClick" :expand-on-click-node="false">
  <span class="custom-tree-node" slot-scope="{ node, data }">
    <span>{{ node.label }}</span>
    <span>
      <el-button
        type="text"
        size="mini"
        @click="() => append(data)">
        Append
      </el-button>
      <el-button
        type="text"
        size="mini"
        @click="() => remove(node, data)">
        Delete
      </el-button>
    </span>
  </span>
</el-tree>
```





按照规范，显示append和delete按钮

当前总共有三级节点

- append：只能在一级和二级节点显示（通过当前节点node的level属性去进行区分）

  ```html
  <el-button
  v-if="node.level<=2"
  type="text"
  size="mini"
  @click="() => append(data)">
  Append
  </el-button>
  ```

  ![image-20240215001110217](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240215001110217.png)

- delete：只能在当前节点没有子节点的情况下显示（通过当前节点node的childNodes或data中的children都可以进行判断）并且没有被引用（后端逻辑判断）

  ```html
  <el-button
  v-if="node.childNodes.length == 0"
  type="text"
  size="mini"
  @click="() => remove(node, data)">
  Delete
  </el-button>
  ```

  ![image-20240215001431142](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240215001431142.png)







通过show-checkbox来设置节点能够被选择

```
 <el-tree :data="category" :props="defaultProps" @node-click="handleNodeClick" show-checkbox :expand-on-click-node="false">
```

![image-20240215001740409](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240215001740409.png)

并且为其添加node-key属性，其为每个树节点用来作为唯一标识的属性（整棵树应该是唯一的）

这里将cat_id作为各个节点的唯一标识

```html
<el-tree :data="category" 
:props="defaultProps" 
@node-click="handleNodeClick" 
show-checkbox
node-key="catId" 
:expand-on-click-node="false">
```



编写按钮对应的删除后端代码，详情见后端版块17.4



然后在前端中编写删除的发送请求



在工具类utils中的httpRequest中编写了对应的get请求和post请求的参数处理

```java
/**
 * get请求参数处理
 * @param {*} params 参数对象
 * @param {*} openDefaultParams 是否开启默认参数?
 */
http.adornParams = (params = {}, openDefaultParams = true) => {
  var defaults = {
    't': new Date().getTime()
  }
  return openDefaultParams ? merge(defaults, params) : params
}

/**
 * post请求数据处理
 * @param {*} data 数据对象
 * @param {*} openDefaultData 是否开启默认数据?
 * @param {*} contentType 数据格式
 *  json: 'application/json; charset=utf-8'
 *  form: 'application/x-www-form-urlencoded; charset=utf-8'
 */
http.adornData = (data = {}, openDefaultData = true, contentType = 'json') => {
  var defaults = {
    't': new Date().getTime()
  }
  data = openDefaultData ? merge(defaults, data) : data
  return contentType === 'json' ? JSON.stringify(data) : qs.stringify(data)
}
```

这段代码是一个处理请求参数的工具函数。它包含了两个方法：`adornParams`用于处理GET请求的参数，`adornData`用于处理POST请求的数据。

`adornParams`方法接受两个参数：

- `params`：参数对象，表示需要传递给GET请求的参数。
- `openDefaultParams`：是否开启默认参数，默认为`true`。如果设置为`true`，则会在参数对象中添加一个名为`t`的参数，其值为当前时间戳。axios的get请求会被缓存，第一次发过之后，就不会再找服务器请求新的数据，为了让它不缓存，让它发请求的时候带一个如上的时间参数，保证每一次请求都可以请求到新的数据。

`adornParams`方法会返回处理后的参数对象。如果`openDefaultParams`为`true`，则会将默认参数对象与传入的参数对象合并，否则只返回传入的参数对象。

`adornData`方法也接受三个参数：

- `data`：数据对象，表示需要传递给POST请求的数据。
- `openDefaultData`：是否开启默认数据，默认为`true`。如果设置为`true`，则会在数据对象中添加一个名为`t`的属性，其值为当前时间戳。
- `contentType`：数据格式，默认为`json`。可以设置为`json`或`form`，分别表示以JSON格式或表单形式提交数据。

`adornData`方法会返回处理后的数据。如果`openDefaultData`为`true`，则会将默认数据对象与传入的数据对象合并，否则只返回传入的数据对象。如果`contentType`为`json`，则会将数据对象转换为JSON字符串形式，否则会将数据对象转换为URL编码的字符串形式。



在用户片段中添加post请求的模板

```html
 "http-post请求":{
    "prefix":"httppost",
    "body":[
        "this.\\$http({",
        "url:this.\\$http.adornUrl(''),",
        "method:'post',",
        "data:this.\\$http.adornData(data,false)",
        "}).then(({data}) =>{})"
    ],
    "description":"httpPost请求"
}
```



对remove方法进行重写：

```javascript
remove (node, data) {
    var ids = [data.catId]
    this.$http({
      url: this.$http.adornUrl('/product/category/delete'),
      method: 'post',
      data: this.$http.adornData(ids, false)
    }).then(({data}) => {
      console.log('删除成功!')
      // 删除后刷新菜单
      this.category = this.getCategory()
    })
    console.log('remove', node, data)
  }
```



为了友好的人机交互效果，我们在删除的时候，使用element-ui的MessageBox 弹框组件

![image-20240216130626391](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240216130626391.png)

将其整合到我们的代码中

```js
remove (node, data) {
    var ids = [data.catId]
    this.$confirm(`是否删除【${data.name}】菜单?`, '提示', {
        confirmButtonText: '确定',
        cancelButtonText: '取消',
        type: 'warning'
    }).then(() => {
        this.$http({
            url: this.$http.adornUrl('/product/category/delete'),
            method: 'post',
            data: this.$http.adornData(ids, false)
        }).then(({data}) => {
            console.log('菜单删除成功!')
            // 删除后刷新菜单
            this.category = this.getCategory()
        })
        this.$message({
            type: 'success',
            message: '菜单删除成功!'
        })
    }).catch(() => {
        this.$message({
            type: 'info',
            message: '已取消删除'
        })
    })
    console.log('remove', node, data)
}
```



但是现在我们删除某一项菜单后，会重新调用刷新菜单的方法，原来的菜单会取消展开状态，我们要保持其展开的状态

我们需要在重新调用刷新菜单后，将当前删除结点的父级结点展示成展开效果，通过`default-expanded-keys` 默认展开结点去控制

```js
<template>
    <!-- element-UI树形tree控件 -->
    <el-tree :data="category" 
      :props="defaultProps" 
      @node-click="handleNodeClick" 
      show-checkbox
      node-key="catId" 
      :default-expanded-keys="expandedKey"
      :expand-on-click-node="false">
      <span class="custom-tree-node" slot-scope="{ node, data }">
        <span>{{ node.label }}</span>
        <span>
          <el-button
            v-if="node.level <= 2"
            type="text"
            size="mini"
            @click="() => append(data)">
            Append
          </el-button>
          <el-button
            v-if="node.childNodes.length == 0"
            type="text"
            size="mini"
            @click="() => remove(node, data)">
            Delete
          </el-button>
        </span>
      </span>
    </el-tree>
</template>

<script>
  export default {
    data () {
      return {
        category: [],
        expandedKey: [],
        defaultProps: {
          children: 'children',
          label: 'name'
        }
      }
    },
    methods: {
      // 获取商品服务的三级分类信息
      getCategory () {
        // 发送http请求
        this.$http({
          url: this.$http.adornUrl('/product/category/list/tree'),
          method: 'get'
        }).then(({data}) => {
          console.log('成功获取到商品菜单数据：', data.data)
          this.category = data.data
        })
      },
      append (data) {
        console.log('append', data)
      },
      remove (node, data) {
        var ids = [data.catId]
        this.$confirm(`是否删除【${data.name}】菜单?`, '提示', {
          confirmButtonText: '确定',
          cancelButtonText: '取消',
          type: 'warning'
        }).then(() => {
          this.$http({
            url: this.$http.adornUrl('/product/category/delete'),
            method: 'post',
            data: this.$http.adornData(ids, false)
          }).then(({data}) => {
            console.log('菜单删除成功!')
            // 删除后刷新菜单
            this.category = this.getCategory()
            // 设置需要默认展开的菜单
            this.expandedKey = [node.parent.data.catId]
          })
          this.$message({
            type: 'success',
            message: '菜单删除成功!'
          })
        }).catch(() => {
          this.$message({
            type: 'info',
            message: '已取消删除'
          })
        })
        console.log('remove', node, data)
      }
    },
    // vue生命周期 - 创建完成（可以访问当前this实例）
    created () {
      this.getCategory()
    }
  }
</script>

<style>
</style>
```



##### 5.4、三级分类添加

我们通过element-ui的对话框（Dialog 对话框）来实现该功能

在点击append按钮后，通过`:visible.sync="dialogVisible"`去控制它的显示，将dialogVisible放在组件的data中去进行控制

- dialogVisible：true       显示

- dialogVisible：false      关闭

```js
<template>
  <div>
     <!-- element-UI树形tree控件 -->
    <el-tree :data="categorys" 
      :props="defaultProps" 
      @node-click="handleNodeClick" 
      show-checkbox
      node-key="catId" 
      :default-expanded-keys="expandedKey"
      :expand-on-click-node="false">
      <span class="custom-tree-node" slot-scope="{ node, data }">
        <span>{{ node.label }}</span>
        <span>
          <el-button
            v-if="node.level <= 2"
            type="text"
            size="mini"
            @click="() => append(data)">
            Append
          </el-button>
          <el-button
            v-if="node.childNodes.length == 0"
            type="text"
            size="mini"
            @click="() => remove(node, data)">
            Delete
          </el-button>
        </span>
      </span>
    </el-tree>    

    <!-- 对话框Dialog -->
    <el-dialog
      title="提示"
      :visible.sync="dialogVisible"
      width="30%">
      <span>这是一段信息</span>
      <span slot="footer" class="dialog-footer">
      <el-button @click="dialogVisible = false">取 消</el-button>
      <el-button type="primary" @click="dialogVisible = false">确 定</el-button>
      </span>
    </el-dialog>
  </div>
</template>

<script>
  export default {
    data () {
      return {
        categorys: [],
        expandedKey: [],
        dialogVisible: false,
        defaultProps: {
          children: 'children',
          label: 'name'
        }
      }
    },
    methods: {
      // 获取商品服务的三级分类信息
      getCategory () {
        // 发送http请求
        this.$http({
          url: this.$http.adornUrl('/product/category/list/tree'),
          method: 'get'
        }).then(({data}) => {
          console.log('成功获取到商品菜单数据：', data.data)
          this.categorys = data.data
        })
      },
      append (data) {
        this.dialogVisible = true
        console.log('append', data)
      },
      remove (node, data) {
        var ids = [data.catId]
        this.$confirm(`是否删除【${data.name}】菜单?`, '提示', {
          confirmButtonText: '确定',
          cancelButtonText: '取消',
          type: 'warning'
        }).then(() => {
          this.$http({
            url: this.$http.adornUrl('/product/category/delete'),
            method: 'post',
            data: this.$http.adornData(ids, false)
          }).then(({data}) => {
            console.log('菜单删除成功!')
            // 删除后刷新菜单
            this.categorys = this.getCategory()
            // 设置需要默认展开的菜单
            this.expandedKey = [node.parent.data.catId]
          })
          this.$message({
            type: 'success',
            message: '菜单删除成功!'
          })
        }).catch(() => {
          this.$message({
            type: 'info',
            message: '已取消删除'
          })
        })
        console.log('remove', node, data)
      }
    },
    // vue生命周期 - 创建完成（可以访问当前this实例）
    created () {
      this.getCategory()
    }
  }
</script>

<style>
</style>
```



添加对话框组件的自定义内容：

![image-20240216143102916](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240216143102916.png)





```js
 <!-- 对话框Dialog -->
<el-dialog title="提示" :visible.sync="dialogVisible" width="30%">
  <el-form :model="category">
    <el-form-item label="活动名称">
      <el-input v-model="category.name" autocomplete="off"></el-input>
    </el-form-item>
  </el-form>
  <span slot="footer" class="dialog-footer">
    <el-button @click="dialogVisible = false">取 消</el-button>
    <el-button type="primary" @click="dialogVisible = false">确 定</el-button>
  </span>
</el-dialog>


<script>
  export default {
    data () {
      return {
        category: {name: ''},
        categorys: [],
        expandedKey: [],
        dialogVisible: false,
        defaultProps: {
          children: 'children',
          label: 'name'
        }
      }
    },
   // ……
}
```

![image-20240216144154149](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240216144154149.png)



总的代码：

```js
<template>
  <div>
     <!-- element-UI树形tree控件 -->
    <el-tree :data="categorys" 
      :props="defaultProps" 
      @node-click="handleNodeClick" 
      show-checkbox
      node-key="catId" 
      :default-expanded-keys="expandedKey"
      :expand-on-click-node="false">
      <span class="custom-tree-node" slot-scope="{ node, data }">
        <span>{{ node.label }}</span>
        <span>
          <el-button
            v-if="node.level <= 2"
            type="text"
            size="mini"
            @click="() => append(data)">
            Append
          </el-button>
          <el-button
            v-if="node.childNodes.length == 0"
            type="text"
            size="mini"
            @click="() => remove(node, data)">
            Delete
          </el-button>
        </span>
      </span>
    </el-tree>    

    <!-- 对话框Dialog -->
    <el-dialog title="提示" :visible.sync="dialogVisible" width="30%">
      <el-form :model="category">
        <el-form-item label="菜单名称">
          <el-input v-model="category.name" autocomplete="off"></el-input>
        </el-form-item>
      </el-form>
      <span slot="footer" class="dialog-footer">
        <el-button @click="dialogVisible = false">取 消</el-button>
        <!-- 确定调用添加分类方法 -->
        <el-button type="primary" @click="dialogVisible = addCategory()">确 定</el-button>
      </span>
    </el-dialog>
  </div>
</template>

<script>
  export default {
    data () {
      return {
        // 声明添加分类时候的对象
        category: {name: '', parentCid: 0, catLevel: 0, showStatus: 1, sort: 0},
        categorys: [],
        expandedKey: [],
        dialogVisible: false,
        defaultProps: {
          children: 'children',
          label: 'name'
        }
      }
    },
    methods: {
      // 获取商品服务的三级分类信息
      getCategory () {
        // 发送http请求
        this.$http({
          url: this.$http.adornUrl('/product/category/list/tree'),
          method: 'get'
        }).then(({data}) => {
          console.log('成功获取到商品菜单数据：', data.data)
          this.categorys = data.data
        })
      },
      // 添加三级分类方法
      addCategory () {
        // 打印提交的三级分类数据
        console.log('提交的三级分类数据', this.category)
        // 调用后端添加三级分类方法的接口
        this.$http({
          url: this.$http.adornUrl('/product/category/save'),
          method: 'post',
          data: this.$http.adornData(this.category, false)
        }).then(({data}) => {
          // 提示菜单保存成功
          this.$message({
            type: 'success',
            message: '菜单保存成功!'
          })
          // 关闭对话框
          this.dialogVisible = false
          // 删除后刷新菜单
          this.categorys = this.getCategory()
          // 设置需要默认展开的菜单
          this.expandedKey = [this.category.parentCid]
        })
      },
      // 添加按钮方法
      append (data) {
        // 显示对话框
        this.dialogVisible = true
        // 设置当前新增三级分类的父亲结点为当前点击新增结点的id
        this.category.parentCid = data.catId
        // 设置当前新增三级分类结点的level
        this.category.catLevel = data.catLevel * 1 + 1
        console.log('append', data)
      },
      // 删除按钮方法
      remove (node, data) {
        var ids = [data.catId]
        this.$confirm(`是否删除【${data.name}】菜单?`, '提示', {
          confirmButtonText: '确定',
          cancelButtonText: '取消',
          type: 'warning'
        }).then(() => {
          this.$http({
            url: this.$http.adornUrl('/product/category/delete'),
            method: 'post',
            data: this.$http.adornData(ids, false)
          }).then(({data}) => {
            console.log('菜单删除成功!')
            // 删除后刷新菜单
            this.categorys = this.getCategory()
            // 设置需要默认展开的菜单
            this.expandedKey = [node.parent.data.catId]
          })
          this.$message({
            type: 'success',
            message: '菜单删除成功!'
          })
        }).catch(() => {
          this.$message({
            type: 'info',
            message: '已取消删除'
          })
        })
        console.log('remove', node, data)
      }
    },
    // vue生命周期 - 创建完成（可以访问当前this实例）
    created () {
      this.getCategory()
    }
  }
</script>

<style>
</style>
```

后端的保存按钮接口详情见后端17.5



##### 5.5、三级分类修改

整个流程：

添加一个修改按钮，点击修改按钮，首先回显当前菜单的内容，然后进行修改，修改完成后，调用修改接口进行保存

具体代码示例：

```js
<template>
  <div>
     <!-- element-UI树形tree控件 -->
    <el-tree :data="categorys" 
      :props="defaultProps" 
      @node-click="handleNodeClick" 
      show-checkbox
      node-key="catId" 
      :default-expanded-keys="expandedKey"
      :expand-on-click-node="false">
      <span class="custom-tree-node" slot-scope="{ node, data }">
        <span>{{ node.label }}</span>
        <span>
          <el-button
            v-if="node.level <= 2"
            type="text"
            size="mini"
            @click="() => append(data)">
            新增
          </el-button>
          <el-button
            type="text"
            size="mini"
            @click="() => edit(data)">
            修改
          </el-button>
          <el-button
            v-if="node.childNodes.length == 0"
            type="text"
            size="mini"
            @click="() => remove(node, data)">
            删除
          </el-button>
        </span>
      </span>
    </el-tree>    

    <!-- 对话框Dialog -->
    <el-dialog v-bind:title="title" :visible.sync="dialogVisible" width="30%" :close-on-click-modal="false">
      <el-form :model="category">
        <el-form-item label="分类名称">
          <el-input v-model="category.name" autocomplete="off"></el-input>
        </el-form-item>
        <el-form-item label="图标">
          <el-input v-model="category.icon" autocomplete="off"></el-input>
        </el-form-item>
        <el-form-item label="计量单位">
          <el-input v-model="category.productUnit" autocomplete="off"></el-input>
        </el-form-item>
      </el-form>
      <span slot="footer" class="dialog-footer">
        <el-button @click="dialogVisible = false">取 消</el-button>
        <!-- 确定调用添加分类方法 -->
        <el-button type="primary" @click="dialogVisible = submitData()">确 定</el-button>
      </span>
    </el-dialog>
  </div>
</template>

<script>
  export default {
    data () {
      return {
        // 对话框的title动态保定
        title: '',
        // 区分对话框是新增还是修改
        dialogType: '',
        // 声明添加分类时候的对象
        category: {
          catId: null,
          name: '',
          parentCid: 0,
          catLevel: 0,
          showStatus: 1,
          sort: 0,
          productUnit: '',
          icon: ''
        },
        categorys: [],
        expandedKey: [],
        dialogVisible: false,
        defaultProps: {
          children: 'children',
          label: 'name'
        }
      }
    },
    methods: {
      // 获取商品服务的三级分类信息
      getCategory () {
        // 发送http请求
        this.$http({
          url: this.$http.adornUrl('/product/category/list/tree'),
          method: 'get'
        }).then(({data}) => {
          console.log('成功获取到商品菜单数据：', data.data)
          this.categorys = data.data
        })
      },
      // 表单提交数据
      submitData () {
        if (this.dialogType === 'add') {
          // 新增
          this.addCategory()
        } else if (this.dialogType === 'edit') {
          // 修改
          this.editCategory()
        }
      },
      // 修改三级分类方法
      editCategory () {
        // 处理发送请求数据(结构表达式)
        var {catId, name, icon, productUnit} = this.category
        // var data = {catId: catId, name: name, icon: icon, productUnit: productUnit}
        // var data = {catId, name, icon, productUnit}
        // 发送修改请求
        this.$http({
          url: this.$http.adornUrl('/product/category/update'),
          method: 'post',
          data: this.$http.adornData({catId, name, icon, productUnit}, false)
        }).then(({data}) => {
           // 提示菜单修改成功
          this.$message({
            type: 'success',
            message: '菜单修改成功!'
          })
          // 关闭对话框
          this.dialogVisible = false
          // 删除后刷新菜单
          this.categorys = this.getCategory()
          // 设置需要默认展开的菜单
          this.expandedKey = [this.category.parentCid]
        })
      },
      // 添加三级分类方法
      addCategory () {
        // 打印提交的三级分类数据
        console.log('提交的三级分类数据', this.category)
        // 调用后端添加三级分类方法的接口
        this.$http({
          url: this.$http.adornUrl('/product/category/save'),
          method: 'post',
          data: this.$http.adornData(this.category, false)
        }).then(({data}) => {
          // 提示菜单保存成功
          this.$message({
            type: 'success',
            message: '菜单保存成功!'
          })
          // 关闭对话框
          this.dialogVisible = false
          // 删除后刷新菜单
          this.categorys = this.getCategory()
          // 设置需要默认展开的菜单
          this.expandedKey = [this.category.parentCid]
        })
      },
      // 添加按钮方法
      append (data) {
        console.log('当前要新增的数据', data)
        // 设置对话框为新增
        this.dialogType = 'add'
        // 设置对话框标题
        this.title = '添加分类'
        // 显示对话框
        this.dialogVisible = true
        // 设置当前新增三级分类的父亲结点为当前点击新增结点的id
        this.category.parentCid = data.catId
        // 设置当前新增三级分类结点的level
        this.category.catLevel = data.catLevel * 1 + 1
      },
      // 修改按钮方法
      edit (data) {
        console.log('当前要修改的数据:', data)
        // 设置对话框为新增
        this.dialogType = 'edit'
        // 设置对话框标题
        this.title = '修改分类'
        // 显示对话框
        this.dialogVisible = true
        // 为当前表单对象category赋值
        // 发送请求获取当前结点最新的数据
        this.$http({
          url: this.$http.adornUrl(`/product/category/info/${data.catId}`),
          method: 'get',
          data: this.$http.adornParams({})
        }).then(({data}) => {
          // 请求成功
          console.log('回显数据内容:', data)
          this.category.name = data.data.name
          this.category.catId = data.data.catId
          this.category.icon = data.data.icon
          this.category.productUnit = data.data.productUnit
          this.category.parentCid = data.data.parentCid
        })
      },
      // 删除按钮方法
      remove (node, data) {
        var ids = [data.catId]
        this.$confirm(`是否删除【${data.name}】菜单?`, '提示', {
          confirmButtonText: '确定',
          cancelButtonText: '取消',
          type: 'warning'
        }).then(() => {
          this.$http({
            url: this.$http.adornUrl('/product/category/delete'),
            method: 'post',
            data: this.$http.adornData(ids, false)
          }).then(({data}) => {
            console.log('菜单删除成功!')
            // 删除后刷新菜单
            this.categorys = this.getCategory()
            // 设置需要默认展开的菜单
            this.expandedKey = [node.parent.data.catId]
          })
          this.$message({
            type: 'success',
            message: '菜单删除成功!'
          })
        }).catch(() => {
          this.$message({
            type: 'info',
            message: '已取消删除'
          })
        })
        console.log('remove', node, data)
      }
    },
    // vue生命周期 - 创建完成（可以访问当前this实例）
    created () {
      this.getCategory()
    }
  }
</script>

<style>
</style>
```

后端接口代码详情见17.6



##### 5.6、三级分类修改-可拖拽

在el-tree中通过draggable属性，开启结点的可拖拽功能

![image-20240217011156383](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240217011156383.png)

```js
<el-tree 
  :data="categorys" 
  :props="defaultProps"  
  show-checkbox
  node-key="catId" 
  :default-expanded-keys="expandedKey"
  :expand-on-click-node="false"
  draggable
></el-tree>
```

通过allow-drop去控制结点的拖拽成功与否

![image-20240217011149913](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240217011149913.png)

详细代码：

```html
<template>
  <div>
     <!-- element-UI树形tree控件 -->
    <el-tree 
      :data="categorys" 
      :props="defaultProps"  
      show-checkbox
      node-key="catId" 
      :default-expanded-keys="expandedKey"
      :expand-on-click-node="false"
      draggable
      :allow-drop="allowDrop"
      >
      <span class="custom-tree-node" slot-scope="{ node, data }">
        <span>{{ node.label }}</span>
        <span>
          <el-button
            v-if="node.level <= 2"
            type="text"
            size="mini"
            @click="() => append(data)">
            新增
          </el-button>
          <el-button
            type="text"
            size="mini"
            @click="() => edit(data)">
            修改
          </el-button>
          <el-button
            v-if="node.childNodes.length == 0"
            type="text"
            size="mini"
            @click="() => remove(node, data)">
            删除
          </el-button>
        </span>
      </span>
    </el-tree>    

    <!-- 对话框Dialog -->
    <el-dialog v-bind:title="title" :visible.sync="dialogVisible" width="30%" :close-on-click-modal="false">
      <el-form :model="category">
        <el-form-item label="分类名称">
          <el-input v-model="category.name" autocomplete="off"></el-input>
        </el-form-item>
        <el-form-item label="图标">
          <el-input v-model="category.icon" autocomplete="off"></el-input>
        </el-form-item>
        <el-form-item label="计量单位">
          <el-input v-model="category.productUnit" autocomplete="off"></el-input>
        </el-form-item>
      </el-form>
      <span slot="footer" class="dialog-footer">
        <el-button @click="dialogVisible = false">取 消</el-button>
        <!-- 确定调用添加分类方法 -->
        <el-button type="primary" @click="dialogVisible = submitData()">确 定</el-button>
      </span>
    </el-dialog>
  </div>
</template>

<script>
  export default {
    data () {
      return {
        // 结点最大层数
        nodeMaxLevel: 0,
        // 对话框的title动态保定
        title: '',
        // 区分对话框是新增还是修改
        dialogType: '',
        // 声明添加分类时候的对象
        category: {
          catId: null,
          name: '',
          parentCid: 0,
          catLevel: 0,
          showStatus: 1,
          sort: 0,
          productUnit: '',
          icon: ''
        },
        categorys: [],
        expandedKey: [],
        dialogVisible: false,
        defaultProps: {
          children: 'children',
          label: 'name'
        }
      }
    },
    methods: {
      // 获取商品服务的三级分类信息
      getCategory () {
        // 发送http请求
        this.$http({
          url: this.$http.adornUrl('/product/category/list/tree'),
          method: 'get'
        }).then(({data}) => {
          console.log('成功获取到商品菜单数据：', data.data)
          this.categorys = data.data
        })
      },
      // 表单提交数据
      submitData () {
        if (this.dialogType === 'add') {
          // 新增
          this.addCategory()
        } else if (this.dialogType === 'edit') {
          // 修改
          this.editCategory()
        }
      },
      // 修改三级分类方法
      editCategory () {
        // 处理发送请求数据(结构表达式)
        var {catId, name, icon, productUnit} = this.category
        // var data = {catId: catId, name: name, icon: icon, productUnit: productUnit}
        // var data = {catId, name, icon, productUnit}
        // 发送修改请求
        this.$http({
          url: this.$http.adornUrl('/product/category/update'),
          method: 'post',
          data: this.$http.adornData({catId, name, icon, productUnit}, false)
        }).then(({data}) => {
           // 提示菜单修改成功
          this.$message({
            type: 'success',
            message: '菜单修改成功!'
          })
          // 关闭对话框
          this.dialogVisible = false
          // 删除后刷新菜单
          this.categorys = this.getCategory()
          // 设置需要默认展开的菜单
          this.expandedKey = [this.category.parentCid]
        })
      },
      // 添加三级分类方法
      addCategory () {
        // 打印提交的三级分类数据
        console.log('提交的三级分类数据', this.category)
        // 调用后端添加三级分类方法的接口
        this.$http({
          url: this.$http.adornUrl('/product/category/save'),
          method: 'post',
          data: this.$http.adornData(this.category, false)
        }).then(({data}) => {
          // 提示菜单保存成功
          this.$message({
            type: 'success',
            message: '菜单保存成功!'
          })
          // 关闭对话框
          this.dialogVisible = false
          // 删除后刷新菜单
          this.categorys = this.getCategory()
          // 设置需要默认展开的菜单
          this.expandedKey = [this.category.parentCid]
        })
      },
      // 添加按钮方法
      append (data) {
        console.log('当前要新增的数据', data)
        // 设置对话框为新增
        this.dialogType = 'add'
        // 设置对话框标题
        this.title = '添加分类'
        // 显示对话框
        this.dialogVisible = true
        // 清空回显的数据
        this.restoreCategoryDefaultValue()
        console.log('清空回显数据：' + this.category)
        // 设置当前新增三级分类的父亲结点为当前点击新增结点的id
        this.category.parentCid = data.catId
        // 设置当前新增三级分类结点的level
        this.category.catLevel = data.catLevel * 1 + 1
      },
      // 修改按钮方法
      edit (data) {
        console.log('当前要修改的数据:', data)
        // 设置对话框为新增
        this.dialogType = 'edit'
        // 设置对话框标题
        this.title = '修改分类'
        // 显示对话框
        this.dialogVisible = true
        // 为当前表单对象category赋值
        // 发送请求获取当前结点最新的数据
        this.$http({
          url: this.$http.adornUrl(`/product/category/info/${data.catId}`),
          method: 'get',
          data: this.$http.adornParams({})
        }).then(({data}) => {
          // 请求成功
          console.log('回显数据内容:', data)
          this.category.name = data.data.name
          this.category.catId = data.data.catId
          this.category.icon = data.data.icon
          this.category.productUnit = data.data.productUnit
          this.category.parentCid = data.data.parentCid
        })
      },
      // 删除按钮方法
      remove (node, data) {
        var ids = [data.catId]
        this.$confirm(`是否删除【${data.name}】菜单?`, '提示', {
          confirmButtonText: '确定',
          cancelButtonText: '取消',
          type: 'warning'
        }).then(() => {
          this.$http({
            url: this.$http.adornUrl('/product/category/delete'),
            method: 'post',
            data: this.$http.adornData(ids, false)
          }).then(({data}) => {
            console.log('菜单删除成功!')
            // 删除后刷新菜单
            this.categorys = this.getCategory()
            // 设置需要默认展开的菜单
            this.expandedKey = [node.parent.data.catId]
          })
          this.$message({
            type: 'success',
            message: '菜单删除成功!'
          })
        }).catch(() => {
          this.$message({
            type: 'info',
            message: '已取消删除'
          })
        })
        console.log('remove', node, data)
      },
      // 拖拽结点放置位置判断
      allowDrop (draggingNode, dropNode, type) {
        this.nodeMaxLevel = draggingNode.data.catLevel
        // 合理：被拖动后的节点中的最大深度或所在父结点最大深度不能大于3
        console.log('allowDrop:', draggingNode, dropNode, type)
        // 获取被拖结点的深度
        this.getNodeLevel(draggingNode.data)
        let draggingNodeDeep = this.nodeMaxLevel - draggingNode.data.catLevel + 1
        console.log('当前拖拽结点深度:', draggingNodeDeep)
        console.log('目标结点的深度：', dropNode.level)
        console.log('目标结点的父亲结点的深度：', dropNode.parent.level)
        if (type === 'inner') {
          // 情况1.如果是放到目标结点内，判断当前拖拽结点的深度加上目标结点的深度 <= 3
          return (draggingNodeDeep + dropNode.level) <= 3
        } else {
          // 情况2.如果放到目标结点并列位置，判断当前拖拽结点的深度加上目标结点父亲结点的深度 <= 3
          return (draggingNodeDeep + dropNode.parent.level) <= 3
        }
      },
      // 自定义方法
      // 获取当前结点的层级
      getNodeLevel (node) {
        // 遍历所有子节点，求出最大深度
        if (node.children != null && node.children.length > 0) {
          // 当前结点有子节点
          for (let i = 0; i < node.children.length; i++) {
            if (node.children[i].catLevel > this.nodeMaxLevel) {
              this.nodeMaxLevel = node.children[i].catLevel
            }
            // 继续遍历子节点
            this.getNodeLevel(node.children[i])
          }
        }
      },
      // 重置category对象的默认值
      restoreCategoryDefaultValue () {
        this.category.catId = null
        this.category.name = ''
        this.category.parentCid = 0
        this.category.catLevel = 0
        this.category.showStatus = 1
        this.category.sort = 0
        this.category.productUnit = ''
        this.category.icon = ''
      }
    },
    // vue生命周期 - 创建完成（可以访问当前this实例）
    created () {
      this.getCategory()
    }
  }
</script>

<style>
</style>
```



##### 5.7、三级分类修改-拖拽数据同步

我们使用node-drop事件去监听拖拽的成功与否

![image-20240217111821926](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240217111821926.png)



详情：

```js
<template>
  <div>
     <!-- element-UI树形tree控件 -->
    <el-tree 
      :data="categorys" 
      :props="defaultProps"  
      show-checkbox
      node-key="catId" 
      :default-expanded-keys="expandedKey"
      :expand-on-click-node="false"
      draggable
      :allow-drop="allowDrop"
      @node-drop="handleDrop"
      >
      <span class="custom-tree-node" slot-scope="{ node, data }">
        <span>{{ node.label }}</span>
        <span>
          <el-button
            v-if="node.level <= 2"
            type="text"
            size="mini"
            @click="() => append(data)">
            新增
          </el-button>
          <el-button
            type="text"
            size="mini"
            @click="() => edit(data)">
            修改
          </el-button>
          <el-button
            v-if="node.childNodes.length == 0"
            type="text"
            size="mini"
            @click="() => remove(node, data)">
            删除
          </el-button>
        </span>
      </span>
    </el-tree>    

    <!-- 对话框Dialog -->
    <el-dialog v-bind:title="title" :visible.sync="dialogVisible" width="30%" :close-on-click-modal="false">
      <el-form :model="category">
        <el-form-item label="分类名称">
          <el-input v-model="category.name" autocomplete="off"></el-input>
        </el-form-item>
        <el-form-item label="图标">
          <el-input v-model="category.icon" autocomplete="off"></el-input>
        </el-form-item>
        <el-form-item label="计量单位">
          <el-input v-model="category.productUnit" autocomplete="off"></el-input>
        </el-form-item>
      </el-form>
      <span slot="footer" class="dialog-footer">
        <el-button @click="dialogVisible = false">取 消</el-button>
        <!-- 确定调用添加分类方法 -->
        <el-button type="primary" @click="dialogVisible = submitData()">确 定</el-button>
      </span>
    </el-dialog>
  </div>
</template>

<script>
  export default {
    data () {
      return {
        // 修改后结点内容
        updateNodes: [],
        // 结点最大层数
        nodeMaxLevel: 0,
        // 对话框的title动态保定
        title: '',
        // 区分对话框是新增还是修改
        dialogType: '',
        // 声明添加分类时候的对象
        category: {
          catId: null,
          name: '',
          parentCid: 0,
          catLevel: 0,
          showStatus: 1,
          sort: 0,
          productUnit: '',
          icon: ''
        },
        categorys: [],
        expandedKey: [],
        dialogVisible: false,
        defaultProps: {
          children: 'children',
          label: 'name'
        }
      }
    },
    methods: {
      // 获取商品服务的三级分类信息
      getCategory () {
        // 发送http请求
        this.$http({
          url: this.$http.adornUrl('/product/category/list/tree'),
          method: 'get'
        }).then(({data}) => {
          console.log('成功获取到商品菜单数据：', data.data)
          this.categorys = data.data
        })
      },
      // 表单提交数据
      submitData () {
        if (this.dialogType === 'add') {
          // 新增
          this.addCategory()
        } else if (this.dialogType === 'edit') {
          // 修改
          this.editCategory()
        }
      },
      // 修改三级分类方法
      editCategory () {
        // 处理发送请求数据(结构表达式)
        var {catId, name, icon, productUnit} = this.category
        // var data = {catId: catId, name: name, icon: icon, productUnit: productUnit}
        // var data = {catId, name, icon, productUnit}
        // 发送修改请求
        this.$http({
          url: this.$http.adornUrl('/product/category/update'),
          method: 'post',
          data: this.$http.adornData({catId, name, icon, productUnit}, false)
        }).then(({data}) => {
           // 提示菜单修改成功
          this.$message({
            type: 'success',
            message: '菜单修改成功!'
          })
          // 关闭对话框
          this.dialogVisible = false
          // 删除后刷新菜单
          this.categorys = this.getCategory()
          // 设置需要默认展开的菜单
          this.expandedKey = [this.category.parentCid]
        })
      },
      // 添加三级分类方法
      addCategory () {
        // 打印提交的三级分类数据
        console.log('提交的三级分类数据', this.category)
        // 调用后端添加三级分类方法的接口
        this.$http({
          url: this.$http.adornUrl('/product/category/save'),
          method: 'post',
          data: this.$http.adornData(this.category, false)
        }).then(({data}) => {
          // 提示菜单保存成功
          this.$message({
            type: 'success',
            message: '菜单保存成功!'
          })
          // 关闭对话框
          this.dialogVisible = false
          // 删除后刷新菜单
          this.categorys = this.getCategory()
          // 设置需要默认展开的菜单
          this.expandedKey = [this.category.parentCid]
        })
      },
      // 添加按钮方法
      append (data) {
        console.log('当前要新增的数据', data)
        // 设置对话框为新增
        this.dialogType = 'add'
        // 设置对话框标题
        this.title = '添加分类'
        // 显示对话框
        this.dialogVisible = true
        // 清空回显的数据
        this.restoreCategoryDefaultValue()
        console.log('清空回显数据：' + this.category)
        // 设置当前新增三级分类的父亲结点为当前点击新增结点的id
        this.category.parentCid = data.catId
        // 设置当前新增三级分类结点的level
        this.category.catLevel = data.catLevel * 1 + 1
      },
      // 修改按钮方法
      edit (data) {
        console.log('当前要修改的数据:', data)
        // 设置对话框为新增
        this.dialogType = 'edit'
        // 设置对话框标题
        this.title = '修改分类'
        // 显示对话框
        this.dialogVisible = true
        // 为当前表单对象category赋值
        // 发送请求获取当前结点最新的数据
        this.$http({
          url: this.$http.adornUrl(`/product/category/info/${data.catId}`),
          method: 'get',
          data: this.$http.adornParams({})
        }).then(({data}) => {
          // 请求成功
          console.log('回显数据内容:', data)
          this.category.name = data.data.name
          this.category.catId = data.data.catId
          this.category.icon = data.data.icon
          this.category.productUnit = data.data.productUnit
          this.category.parentCid = data.data.parentCid
        })
      },
      // 删除按钮方法
      remove (node, data) {
        var ids = [data.catId]
        this.$confirm(`是否删除【${data.name}】菜单?`, '提示', {
          confirmButtonText: '确定',
          cancelButtonText: '取消',
          type: 'warning'
        }).then(() => {
          this.$http({
            url: this.$http.adornUrl('/product/category/delete'),
            method: 'post',
            data: this.$http.adornData(ids, false)
          }).then(({data}) => {
            console.log('菜单删除成功!')
            // 删除后刷新菜单
            this.categorys = this.getCategory()
            // 设置需要默认展开的菜单
            this.expandedKey = [node.parent.data.catId]
          })
          this.$message({
            type: 'success',
            message: '菜单删除成功!'
          })
        }).catch(() => {
          this.$message({
            type: 'info',
            message: '已取消删除'
          })
        })
        console.log('remove', node, data)
      },
      // 拖拽结点放置位置判断
      allowDrop (draggingNode, dropNode, type) {
        this.nodeMaxLevel = draggingNode.data.catLevel
        // 合理：被拖动后的节点中的最大深度或所在父结点最大深度不能大于3
        console.log('allowDrop:', draggingNode, dropNode, type)
        // 获取被拖结点的深度
        this.getNodeLevel(draggingNode.data)
        let draggingNodeDeep = this.nodeMaxLevel - draggingNode.data.catLevel + 1
        console.log('当前拖拽结点深度:', draggingNodeDeep)
        console.log('目标结点的深度：', dropNode.level)
        console.log('目标结点的父亲结点的深度：', dropNode.parent.level)
        if (type === 'inner') {
          // 情况1.如果是放到目标结点内，判断当前拖拽结点的深度加上目标结点的深度 <= 3
          return (draggingNodeDeep + dropNode.level) <= 3
        } else {
          // 情况2.如果放到目标结点并列位置，判断当前拖拽结点的深度加上目标结点父亲结点的深度 <= 3
          return (draggingNodeDeep + dropNode.parent.level) <= 3
        }
      },
      // 拖拽节点事件
      handleDrop (draggingNode, dropNode, dropType, ev) {
        console.log('handleDrop: ', draggingNode, dropNode, dropType)
        // 获取当前结点最新的父结点id
        let pCid = 0
        // 获取当前结点最新的兄弟节点信息
        let siblings = null
        console.log('当前节点的父结点id：', pCid)
        if (dropType === 'before' || dropType === 'after') {
          // 目标节点的前或后 父结点就是目标节点的父结点
          pCid = dropNode.parent.data.catId === undefined ? 0 : dropNode.parent.data.catId
          // 目标节点的前和后 兄弟节点就是目标结点的父结点的子节点
          siblings = dropNode.parent.childNodes
        } else {
          // 目标节点中 父结点就是目标节点
          pCid = dropNode.data.catId
          // 目标结点中 兄弟节点就是目标结点的所有子节点
          siblings = dropNode.childNodes
        }
        console.log('当前节点的父结点id：', pCid)
        console.log('当前兄弟节点：', siblings)
        // 当前拖拽节点的最新顺序
        for (let i = 0; i < siblings.length; i++) {
          if (siblings[i].data.catId === draggingNode.data.catId) {
            // 如果遍历的是当前拖拽的结点
            // 当前拖拽结点的层级（原）
            let draggingNodeLevel = draggingNode.level
            if (siblings[i].level !== draggingNodeLevel) {
              // 拓展后兄弟节点的层级和当前拖拽结点原层级不同说明层级发送了变化
              draggingNodeLevel = siblings[i].level
              // 修改当前拖拽结点子节点的层级
              this.updateChildNodeLevel(siblings[i])
            }
            this.updateNodes.push({catId: siblings[i].data.catId, sort: i, parentCid: pCid, catLevel: draggingNodeLevel})
          } else {
            this.updateNodes.push({catId: siblings[i].data.catId, sort: i})
          }
        }
        console.log('当前需要更新排序的结点信息：', this.updateNodes)
        // 更新拖拽结点层级和顺序
        this.$http({
          url: this.$http.adornUrl('/product/category/update/sort'),
          method: 'post',
          data: this.$http.adornData(this.updateNodes, false)
        }).then(({data}) => {
          this.$message({
            type: 'success',
            message: '菜单顺序修改成功'
          })
          // 刷新菜单
          this.getCategory()
          // 设置需要默认展开的菜单
          this.expandedKey = [pCid]
          // 重置更新结点数据和最大层级
          this.updateNodes = []
          this.nodeMaxLevel = 0
        })
      },
      // 自定义方法
      // 更新子节点的层级
      updateChildNodeLevel (node) {
        if (node.childNodes !== null && node.childNodes.length > 0) {
          // 遍历所有子节点
          for (let i = 0; i < node.childNodes.length; i++) {
            // 当前节点
            var cNode = node.childNodes[i].data
            // 注：这里的level属性是放置后的层级
            this.updateNodes.push({catId: cNode.catId, catLevel: node.childNodes[i].level})
            // 递归更新子节点
            this.updateChildNodeLevel(node.childNodes[i])
          }
        }
      },
      // 获取当前结点的层级
      getNodeLevel (node) {
        // 遍历所有子节点，求出最大深度
        if (node.children != null && node.children.length > 0) {
          // 当前结点有子节点
          for (let i = 0; i < node.children.length; i++) {
            if (node.children[i].catLevel > this.nodeMaxLevel) {
              this.nodeMaxLevel = node.children[i].catLevel
            }
            // 继续遍历子节点
            this.getNodeLevel(node.children[i])
          }
        }
      },
      // 重置category对象的默认值
      restoreCategoryDefaultValue () {
        this.category.catId = null
        this.category.name = ''
        this.category.parentCid = 0
        this.category.catLevel = 0
        this.category.showStatus = 1
        this.category.sort = 0
        this.category.productUnit = ''
        this.category.icon = ''
      }
    },
    // vue生命周期 - 创建完成（可以访问当前this实例）
    created () {
      this.getCategory()
    }
  }
</script>

<style>
</style>
```

拖拽数据同步数据库的内容详情见后端17.7



##### 5.8、批量拖拽效果

1、添加拖动开启的开关，通过开关帮我们开启是否进行拖拽功能，防止误触

采用element-ui中的switch开关

```html
<el-switch
  v-model="value1"	//开关是否开启
  active-text="按月付费"	
  inactive-text="按年付费">
</el-switch>
```

详细代码：

```html
<template>
  <div>
    <!-- 拖拽开关 -->
    <el-switch
      v-model="draggable"	
      inactive-color=#ff0010
      active-text="开启拖拽"	
      inactive-text="关闭拖拽">
    </el-switch>
    <br/><br/>
     <!-- element-UI树形tree控件 -->
    <el-tree 
      :data="categorys" 
      :props="defaultProps"  
      show-checkbox
      node-key="catId" 
      :default-expanded-keys="expandedKey"
      :expand-on-click-node="false"
      :draggable="draggable"
      :allow-drop="allowDrop"
      @node-drop="handleDrop"
      >
      <span class="custom-tree-node" slot-scope="{ node, data }">
        <span>{{ node.label }}</span>
        <span>
          <el-button
            v-if="node.level <= 2"
            type="text"
            size="mini"
            @click="() => append(data)">
            新增
          </el-button>
          <el-button
            type="text"
            size="mini"
            @click="() => edit(data)">
            修改
          </el-button>
          <el-button
            v-if="node.childNodes.length == 0"
            type="text"
            size="mini"
            @click="() => remove(node, data)">
            删除
          </el-button>
        </span>
      </span>
    </el-tree>    

    <!-- 对话框Dialog -->
    <el-dialog v-bind:title="title" :visible.sync="dialogVisible" width="30%" :close-on-click-modal="false">
      <el-form :model="category">
        <el-form-item label="分类名称">
          <el-input v-model="category.name" autocomplete="off"></el-input>
        </el-form-item>
        <el-form-item label="图标">
          <el-input v-model="category.icon" autocomplete="off"></el-input>
        </el-form-item>
        <el-form-item label="计量单位">
          <el-input v-model="category.productUnit" autocomplete="off"></el-input>
        </el-form-item>
      </el-form>
      <span slot="footer" class="dialog-footer">
        <el-button @click="dialogVisible = false">取 消</el-button>
        <!-- 确定调用添加分类方法 -->
        <el-button type="primary" @click="dialogVisible = submitData()">确 定</el-button>
      </span>
    </el-dialog>
  </div>
</template>

<script>
  export default {
    data () {
      return {
        // 是否开启拖拽
        draggable: false,
        // 修改后结点内容
        updateNodes: [],
        // 结点最大层数
        nodeMaxLevel: 0,
        // 对话框的title动态保定
        title: '',
        // 区分对话框是新增还是修改
        dialogType: '',
        // 声明添加分类时候的对象
        category: {
          catId: null,
          name: '',
          parentCid: 0,
          catLevel: 0,
          showStatus: 1,
          sort: 0,
          productUnit: '',
          icon: ''
        },
        categorys: [],
        expandedKey: [],
        dialogVisible: false,
        defaultProps: {
          children: 'children',
          label: 'name'
        }
      }
    },
    methods: {
      // 获取商品服务的三级分类信息
      getCategory () {
        // 发送http请求
        this.$http({
          url: this.$http.adornUrl('/product/category/list/tree'),
          method: 'get'
        }).then(({data}) => {
          console.log('成功获取到商品菜单数据：', data.data)
          this.categorys = data.data
        })
      },
      // 表单提交数据
      submitData () {
        if (this.dialogType === 'add') {
          // 新增
          this.addCategory()
        } else if (this.dialogType === 'edit') {
          // 修改
          this.editCategory()
        }
      },
      // 修改三级分类方法
      editCategory () {
        // 处理发送请求数据(结构表达式)
        var {catId, name, icon, productUnit} = this.category
        // var data = {catId: catId, name: name, icon: icon, productUnit: productUnit}
        // var data = {catId, name, icon, productUnit}
        // 发送修改请求
        this.$http({
          url: this.$http.adornUrl('/product/category/update'),
          method: 'post',
          data: this.$http.adornData({catId, name, icon, productUnit}, false)
        }).then(({data}) => {
           // 提示菜单修改成功
          this.$message({
            type: 'success',
            message: '菜单修改成功!'
          })
          // 关闭对话框
          this.dialogVisible = false
          // 删除后刷新菜单
          this.categorys = this.getCategory()
          // 设置需要默认展开的菜单
          this.expandedKey = [this.category.parentCid]
        })
      },
      // 添加三级分类方法
      addCategory () {
        // 打印提交的三级分类数据
        console.log('提交的三级分类数据', this.category)
        // 调用后端添加三级分类方法的接口
        this.$http({
          url: this.$http.adornUrl('/product/category/save'),
          method: 'post',
          data: this.$http.adornData(this.category, false)
        }).then(({data}) => {
          // 提示菜单保存成功
          this.$message({
            type: 'success',
            message: '菜单保存成功!'
          })
          // 关闭对话框
          this.dialogVisible = false
          // 删除后刷新菜单
          this.categorys = this.getCategory()
          // 设置需要默认展开的菜单
          this.expandedKey = [this.category.parentCid]
        })
      },
      // 添加按钮方法
      append (data) {
        console.log('当前要新增的数据', data)
        // 设置对话框为新增
        this.dialogType = 'add'
        // 设置对话框标题
        this.title = '添加分类'
        // 显示对话框
        this.dialogVisible = true
        // 清空回显的数据
        this.restoreCategoryDefaultValue()
        console.log('清空回显数据：' + this.category)
        // 设置当前新增三级分类的父亲结点为当前点击新增结点的id
        this.category.parentCid = data.catId
        // 设置当前新增三级分类结点的level
        this.category.catLevel = data.catLevel * 1 + 1
      },
      // 修改按钮方法
      edit (data) {
        console.log('当前要修改的数据:', data)
        // 设置对话框为新增
        this.dialogType = 'edit'
        // 设置对话框标题
        this.title = '修改分类'
        // 显示对话框
        this.dialogVisible = true
        // 为当前表单对象category赋值
        // 发送请求获取当前结点最新的数据
        this.$http({
          url: this.$http.adornUrl(`/product/category/info/${data.catId}`),
          method: 'get',
          data: this.$http.adornParams({})
        }).then(({data}) => {
          // 请求成功
          console.log('回显数据内容:', data)
          this.category.name = data.data.name
          this.category.catId = data.data.catId
          this.category.icon = data.data.icon
          this.category.productUnit = data.data.productUnit
          this.category.parentCid = data.data.parentCid
        })
      },
      // 删除按钮方法
      remove (node, data) {
        var ids = [data.catId]
        this.$confirm(`是否删除【${data.name}】菜单?`, '提示', {
          confirmButtonText: '确定',
          cancelButtonText: '取消',
          type: 'warning'
        }).then(() => {
          this.$http({
            url: this.$http.adornUrl('/product/category/delete'),
            method: 'post',
            data: this.$http.adornData(ids, false)
          }).then(({data}) => {
            console.log('菜单删除成功!')
            // 删除后刷新菜单
            this.categorys = this.getCategory()
            // 设置需要默认展开的菜单
            this.expandedKey = [node.parent.data.catId]
          })
          this.$message({
            type: 'success',
            message: '菜单删除成功!'
          })
        }).catch(() => {
          this.$message({
            type: 'info',
            message: '已取消删除'
          })
        })
        console.log('remove', node, data)
      },
      // 拖拽结点放置位置判断
      allowDrop (draggingNode, dropNode, type) {
        this.nodeMaxLevel = draggingNode.data.catLevel
        // 合理：被拖动后的节点中的最大深度或所在父结点最大深度不能大于3
        console.log('allowDrop:', draggingNode, dropNode, type)
        // 获取被拖结点的深度
        this.getNodeLevel(draggingNode.data)
        let draggingNodeDeep = this.nodeMaxLevel - draggingNode.data.catLevel + 1
        console.log('当前拖拽结点深度:', draggingNodeDeep)
        console.log('目标结点的深度：', dropNode.level)
        console.log('目标结点的父亲结点的深度：', dropNode.parent.level)
        if (type === 'inner') {
          // 情况1.如果是放到目标结点内，判断当前拖拽结点的深度加上目标结点的深度 <= 3
          return (draggingNodeDeep + dropNode.level) <= 3
        } else {
          // 情况2.如果放到目标结点并列位置，判断当前拖拽结点的深度加上目标结点父亲结点的深度 <= 3
          return (draggingNodeDeep + dropNode.parent.level) <= 3
        }
      },
      // 拖拽节点事件
      handleDrop (draggingNode, dropNode, dropType, ev) {
        console.log('handleDrop: ', draggingNode, dropNode, dropType)
        // 获取当前结点最新的父结点id
        let pCid = 0
        // 获取当前结点最新的兄弟节点信息
        let siblings = null
        console.log('当前节点的父结点id：', pCid)
        if (dropType === 'before' || dropType === 'after') {
          // 目标节点的前或后 父结点就是目标节点的父结点
          pCid = dropNode.parent.data.catId === undefined ? 0 : dropNode.parent.data.catId
          // 目标节点的前和后 兄弟节点就是目标结点的父结点的子节点
          siblings = dropNode.parent.childNodes
        } else {
          // 目标节点中 父结点就是目标节点
          pCid = dropNode.data.catId
          // 目标结点中 兄弟节点就是目标结点的所有子节点
          siblings = dropNode.childNodes
        }
        console.log('当前节点的父结点id：', pCid)
        console.log('当前兄弟节点：', siblings)
        // 当前拖拽节点的最新顺序
        for (let i = 0; i < siblings.length; i++) {
          if (siblings[i].data.catId === draggingNode.data.catId) {
            // 如果遍历的是当前拖拽的结点
            // 当前拖拽结点的层级（原）
            let draggingNodeLevel = draggingNode.level
            if (siblings[i].level !== draggingNodeLevel) {
              // 拓展后兄弟节点的层级和当前拖拽结点原层级不同说明层级发送了变化
              draggingNodeLevel = siblings[i].level
              // 修改当前拖拽结点子节点的层级
              this.updateChildNodeLevel(siblings[i])
            }
            this.updateNodes.push({catId: siblings[i].data.catId, sort: i, parentCid: pCid, catLevel: draggingNodeLevel})
          } else {
            this.updateNodes.push({catId: siblings[i].data.catId, sort: i})
          }
        }
        console.log('当前需要更新排序的结点信息：', this.updateNodes)
        // 更新拖拽结点层级和顺序
        this.$http({
          url: this.$http.adornUrl('/product/category/update/sort'),
          method: 'post',
          data: this.$http.adornData(this.updateNodes, false)
        }).then(({data}) => {
          this.$message({
            type: 'success',
            message: '菜单顺序修改成功'
          })
          // 刷新菜单
          this.getCategory()
          // 设置需要默认展开的菜单
          this.expandedKey = [pCid]
          // 重置更新结点数据和最大层级
          this.updateNodes = []
          this.nodeMaxLevel = 0
        })
      },
      // 自定义方法
      // 更新子节点的层级
      updateChildNodeLevel (node) {
        if (node.childNodes !== null && node.childNodes.length > 0) {
          // 遍历所有子节点
          for (let i = 0; i < node.childNodes.length; i++) {
            // 当前节点
            var cNode = node.childNodes[i].data
            // 注：这里的level属性是放置后的层级
            this.updateNodes.push({catId: cNode.catId, catLevel: node.childNodes[i].level})
            // 递归更新子节点
            this.updateChildNodeLevel(node.childNodes[i])
          }
        }
      },
      // 获取当前结点的层级
      getNodeLevel (node) {
        // 遍历所有子节点，求出最大深度
        if (node.children != null && node.children.length > 0) {
          // 当前结点有子节点
          for (let i = 0; i < node.children.length; i++) {
            if (node.children[i].catLevel > this.nodeMaxLevel) {
              this.nodeMaxLevel = node.children[i].catLevel
            }
            // 继续遍历子节点
            this.getNodeLevel(node.children[i])
          }
        }
      },
      // 重置category对象的默认值
      restoreCategoryDefaultValue () {
        this.category.catId = null
        this.category.name = ''
        this.category.parentCid = 0
        this.category.catLevel = 0
        this.category.showStatus = 1
        this.category.sort = 0
        this.category.productUnit = ''
        this.category.icon = ''
      }
    },
    // vue生命周期 - 创建完成（可以访问当前this实例）
    created () {
      this.getCategory()
    }
  }
</script>

<style>
</style>
```



2、批量保存

解决每拖动一个结点都要和数据进行频繁的交互问题

详情

```HTML
<template>
  <div>
    <!-- 拖拽开关 -->
    <el-switch
      v-model="draggable"	
      inactive-color=#ff0010
      active-text="开启拖拽"	
      inactive-text="关闭拖拽">
    </el-switch>
    <el-button v-if="draggable" @click="batchSave">批量保存</el-button>
     <!-- element-UI树形tree控件 -->
    <el-tree 
      :data="categorys" 
      :props="defaultProps"  
      show-checkbox
      node-key="catId" 
      :default-expanded-keys="expandedKey"
      :expand-on-click-node="false"
      :draggable="draggable"
      :allow-drop="allowDrop"
      @node-drop="handleDrop"
      >
      <span class="custom-tree-node" slot-scope="{ node, data }">
        <span>{{ node.label }}</span>
        <span>
          <el-button
            v-if="node.level <= 2"
            type="text"
            size="mini"
            @click="() => append(data)">
            新增
          </el-button>
          <el-button
            type="text"
            size="mini"
            @click="() => edit(data)">
            修改
          </el-button>
          <el-button
            v-if="node.childNodes.length == 0"
            type="text"
            size="mini"
            @click="() => remove(node, data)">
            删除
          </el-button>
        </span>
      </span>
    </el-tree>    

    <!-- 对话框Dialog -->
    <el-dialog v-bind:title="title" :visible.sync="dialogVisible" width="30%" :close-on-click-modal="false">
      <el-form :model="category">
        <el-form-item label="分类名称">
          <el-input v-model="category.name" autocomplete="off"></el-input>
        </el-form-item>
        <el-form-item label="图标">
          <el-input v-model="category.icon" autocomplete="off"></el-input>
        </el-form-item>
        <el-form-item label="计量单位">
          <el-input v-model="category.productUnit" autocomplete="off"></el-input>
        </el-form-item>
      </el-form>
      <span slot="footer" class="dialog-footer">
        <el-button @click="dialogVisible = false">取 消</el-button>
        <!-- 确定调用添加分类方法 -->
        <el-button type="primary" @click="dialogVisible = submitData()">确 定</el-button>
      </span>
    </el-dialog>
  </div>
</template>

<script>
  export default {
    data () {
      return {
        // 当前结点拖动后最新的父结点id列表（用于保存后的展开）
        pCid: [],
        // 是否开启拖拽
        draggable: false,
        // 修改后结点内容
        updateNodes: [],
        // 结点最大层数
        nodeMaxLevel: 0,
        // 对话框的title动态保定
        title: '',
        // 区分对话框是新增还是修改
        dialogType: '',
        // 声明添加分类时候的对象
        category: {
          catId: null,
          name: '',
          parentCid: 0,
          catLevel: 0,
          showStatus: 1,
          sort: 0,
          productUnit: '',
          icon: ''
        },
        // 全部分类数据
        categorys: [],
        // 存储刷新页面后展开结点信息
        expandedKey: [],
        // 表单的可见
        dialogVisible: false,
        // 树结点默认的显示和子节点信息配置
        defaultProps: {
          children: 'children',
          label: 'name'
        }
      }
    },
    methods: {
      // 获取商品服务的三级分类信息
      getCategory () {
        // 发送http请求
        this.$http({
          url: this.$http.adornUrl('/product/category/list/tree'),
          method: 'get'
        }).then(({data}) => {
          console.log('成功获取到商品菜单数据：', data.data)
          this.categorys = data.data
        })
      },
      // 表单提交数据
      submitData () {
        if (this.dialogType === 'add') {
          // 新增
          this.addCategory()
        } else if (this.dialogType === 'edit') {
          // 修改
          this.editCategory()
        }
      },
      // 修改三级分类方法
      editCategory () {
        // 处理发送请求数据(结构表达式)
        var {catId, name, icon, productUnit} = this.category
        // var data = {catId: catId, name: name, icon: icon, productUnit: productUnit}
        // var data = {catId, name, icon, productUnit}
        // 发送修改请求
        this.$http({
          url: this.$http.adornUrl('/product/category/update'),
          method: 'post',
          data: this.$http.adornData({catId, name, icon, productUnit}, false)
        }).then(({data}) => {
           // 提示菜单修改成功
          this.$message({
            type: 'success',
            message: '菜单修改成功!'
          })
          // 关闭对话框
          this.dialogVisible = false
          // 删除后刷新菜单
          this.categorys = this.getCategory()
          // 设置需要默认展开的菜单
          this.expandedKey = [this.category.parentCid]
        })
      },
      // 添加三级分类方法
      addCategory () {
        // 打印提交的三级分类数据
        console.log('提交的三级分类数据', this.category)
        // 调用后端添加三级分类方法的接口
        this.$http({
          url: this.$http.adornUrl('/product/category/save'),
          method: 'post',
          data: this.$http.adornData(this.category, false)
        }).then(({data}) => {
          // 提示菜单保存成功
          this.$message({
            type: 'success',
            message: '菜单保存成功!'
          })
          // 关闭对话框
          this.dialogVisible = false
          // 删除后刷新菜单
          this.categorys = this.getCategory()
          // 设置需要默认展开的菜单
          this.expandedKey = [this.category.parentCid]
        })
      },
      // 添加按钮方法
      append (data) {
        console.log('当前要新增的数据', data)
        // 设置对话框为新增
        this.dialogType = 'add'
        // 设置对话框标题
        this.title = '添加分类'
        // 显示对话框
        this.dialogVisible = true
        // 清空回显的数据
        this.restoreCategoryDefaultValue()
        console.log('清空回显数据：' + this.category)
        // 设置当前新增三级分类的父亲结点为当前点击新增结点的id
        this.category.parentCid = data.catId
        // 设置当前新增三级分类结点的level
        this.category.catLevel = data.catLevel * 1 + 1
      },
      // 修改按钮方法
      edit (data) {
        console.log('当前要修改的数据:', data)
        // 设置对话框为新增
        this.dialogType = 'edit'
        // 设置对话框标题
        this.title = '修改分类'
        // 显示对话框
        this.dialogVisible = true
        // 为当前表单对象category赋值
        // 发送请求获取当前结点最新的数据
        this.$http({
          url: this.$http.adornUrl(`/product/category/info/${data.catId}`),
          method: 'get',
          data: this.$http.adornParams({})
        }).then(({data}) => {
          // 请求成功
          console.log('回显数据内容:', data)
          this.category.name = data.data.name
          this.category.catId = data.data.catId
          this.category.icon = data.data.icon
          this.category.productUnit = data.data.productUnit
          this.category.parentCid = data.data.parentCid
        })
      },
      // 删除按钮方法
      remove (node, data) {
        var ids = [data.catId]
        this.$confirm(`是否删除【${data.name}】菜单?`, '提示', {
          confirmButtonText: '确定',
          cancelButtonText: '取消',
          type: 'warning'
        }).then(() => {
          this.$http({
            url: this.$http.adornUrl('/product/category/delete'),
            method: 'post',
            data: this.$http.adornData(ids, false)
          }).then(({data}) => {
            console.log('菜单删除成功!')
            // 删除后刷新菜单
            this.categorys = this.getCategory()
            // 设置需要默认展开的菜单
            this.expandedKey = [node.parent.data.catId]
          })
          this.$message({
            type: 'success',
            message: '菜单删除成功!'
          })
        }).catch(() => {
          this.$message({
            type: 'info',
            message: '已取消删除'
          })
        })
        console.log('remove', node, data)
      },
      // 批量保存结点拖动
      batchSave () {
        // 更新拖拽结点层级和顺序
        this.$http({
          url: this.$http.adornUrl('/product/category/update/sort'),
          method: 'post',
          data: this.$http.adornData(this.updateNodes, false)
        }).then(({data}) => {
          this.$message({
            type: 'success',
            message: '菜单顺序修改成功'
          })
          // 刷新菜单
          this.getCategory()
          // 设置需要默认展开的菜单
          this.expandedKey = this.pCid
          // 重置更新结点数据和最大层级
          this.updateNodes = []
          this.nodeMaxLevel = 0
          this.pCid = []
        })
      },
      // 拖拽结点放置位置判断
      allowDrop (draggingNode, dropNode, type) {
        this.nodeMaxLevel = draggingNode.data.catLevel
        // 合理：被拖动后的节点中的最大深度或所在父结点最大深度不能大于3
        console.log('allowDrop:', draggingNode, dropNode, type)
        // 获取被拖结点的深度
        this.getNodeLevel(draggingNode)
        let draggingNodeDeep = Math.abs(this.nodeMaxLevel - draggingNode.level + 1)
        console.log('当前拖拽结点深度:', draggingNodeDeep)
        console.log('目标结点的深度：', dropNode.level)
        console.log('目标结点的父亲结点的深度：', dropNode.parent.level)
        if (type === 'inner') {
          // 情况1.如果是放到目标结点内，判断当前拖拽结点的深度加上目标结点的深度 <= 3
          return (draggingNodeDeep + dropNode.level) <= 3
        } else {
          // 情况2.如果放到目标结点并列位置，判断当前拖拽结点的深度加上目标结点父亲结点的深度 <= 3
          return (draggingNodeDeep + dropNode.parent.level) <= 3
        }
      },
      // 拖拽节点事件
      handleDrop (draggingNode, dropNode, dropType, ev) {
        console.log('handleDrop: ', draggingNode, dropNode, dropType)
        // 获取当前结点最新的父结点id
        let pCid = 0
        // 获取当前结点最新的兄弟节点信息
        let siblings = null
        console.log('当前节点的父结点id：', pCid)
        if (dropType === 'before' || dropType === 'after') {
          // 目标节点的前或后 父结点就是目标节点的父结点
          pCid = dropNode.parent.data.catId === undefined ? 0 : dropNode.parent.data.catId
          // 目标节点的前和后 兄弟节点就是目标结点的父结点的子节点
          siblings = dropNode.parent.childNodes
        } else {
          // 目标节点中 父结点就是目标节点
          pCid = dropNode.data.catId
          // 目标结点中 兄弟节点就是目标结点的所有子节点
          siblings = dropNode.childNodes
        }
        this.pCid.push(pCid)
        console.log('当前节点的父结点id：', pCid)
        console.log('当前兄弟节点：', siblings)
        // 当前拖拽节点的最新顺序
        for (let i = 0; i < siblings.length; i++) {
          if (siblings[i].data.catId === draggingNode.data.catId) {
            // 如果遍历的是当前拖拽的结点
            // 当前拖拽结点的层级（原）
            let draggingNodeLevel = draggingNode.level
            if (siblings[i].level !== draggingNodeLevel) {
              // 拓展后兄弟节点的层级和当前拖拽结点原层级不同说明层级发送了变化
              draggingNodeLevel = siblings[i].level
              // 修改当前拖拽结点子节点的层级
              this.updateChildNodeLevel(siblings[i])
            }
            this.updateNodes.push({catId: siblings[i].data.catId, sort: i, parentCid: pCid, catLevel: draggingNodeLevel})
          } else {
            this.updateNodes.push({catId: siblings[i].data.catId, sort: i})
          }
        }
        console.log('当前需要更新排序的结点信息：', this.updateNodes)
      },
      // 自定义方法
      // 更新子节点的层级
      updateChildNodeLevel (node) {
        if (node.childNodes !== null && node.childNodes.length > 0) {
          // 遍历所有子节点
          for (let i = 0; i < node.childNodes.length; i++) {
            // 当前节点
            var cNode = node.childNodes[i].data
            // 注：这里的level属性是放置后的层级
            this.updateNodes.push({catId: cNode.catId, catLevel: node.childNodes[i].level})
            // 递归更新子节点
            this.updateChildNodeLevel(node.childNodes[i])
          }
        }
      },
      // 获取当前结点的层级
      getNodeLevel (node) {
        // 遍历所有子节点，求出最大深度
        if (node.childNodes != null && node.childNodes.length > 0) {
          // 当前结点有子节点
          for (let i = 0; i < node.childNodes.length; i++) {
            if (node.childNodes[i].level > this.nodeMaxLevel) {
              this.nodeMaxLevel = node.childNodes[i].level
            }
            // 继续遍历子节点
            this.getNodeLevel(node.childNodes[i])
          }
        }
      },
      // 重置category对象的默认值
      restoreCategoryDefaultValue () {
        this.category.catId = null
        this.category.name = ''
        this.category.parentCid = 0
        this.category.catLevel = 0
        this.category.showStatus = 1
        this.category.sort = 0
        this.category.productUnit = ''
        this.category.icon = ''
      }
    },
    // vue生命周期 - 创建完成（可以访问当前this实例）
    created () {
      this.getCategory()
    }
  }
</script>

<style>
</style>
```





##### 5.9、批量删除

```html
<template>
  <div>
    <!-- 拖拽开关 -->
    <el-switch
      v-model="draggable"	
      inactive-color=#ff0010
      active-text="开启拖拽"	
      inactive-text="关闭拖拽">
    </el-switch>
    <el-button v-if="draggable" @click="batchSave">批量保存</el-button>
    <el-button type='danger' @click="batchDelete">批量删除</el-button>
     <!-- element-UI树形tree控件 -->
    <el-tree 
      :data="categorys" 
      :props="defaultProps"  
      show-checkbox
      node-key="catId" 
      :default-expanded-keys="expandedKey"
      :expand-on-click-node="false"
      :draggable="draggable"
      :allow-drop="allowDrop"
      @node-drop="handleDrop"
      ref="categoryTree"
      >
      <span class="custom-tree-node" slot-scope="{ node, data }">
        <span>{{ node.label }}</span>
        <span>
          <el-button
            v-if="node.level <= 2"
            type="text"
            size="mini"
            @click="() => append(data)">
            新增
          </el-button>
          <el-button
            type="text"
            size="mini"
            @click="() => edit(data)">
            修改
          </el-button>
          <el-button
            v-if="node.childNodes.length == 0"
            type="text"
            size="mini"
            @click="() => remove(node, data)">
            删除
          </el-button>
        </span>
      </span>
    </el-tree>    

    <!-- 对话框Dialog -->
    <el-dialog v-bind:title="title" :visible.sync="dialogVisible" width="30%" :close-on-click-modal="false">
      <el-form :model="category">
        <el-form-item label="分类名称">
          <el-input v-model="category.name" autocomplete="off"></el-input>
        </el-form-item>
        <el-form-item label="图标">
          <el-input v-model="category.icon" autocomplete="off"></el-input>
        </el-form-item>
        <el-form-item label="计量单位">
          <el-input v-model="category.productUnit" autocomplete="off"></el-input>
        </el-form-item>
      </el-form>
      <span slot="footer" class="dialog-footer">
        <el-button @click="dialogVisible = false">取 消</el-button>
        <!-- 确定调用添加分类方法 -->
        <el-button type="primary" @click="dialogVisible = submitData()">确 定</el-button>
      </span>
    </el-dialog>
  </div>
</template>

<script>
  export default {
    data () {
      return {
        // 当前结点拖动后最新的父结点id列表（用于保存后的展开）
        pCid: [],
        // 是否开启拖拽
        draggable: false,
        // 修改后结点内容
        updateNodes: [],
        // 结点最大层数
        nodeMaxLevel: 0,
        // 对话框的title动态保定
        title: '',
        // 区分对话框是新增还是修改
        dialogType: '',
        // 声明添加分类时候的对象
        category: {
          catId: null,
          name: '',
          parentCid: 0,
          catLevel: 0,
          showStatus: 1,
          sort: 0,
          productUnit: '',
          icon: ''
        },
        // 全部分类数据
        categorys: [],
        // 存储刷新页面后展开结点信息
        expandedKey: [],
        // 表单的可见
        dialogVisible: false,
        // 树结点默认的显示和子节点信息配置
        defaultProps: {
          children: 'children',
          label: 'name'
        }
      }
    },
    methods: {
      // 获取商品服务的三级分类信息
      getCategory () {
        // 发送http请求
        this.$http({
          url: this.$http.adornUrl('/product/category/list/tree'),
          method: 'get'
        }).then(({data}) => {
          console.log('成功获取到商品菜单数据：', data.data)
          this.categorys = data.data
        })
      },
      // 表单提交数据
      submitData () {
        if (this.dialogType === 'add') {
          // 新增
          this.addCategory()
        } else if (this.dialogType === 'edit') {
          // 修改
          this.editCategory()
        }
      },
      // 修改三级分类方法
      editCategory () {
        // 处理发送请求数据(结构表达式)
        var {catId, name, icon, productUnit} = this.category
        // var data = {catId: catId, name: name, icon: icon, productUnit: productUnit}
        // var data = {catId, name, icon, productUnit}
        // 发送修改请求
        this.$http({
          url: this.$http.adornUrl('/product/category/update'),
          method: 'post',
          data: this.$http.adornData({catId, name, icon, productUnit}, false)
        }).then(({data}) => {
           // 提示菜单修改成功
          this.$message({
            type: 'success',
            message: '菜单修改成功!'
          })
          // 关闭对话框
          this.dialogVisible = false
          // 删除后刷新菜单
          this.categorys = this.getCategory()
          // 设置需要默认展开的菜单
          this.expandedKey = [this.category.parentCid]
        })
      },
      // 添加三级分类方法
      addCategory () {
        // 打印提交的三级分类数据
        console.log('提交的三级分类数据', this.category)
        // 调用后端添加三级分类方法的接口
        this.$http({
          url: this.$http.adornUrl('/product/category/save'),
          method: 'post',
          data: this.$http.adornData(this.category, false)
        }).then(({data}) => {
          // 提示菜单保存成功
          this.$message({
            type: 'success',
            message: '菜单保存成功!'
          })
          // 关闭对话框
          this.dialogVisible = false
          // 删除后刷新菜单
          this.categorys = this.getCategory()
          // 设置需要默认展开的菜单
          this.expandedKey = [this.category.parentCid]
        })
      },
      // 添加按钮方法
      append (data) {
        console.log('当前要新增的数据', data)
        // 设置对话框为新增
        this.dialogType = 'add'
        // 设置对话框标题
        this.title = '添加分类'
        // 显示对话框
        this.dialogVisible = true
        // 清空回显的数据
        this.restoreCategoryDefaultValue()
        console.log('清空回显数据：' + this.category)
        // 设置当前新增三级分类的父亲结点为当前点击新增结点的id
        this.category.parentCid = data.catId
        // 设置当前新增三级分类结点的level
        this.category.catLevel = data.catLevel * 1 + 1
      },
      // 修改按钮方法
      edit (data) {
        console.log('当前要修改的数据:', data)
        // 设置对话框为新增
        this.dialogType = 'edit'
        // 设置对话框标题
        this.title = '修改分类'
        // 显示对话框
        this.dialogVisible = true
        // 为当前表单对象category赋值
        // 发送请求获取当前结点最新的数据
        this.$http({
          url: this.$http.adornUrl(`/product/category/info/${data.catId}`),
          method: 'get',
          data: this.$http.adornParams({})
        }).then(({data}) => {
          // 请求成功
          console.log('回显数据内容:', data)
          this.category.name = data.data.name
          this.category.catId = data.data.catId
          this.category.icon = data.data.icon
          this.category.productUnit = data.data.productUnit
          this.category.parentCid = data.data.parentCid
        })
      },
      // 删除按钮方法
      remove (node, data) {
        var ids = [data.catId]
        this.$confirm(`是否删除【${data.name}】菜单?`, '提示', {
          confirmButtonText: '确定',
          cancelButtonText: '取消',
          type: 'warning'
        }).then(() => {
          this.$http({
            url: this.$http.adornUrl('/product/category/delete'),
            method: 'post',
            data: this.$http.adornData(ids, false)
          }).then(({data}) => {
            console.log('菜单删除成功!')
            // 删除后刷新菜单
            this.categorys = this.getCategory()
            // 设置需要默认展开的菜单
            this.expandedKey = [node.parent.data.catId]
          })
          this.$message({
            type: 'success',
            message: '菜单删除成功!'
          })
        }).catch(() => {
          this.$message({
            type: 'info',
            message: '已取消删除'
          })
        })
        console.log('remove', node, data)
      },
      // 批量删除结点
      batchDelete () {
        // 删除结点的id
        let catIds = []
        let checkedNodes = this.$refs.categoryTree.getCheckedNodes()
        console.log('当前批量删除选中结点信息：', checkedNodes)
        // 封装删除结点id
        for (let i = 0; i < checkedNodes.length; i++) {
          catIds.push(checkedNodes[i].catId)
        }
        this.$confirm(`是否批量删除【${catIds}】菜单?`, '提示', {
          confirmButtonText: '确定',
          cancelButtonText: '取消',
          type: 'warning'
        }).then(() => {
          // 发送删除请求
          this.$http({
            url: this.$http.adornUrl('/product/category/delete'),
            method: 'post',
            data: this.$http.adornData(catIds, false)
          }).then(({data}) => {
            // 提示删除成功
            this.$message({
              type: 'success',
              message: '菜单批量删除成功'
            })
            // 刷新菜单
            this.getCategory()
          })
        }).catch(() => {
          this.$message({
            type: 'info',
            message: '已取消批量删除'
          })
        })
      },
      // 批量保存结点拖动
      batchSave () {
        // 更新拖拽结点层级和顺序
        this.$http({
          url: this.$http.adornUrl('/product/category/update/sort'),
          method: 'post',
          data: this.$http.adornData(this.updateNodes, false)
        }).then(({data}) => {
          this.$message({
            type: 'success',
            message: '菜单顺序修改成功'
          })
          // 刷新菜单
          this.getCategory()
          // 设置需要默认展开的菜单
          this.expandedKey = this.pCid
          // 重置更新结点数据和最大层级
          this.updateNodes = []
          this.nodeMaxLevel = 0
          this.pCid = []
        })
      },
      // 拖拽结点放置位置判断
      allowDrop (draggingNode, dropNode, type) {
        this.nodeMaxLevel = draggingNode.data.catLevel
        // 合理：被拖动后的节点中的最大深度或所在父结点最大深度不能大于3
        console.log('allowDrop:', draggingNode, dropNode, type)
        // 获取被拖结点的深度
        this.getNodeLevel(draggingNode)
        let draggingNodeDeep = Math.abs(this.nodeMaxLevel - draggingNode.level + 1)
        console.log('当前拖拽结点深度:', draggingNodeDeep)
        console.log('目标结点的深度：', dropNode.level)
        console.log('目标结点的父亲结点的深度：', dropNode.parent.level)
        if (type === 'inner') {
          // 情况1.如果是放到目标结点内，判断当前拖拽结点的深度加上目标结点的深度 <= 3
          return (draggingNodeDeep + dropNode.level) <= 3
        } else {
          // 情况2.如果放到目标结点并列位置，判断当前拖拽结点的深度加上目标结点父亲结点的深度 <= 3
          return (draggingNodeDeep + dropNode.parent.level) <= 3
        }
      },
      // 拖拽节点事件
      handleDrop (draggingNode, dropNode, dropType, ev) {
        console.log('handleDrop: ', draggingNode, dropNode, dropType)
        // 获取当前结点最新的父结点id
        let pCid = 0
        // 获取当前结点最新的兄弟节点信息
        let siblings = null
        console.log('当前节点的父结点id：', pCid)
        if (dropType === 'before' || dropType === 'after') {
          // 目标节点的前或后 父结点就是目标节点的父结点
          pCid = dropNode.parent.data.catId === undefined ? 0 : dropNode.parent.data.catId
          // 目标节点的前和后 兄弟节点就是目标结点的父结点的子节点
          siblings = dropNode.parent.childNodes
        } else {
          // 目标节点中 父结点就是目标节点
          pCid = dropNode.data.catId
          // 目标结点中 兄弟节点就是目标结点的所有子节点
          siblings = dropNode.childNodes
        }
        this.pCid.push(pCid)
        console.log('当前节点的父结点id：', pCid)
        console.log('当前兄弟节点：', siblings)
        // 当前拖拽节点的最新顺序
        for (let i = 0; i < siblings.length; i++) {
          if (siblings[i].data.catId === draggingNode.data.catId) {
            // 如果遍历的是当前拖拽的结点
            // 当前拖拽结点的层级（原）
            let draggingNodeLevel = draggingNode.level
            if (siblings[i].level !== draggingNodeLevel) {
              // 拓展后兄弟节点的层级和当前拖拽结点原层级不同说明层级发送了变化
              draggingNodeLevel = siblings[i].level
              // 修改当前拖拽结点子节点的层级
              this.updateChildNodeLevel(siblings[i])
            }
            this.updateNodes.push({catId: siblings[i].data.catId, sort: i, parentCid: pCid, catLevel: draggingNodeLevel})
          } else {
            this.updateNodes.push({catId: siblings[i].data.catId, sort: i})
          }
        }
        console.log('当前需要更新排序的结点信息：', this.updateNodes)
      },
      // 自定义方法
      // 更新子节点的层级
      updateChildNodeLevel (node) {
        if (node.childNodes !== null && node.childNodes.length > 0) {
          // 遍历所有子节点
          for (let i = 0; i < node.childNodes.length; i++) {
            // 当前节点
            var cNode = node.childNodes[i].data
            // 注：这里的level属性是放置后的层级
            this.updateNodes.push({catId: cNode.catId, catLevel: node.childNodes[i].level})
            // 递归更新子节点
            this.updateChildNodeLevel(node.childNodes[i])
          }
        }
      },
      // 获取当前结点的层级
      getNodeLevel (node) {
        // 遍历所有子节点，求出最大深度
        if (node.childNodes != null && node.childNodes.length > 0) {
          // 当前结点有子节点
          for (let i = 0; i < node.childNodes.length; i++) {
            if (node.childNodes[i].level > this.nodeMaxLevel) {
              this.nodeMaxLevel = node.childNodes[i].level
            }
            // 继续遍历子节点
            this.getNodeLevel(node.childNodes[i])
          }
        }
      },
      // 重置category对象的默认值
      restoreCategoryDefaultValue () {
        this.category.catId = null
        this.category.name = ''
        this.category.parentCid = 0
        this.category.catLevel = 0
        this.category.showStatus = 1
        this.category.sort = 0
        this.category.productUnit = ''
        this.category.icon = ''
      }
    },
    // vue生命周期 - 创建完成（可以访问当前this实例）
    created () {
      this.getCategory()
    }
  }
</script>

<style>
</style>
```

##### 5.10、优化

1、优化内容：

- 批量删除显示名字
- 调整新增、修改、删除的样式位置



2、代码：

```html
<template>
  <div>
    <!-- 拖拽开关 -->
    <el-switch
      v-model="draggable"	
      inactive-color=#ff0010
      active-text="开启拖拽"	
      inactive-text="关闭拖拽">
    </el-switch>
    <el-button v-if="draggable" @click="batchSave">批量保存</el-button>
    <el-button type='danger' @click="batchDelete">批量删除</el-button>
     <!-- element-UI树形tree控件 -->
    <el-tree 
      :data="categorys" 
      :props="defaultProps"  
      show-checkbox
      node-key="catId" 
      :default-expanded-keys="expandedKey"
      :expand-on-click-node="false"
      :draggable="draggable"
      :allow-drop="allowDrop"
      @node-drop="handleDrop"
      ref="categoryTree"
      >
      <span class="custom-tree-node" slot-scope="{ node, data }">
        <span>{{ node.label }}</span>
        <span>
          <el-button
            v-if="node.level <= 2"
            type="text"
            size="mini"
            @click="() => append(data)">
            新增
          </el-button>
          <el-button
            type="text"
            size="mini"
            @click="() => edit(data)">
            修改
          </el-button>
          <el-button
            v-if="node.childNodes.length == 0"
            type="text"
            size="mini"
            @click="() => remove(node, data)">
            删除
          </el-button>
        </span>
      </span>
    </el-tree>    

    <!-- 对话框Dialog -->
    <el-dialog v-bind:title="title" :visible.sync="dialogVisible" width="30%" :close-on-click-modal="false">
      <el-form :model="category">
        <el-form-item label="分类名称">
          <el-input v-model="category.name" autocomplete="off"></el-input>
        </el-form-item>
        <el-form-item label="图标">
          <el-input v-model="category.icon" autocomplete="off"></el-input>
        </el-form-item>
        <el-form-item label="计量单位">
          <el-input v-model="category.productUnit" autocomplete="off"></el-input>
        </el-form-item>
      </el-form>
      <span slot="footer" class="dialog-footer">
        <el-button @click="dialogVisible = false">取 消</el-button>
        <!-- 确定调用添加分类方法 -->
        <el-button type="primary" @click="dialogVisible = submitData()">确 定</el-button>
      </span>
    </el-dialog>
  </div>
</template>

<script>
  export default {
    data () {
      return {
        // 当前结点拖动后最新的父结点id列表（用于保存后的展开）
        pCid: [],
        // 是否开启拖拽
        draggable: false,
        // 修改后结点内容
        updateNodes: [],
        // 结点最大层数
        nodeMaxLevel: 0,
        // 对话框的title动态保定
        title: '',
        // 区分对话框是新增还是修改
        dialogType: '',
        // 声明添加分类时候的对象
        category: {
          catId: null,
          name: '',
          parentCid: 0,
          catLevel: 0,
          showStatus: 1,
          sort: 0,
          productUnit: '',
          icon: ''
        },
        // 全部分类数据
        categorys: [],
        // 存储刷新页面后展开结点信息
        expandedKey: [],
        // 表单的可见
        dialogVisible: false,
        // 树结点默认的显示和子节点信息配置
        defaultProps: {
          children: 'children',
          label: 'name'
        }
      }
    },
    methods: {
      // 获取商品服务的三级分类信息
      getCategory () {
        // 发送http请求
        this.$http({
          url: this.$http.adornUrl('/product/category/list/tree'),
          method: 'get'
        }).then(({data}) => {
          console.log('成功获取到商品菜单数据：', data.data)
          this.categorys = data.data
        })
      },
      // 表单提交数据
      submitData () {
        if (this.dialogType === 'add') {
          // 新增
          this.addCategory()
        } else if (this.dialogType === 'edit') {
          // 修改
          this.editCategory()
        }
      },
      // 修改三级分类方法
      editCategory () {
        // 处理发送请求数据(结构表达式)
        var {catId, name, icon, productUnit} = this.category
        // var data = {catId: catId, name: name, icon: icon, productUnit: productUnit}
        // var data = {catId, name, icon, productUnit}
        // 发送修改请求
        this.$http({
          url: this.$http.adornUrl('/product/category/update'),
          method: 'post',
          data: this.$http.adornData({catId, name, icon, productUnit}, false)
        }).then(({data}) => {
           // 提示菜单修改成功
          this.$message({
            type: 'success',
            message: '菜单修改成功!'
          })
          // 关闭对话框
          this.dialogVisible = false
          // 删除后刷新菜单
          this.categorys = this.getCategory()
          // 设置需要默认展开的菜单
          this.expandedKey = [this.category.parentCid]
        })
      },
      // 添加三级分类方法
      addCategory () {
        // 打印提交的三级分类数据
        console.log('提交的三级分类数据', this.category)
        // 调用后端添加三级分类方法的接口
        this.$http({
          url: this.$http.adornUrl('/product/category/save'),
          method: 'post',
          data: this.$http.adornData(this.category, false)
        }).then(({data}) => {
          // 提示菜单保存成功
          this.$message({
            type: 'success',
            message: '菜单保存成功!'
          })
          // 关闭对话框
          this.dialogVisible = false
          // 删除后刷新菜单
          this.categorys = this.getCategory()
          // 设置需要默认展开的菜单
          this.expandedKey = [this.category.parentCid]
        })
      },
      // 添加按钮方法
      append (data) {
        console.log('当前要新增的数据', data)
        // 设置对话框为新增
        this.dialogType = 'add'
        // 设置对话框标题
        this.title = '添加分类'
        // 显示对话框
        this.dialogVisible = true
        // 清空回显的数据
        this.restoreCategoryDefaultValue()
        console.log('清空回显数据：' + this.category)
        // 设置当前新增三级分类的父亲结点为当前点击新增结点的id
        this.category.parentCid = data.catId
        // 设置当前新增三级分类结点的level
        this.category.catLevel = data.catLevel * 1 + 1
      },
      // 修改按钮方法
      edit (data) {
        console.log('当前要修改的数据:', data)
        // 设置对话框为新增
        this.dialogType = 'edit'
        // 设置对话框标题
        this.title = '修改分类'
        // 显示对话框
        this.dialogVisible = true
        // 为当前表单对象category赋值
        // 发送请求获取当前结点最新的数据
        this.$http({
          url: this.$http.adornUrl(`/product/category/info/${data.catId}`),
          method: 'get',
          data: this.$http.adornParams({})
        }).then(({data}) => {
          // 请求成功
          console.log('回显数据内容:', data)
          this.category.name = data.data.name
          this.category.catId = data.data.catId
          this.category.icon = data.data.icon
          this.category.productUnit = data.data.productUnit
          this.category.parentCid = data.data.parentCid
        })
      },
      // 删除按钮方法
      remove (node, data) {
        var ids = [data.catId]
        this.$confirm(`是否删除【${data.name}】菜单?`, '提示', {
          confirmButtonText: '确定',
          cancelButtonText: '取消',
          type: 'warning'
        }).then(() => {
          this.$http({
            url: this.$http.adornUrl('/product/category/delete'),
            method: 'post',
            data: this.$http.adornData(ids, false)
          }).then(({data}) => {
            console.log('菜单删除成功!')
            // 删除后刷新菜单
            this.categorys = this.getCategory()
            // 设置需要默认展开的菜单
            this.expandedKey = [node.parent.data.catId]
          })
          this.$message({
            type: 'success',
            message: '菜单删除成功!'
          })
        }).catch(() => {
          this.$message({
            type: 'info',
            message: '已取消删除'
          })
        })
        console.log('remove', node, data)
      },
      // 批量删除结点
      batchDelete () {
        // 删除结点的id
        let catIds = []
        // 展示批量删除的名称
        let catNames = []
        let checkedNodes = this.$refs.categoryTree.getCheckedNodes()
        console.log('当前批量删除选中结点信息：', checkedNodes)
        // 封装删除结点id
        for (let i = 0; i < checkedNodes.length; i++) {
          catIds.push(checkedNodes[i].catId)
          catNames.push(checkedNodes[i].name)
        }
        this.$confirm(`是否批量删除【${catNames}】菜单?`, '提示', {
          confirmButtonText: '确定',
          cancelButtonText: '取消',
          type: 'warning'
        }).then(() => {
          // 发送批量删除请求
          this.$http({
            url: this.$http.adornUrl('/product/category/delete'),
            method: 'post',
            data: this.$http.adornData(catIds, false)
          }).then(({data}) => {
            // 提示删除成功
            this.$message({
              type: 'success',
              message: '菜单批量删除成功'
            })
            // 刷新菜单
            this.getCategory()
          })
        }).catch(() => {
          this.$message({
            type: 'info',
            message: '已取消批量删除'
          })
        })
      },
      // 批量保存结点拖动
      batchSave () {
        // 更新拖拽结点层级和顺序
        this.$http({
          url: this.$http.adornUrl('/product/category/update/sort'),
          method: 'post',
          data: this.$http.adornData(this.updateNodes, false)
        }).then(({data}) => {
          this.$message({
            type: 'success',
            message: '菜单顺序修改成功'
          })
          // 刷新菜单
          this.getCategory()
          // 设置需要默认展开的菜单
          this.expandedKey = this.pCid
          // 重置更新结点数据和最大层级
          this.updateNodes = []
          this.nodeMaxLevel = 0
          this.pCid = []
        })
      },
      // 拖拽结点放置位置判断
      allowDrop (draggingNode, dropNode, type) {
        this.nodeMaxLevel = draggingNode.data.catLevel
        // 合理：被拖动后的节点中的最大深度或所在父结点最大深度不能大于3
        console.log('allowDrop:', draggingNode, dropNode, type)
        // 获取被拖结点的深度
        this.getNodeLevel(draggingNode)
        let draggingNodeDeep = Math.abs(this.nodeMaxLevel - draggingNode.level + 1)
        console.log('当前拖拽结点深度:', draggingNodeDeep)
        console.log('目标结点的深度：', dropNode.level)
        console.log('目标结点的父亲结点的深度：', dropNode.parent.level)
        if (type === 'inner') {
          // 情况1.如果是放到目标结点内，判断当前拖拽结点的深度加上目标结点的深度 <= 3
          return (draggingNodeDeep + dropNode.level) <= 3
        } else {
          // 情况2.如果放到目标结点并列位置，判断当前拖拽结点的深度加上目标结点父亲结点的深度 <= 3
          return (draggingNodeDeep + dropNode.parent.level) <= 3
        }
      },
      // 拖拽节点事件
      handleDrop (draggingNode, dropNode, dropType, ev) {
        console.log('handleDrop: ', draggingNode, dropNode, dropType)
        // 获取当前结点最新的父结点id
        let pCid = 0
        // 获取当前结点最新的兄弟节点信息
        let siblings = null
        console.log('当前节点的父结点id：', pCid)
        if (dropType === 'before' || dropType === 'after') {
          // 目标节点的前或后 父结点就是目标节点的父结点
          pCid = dropNode.parent.data.catId === undefined ? 0 : dropNode.parent.data.catId
          // 目标节点的前和后 兄弟节点就是目标结点的父结点的子节点
          siblings = dropNode.parent.childNodes
        } else {
          // 目标节点中 父结点就是目标节点
          pCid = dropNode.data.catId
          // 目标结点中 兄弟节点就是目标结点的所有子节点
          siblings = dropNode.childNodes
        }
        this.pCid.push(pCid)
        console.log('当前节点的父结点id：', pCid)
        console.log('当前兄弟节点：', siblings)
        // 当前拖拽节点的最新顺序
        for (let i = 0; i < siblings.length; i++) {
          if (siblings[i].data.catId === draggingNode.data.catId) {
            // 如果遍历的是当前拖拽的结点
            // 当前拖拽结点的层级（原）
            let draggingNodeLevel = draggingNode.level
            if (siblings[i].level !== draggingNodeLevel) {
              // 拓展后兄弟节点的层级和当前拖拽结点原层级不同说明层级发送了变化
              draggingNodeLevel = siblings[i].level
              // 修改当前拖拽结点子节点的层级
              this.updateChildNodeLevel(siblings[i])
            }
            this.updateNodes.push({catId: siblings[i].data.catId, sort: i, parentCid: pCid, catLevel: draggingNodeLevel})
          } else {
            this.updateNodes.push({catId: siblings[i].data.catId, sort: i})
          }
        }
        console.log('当前需要更新排序的结点信息：', this.updateNodes)
      },
      // 自定义方法
      // 更新子节点的层级
      updateChildNodeLevel (node) {
        if (node.childNodes !== null && node.childNodes.length > 0) {
          // 遍历所有子节点
          for (let i = 0; i < node.childNodes.length; i++) {
            // 当前节点
            var cNode = node.childNodes[i].data
            // 注：这里的level属性是放置后的层级
            this.updateNodes.push({catId: cNode.catId, catLevel: node.childNodes[i].level})
            // 递归更新子节点
            this.updateChildNodeLevel(node.childNodes[i])
          }
        }
      },
      // 获取当前结点的层级
      getNodeLevel (node) {
        // 遍历所有子节点，求出最大深度
        if (node.childNodes != null && node.childNodes.length > 0) {
          // 当前结点有子节点
          for (let i = 0; i < node.childNodes.length; i++) {
            if (node.childNodes[i].level > this.nodeMaxLevel) {
              this.nodeMaxLevel = node.childNodes[i].level
            }
            // 继续遍历子节点
            this.getNodeLevel(node.childNodes[i])
          }
        }
      },
      // 重置category对象的默认值
      restoreCategoryDefaultValue () {
        this.category.catId = null
        this.category.name = ''
        this.category.parentCid = 0
        this.category.catLevel = 0
        this.category.showStatus = 1
        this.category.sort = 0
        this.category.productUnit = ''
        this.category.icon = ''
      }
    },
    // vue生命周期 - 创建完成（可以访问当前this实例）
    created () {
      this.getCategory()
    }
  }
</script>

<style>
  .custom-tree-node {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: space-between;
    font-size: 14px;
    padding-right: 10px;
  }
  .el-button {
    font-size: 14px;
    /* color: black; */
  }
</style>
```



#### 6、商品服务-品牌管理功能

##### 6.1、快速生成个品牌管理的菜单

在后台管理平台中新增一个品牌管理的菜单

![image-20240224140046196](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240224140046196.png)

![image-20240224140103930](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240224140103930.png)



获取代码生成器生成的前端代码

![image-20240224141740256](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240224141740256.png)

将其放到我们 `modules.product`下

![image-20240224141837480](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240224141837480.png)

查看页面，发现没有新增和删除

![image-20240224142700808](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240224142700808.png)

因为新增和删除有权限控制，可以看其代码

```html
 <el-form-item>
        <el-button @click="getDataList()">查询</el-button>
        <el-button v-if="isAuth('product:brand:save')" type="primary" @click="addOrUpdateHandle()">新增</el-button>
        <el-button v-if="isAuth('product:brand:delete')" type="danger" @click="deleteHandle()" :disabled="dataListSelections.length <= 0">批量删除</el-button>
      </el-form-item>
```

在`index.js `修改权限判断的方法，将其设为永真

```js
/**
 * 是否有权限
 * @param {*} key
 */
export function isAuth (key) {
  // return JSON.parse(sessionStorage.getItem('permissions') || '[]').indexOf(key) !== -1 || false
  return true
}
```

再次查看页面

![image-20240224142946145](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240224142946145.png)





##### 6.2、效果优化与快速显示开关

（1）设置显示状态为开关

可以通过开关动态调整品牌的显示和不显示

使用element-ui中Table表格中的自定义列模板

![image-20240224154431779](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240224154431779.png)

其就是给要修改的类定义一个模板，然后通过通过 `Scoped slot` 可以获取到 row, column, $index 和 store（table 内部的状态管理）的数据

![image-20240224154900501](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240224154900501.png)

我们自定义其中显示一个switch开关

修改前：

```html
<el-table-column
    prop="showStatus"
    header-align="center"
    align="center"
    label="显示状态[0-不显示；1-显示]">
</el-table-column>
```

修改后：

```html
<el-table-column
prop="showStatus"
header-align="center"
align="center"
label="显示状态[0-不显示；1-显示]">
  <template slot-scope="scope">
    <el-switch
      v-model="scope.row.showStatus"
      active-color="#13ce66"
      inactive-color="#ff4949">
    </el-switch>
  </template>
</el-table-column>
```



详情代码：

列表修改按钮的快速修改显示代码：

```html
<template>
  <div class="mod-config">
    <el-form :inline="true" :model="dataForm" @keyup.enter.native="getDataList()">
      <el-form-item>
        <el-input v-model="dataForm.key" placeholder="参数名" clearable></el-input>
      </el-form-item>
      <el-form-item>
        <el-button @click="getDataList()">查询</el-button>
        <el-button v-if="isAuth('product:brand:save')" type="primary" @click="addOrUpdateHandle()">新增</el-button>
        <el-button v-if="isAuth('product:brand:delete')" type="danger" @click="deleteHandle()" :disabled="dataListSelections.length <= 0">批量删除</el-button>
      </el-form-item>
    </el-form>
    <el-table
      :data="dataList"
      border
      v-loading="dataListLoading"
      @selection-change="selectionChangeHandle"
      style="width: 100%;">
      <el-table-column
        type="selection"
        header-align="center"
        align="center"
        width="50">
      </el-table-column>
      <el-table-column
        prop="brandId"
        header-align="center"
        align="center"
        label="品牌id">
      </el-table-column>
      <el-table-column
        prop="name"
        header-align="center"
        align="center"
        label="品牌名">
      </el-table-column>
      <el-table-column
        prop="logo"
        header-align="center"
        align="center"
        label="品牌logo地址">
      </el-table-column>
      <el-table-column
        prop="descript"
        header-align="center"
        align="center"
        label="介绍">
      </el-table-column>
      <el-table-column
        prop="showStatus"
        header-align="center"
        align="center"
        label="显示状态">
          <!-- 自定义列内容-这里显示一个switch -->
          <!-- 
            绑定一个监听事件，并调用updateBrandStatus方法, 
            参数：
            ①整行数据的参数

            注意：没有指定active-value和inactive-value, 默认值是true，false
          -->
          <template slot-scope="scope">
            <el-switch
              v-model="scope.row.showStatus"
              active-color="#13ce66"
              inactive-color="#ff4949"
              :active-value = 1
              :inactive-value= 0
              @change="updateBrandStatus(scope.row)">
            </el-switch>
          </template>
      </el-table-column>
      <el-table-column
        prop="firstLetter"
        header-align="center"
        align="center"
        label="检索首字母">
      </el-table-column>
      <el-table-column
        prop="sort"
        header-align="center"
        align="center"
        label="排序">
      </el-table-column>
      <el-table-column
        fixed="right"
        header-align="center"
        align="center"
        width="150"
        label="操作">
        <template slot-scope="scope">
          <el-button type="text" size="small" @click="addOrUpdateHandle(scope.row.brandId)">修改</el-button>
          <el-button type="text" size="small" @click="deleteHandle(scope.row.brandId)">删除</el-button>
        </template>
      </el-table-column>
    </el-table>
    <el-pagination
      @size-change="sizeChangeHandle"
      @current-change="currentChangeHandle"
      :current-page="pageIndex"
      :page-sizes="[10, 20, 50, 100]"
      :page-size="pageSize"
      :total="totalPage"
      layout="total, sizes, prev, pager, next, jumper">
    </el-pagination>
    <!-- 弹窗, 新增 / 修改 -->
    <add-or-update v-if="addOrUpdateVisible" ref="addOrUpdate" @refreshDataList="getDataList"></add-or-update>
  </div>
</template>

<script>
  import AddOrUpdate from './brand-add-or-update'
  export default {
    data () {
      return {
        dataForm: {
          key: ''
        },
        dataList: [],
        pageIndex: 1,
        pageSize: 10,
        totalPage: 0,
        dataListLoading: false,
        dataListSelections: [],
        addOrUpdateVisible: false
      }
    },
    components: {
      AddOrUpdate
    },
    activated () {
      this.getDataList()
    },
    methods: {
      // 获取数据列表
      getDataList () {
        this.dataListLoading = true
        this.$http({
          url: this.$http.adornUrl('/product/brand/list'),
          method: 'get',
          params: this.$http.adornParams({
            'page': this.pageIndex,
            'limit': this.pageSize,
            'key': this.dataForm.key
          })
        }).then(({data}) => {
          if (data && data.code === 0) {
            this.dataList = data.page.list
            this.totalPage = data.page.totalCount
          } else {
            this.dataList = []
            this.totalPage = 0
          }
          this.dataListLoading = false
        })
      },
      // 更新品牌显示状态的监听方法
      updateBrandStatus (data) {
        // 开关打开 showStatus -> true  开关关闭 showStatus -> false
        console.log('当前行数据:', data)
        // 结构需要的参数
        let {brandId, showStatus} = data
        // 打印相关内容
        console.log('当前品牌id:', brandId)
        console.log('当前显示状态:', showStatus)
        // 发送修改请求
        this.$http({
          url: this.$http.adornUrl('/product/brand/update'),
          method: 'post',
          // 完整写法：data: this.$http.adornData({brandId：brandId, showStatus：showStatus}, false)
          data: this.$http.adornData({brandId, showStatus}, false)
        }).then(({data}) => {
          // 提示成功
          this.$message({
            type: 'success',
            message: '状态更新成功'
          })
        })
      },
      // 每页数
      sizeChangeHandle (val) {
        this.pageSize = val
        this.pageIndex = 1
        this.getDataList()
      },
      // 当前页
      currentChangeHandle (val) {
        this.pageIndex = val
        this.getDataList()
      },
      // 多选
      selectionChangeHandle (val) {
        this.dataListSelections = val
      },
      // 新增 / 修改
      addOrUpdateHandle (id) {
        this.addOrUpdateVisible = true
        this.$nextTick(() => {
          this.$refs.addOrUpdate.init(id)
        })
      },
      // 删除
      deleteHandle (id) {
        var ids = id ? [id] : this.dataListSelections.map(item => {
          return item.brandId
        })
        this.$confirm(`确定对[id=${ids.join(',')}]进行[${id ? '删除' : '批量删除'}]操作?`, '提示', {
          confirmButtonText: '确定',
          cancelButtonText: '取消',
          type: 'warning'
        }).then(() => {
          this.$http({
            url: this.$http.adornUrl('/product/brand/delete'),
            method: 'post',
            data: this.$http.adornData(ids, false)
          }).then(({data}) => {
            if (data && data.code === 0) {
              this.$message({
                message: '操作成功',
                type: 'success',
                duration: 1500,
                onClose: () => {
                  this.getDataList()
                }
              })
            } else {
              this.$message.error(data.msg)
            }
          })
        })
      }
    }
  }
</script>

```

增加修改表单代码：

```html
<template>
  <el-dialog
    :title="!dataForm.brandId ? '新增' : '修改'"
    :close-on-click-modal="false"
    :visible.sync="visible">
    <el-form :model="dataForm" :rules="dataRule" ref="dataForm" @keyup.enter.native="dataFormSubmit()" label-width="140px">
    <el-form-item label="品牌名" prop="name">
      <el-input v-model="dataForm.name" placeholder="品牌名"></el-input>
    </el-form-item>
    <el-form-item label="品牌logo地址" prop="logo">
      <!-- 这里应该是一个上传控件 -->
      <!-- <el-input v-model="dataForm.logo" placeholder="品牌logo地址"></el-input> -->
    </el-form-item>
    <el-form-item label="介绍" prop="descript">
      <el-input v-model="dataForm.descript" placeholder="介绍"></el-input>
    </el-form-item>
    <el-form-item label="显示状态" prop="showStatus">
      <!-- 替换为switch控制 -->
      <!-- <el-input v-model="dataForm.showStatus" placeholder="显示状态[0-不显示；1-显示]"></el-input> -->
       <el-switch v-model="dataForm.showStatus" active-color="#13ce66" inactive-color="#ff4949"></el-switch>
    </el-form-item>
    <el-form-item label="检索首字母" prop="firstLetter">
      <el-input v-model="dataForm.firstLetter" placeholder="检索首字母"></el-input>
    </el-form-item>
    <el-form-item label="排序" prop="sort">
      <el-input v-model="dataForm.sort" placeholder="排序"></el-input>
    </el-form-item>
    </el-form>
    <span slot="footer" class="dialog-footer">
      <el-button @click="visible = false">取消</el-button>
      <el-button type="primary" @click="dataFormSubmit()">确定</el-button>
    </span>
  </el-dialog>
</template>

<script>
  export default {
    data () {
      return {
        visible: false,
        dataForm: {
          brandId: 0,
          name: '',
          logo: '',
          descript: '',
          showStatus: '',
          firstLetter: '',
          sort: ''
        },
        dataRule: {
          name: [
            { required: true, message: '品牌名不能为空', trigger: 'blur' }
          ],
          logo: [
            { required: true, message: '品牌logo地址不能为空', trigger: 'blur' }
          ],
          descript: [
            { required: true, message: '介绍不能为空', trigger: 'blur' }
          ],
          showStatus: [
            { required: true, message: '显示状态[0-不显示；1-显示]不能为空', trigger: 'blur' }
          ],
          firstLetter: [
            { required: true, message: '检索首字母不能为空', trigger: 'blur' }
          ],
          sort: [
            { required: true, message: '排序不能为空', trigger: 'blur' }
          ]
        }
      }
    },
    methods: {
      init (id) {
        this.dataForm.brandId = id || 0
        this.visible = true
        this.$nextTick(() => {
          this.$refs['dataForm'].resetFields()
          if (this.dataForm.brandId) {
            this.$http({
              url: this.$http.adornUrl(`/product/brand/info/${this.dataForm.brandId}`),
              method: 'get',
              params: this.$http.adornParams()
            }).then(({data}) => {
              if (data && data.code === 0) {
                this.dataForm.name = data.brand.name
                this.dataForm.logo = data.brand.logo
                this.dataForm.descript = data.brand.descript
                this.dataForm.showStatus = data.brand.showStatus
                this.dataForm.firstLetter = data.brand.firstLetter
                this.dataForm.sort = data.brand.sort
              }
            })
          }
        })
      },
      // 表单提交
      dataFormSubmit () {
        this.$refs['dataForm'].validate((valid) => {
          if (valid) {
            this.$http({
              url: this.$http.adornUrl(`/product/brand/${!this.dataForm.brandId ? 'save' : 'update'}`),
              method: 'post',
              data: this.$http.adornData({
                'brandId': this.dataForm.brandId || undefined,
                'name': this.dataForm.name,
                'logo': this.dataForm.logo,
                'descript': this.dataForm.descript,
                'showStatus': this.dataForm.showStatus,
                'firstLetter': this.dataForm.firstLetter,
                'sort': this.dataForm.sort
              })
            }).then(({data}) => {
              if (data && data.code === 0) {
                this.$message({
                  message: '操作成功',
                  type: 'success',
                  duration: 1500,
                  onClose: () => {
                    this.visible = false
                    this.$emit('refreshDataList')
                  }
                })
              } else {
                this.$message.error(data.msg)
              }
            })
          }
        })
      }
    }
  }
</script>

```



##### 6.3、OSS文件上传实现

首先获取通用的单文件/多文件上传和发请求的`policy`

![image-20240225154741296](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240225154741296.png)

我们将其放到前端项目`src/components/upload`下

![image-20240225154951798](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240225154951798.png)

其中`singleUpload.vue`和`multiUpload.vue`是对`element-ui上传附件`的封装，我们对其请求地址进行调整，使用bucket域名

![image-20240225155316239](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240225155316239.png)

`singleUpload.vue`：

```html
<template> 
  <div>
    <el-upload
      action="http://tts-platform-oss.oss-cn-hangzhou.aliyuncs.com"
      :data="dataObj"
      list-type="picture"
      :multiple="false" :show-file-list="showFileList"
      :file-list="fileList"
      :before-upload="beforeUpload"
      :on-remove="handleRemove"
      :on-success="handleUploadSuccess"
      :on-preview="handlePreview">
      <el-button size="small" type="primary">点击上传</el-button>
      <div slot="tip" class="el-upload__tip">只能上传jpg/png文件，且不超过10MB</div>
    </el-upload>
    <el-dialog :visible.sync="dialogVisible">
      <img width="100%" :src="fileList[0].url" alt="">
    </el-dialog>
  </div>
</template>
<script>
   import {policy} from './policy'
   import { getUUID } from '@/utils'

  export default {
    name: 'singleUpload',
    props: {
      value: String
    },
    computed: {
      imageUrl() {
        return this.value;
      },
      imageName() {
        if (this.value != null && this.value !== '') {
          return this.value.substr(this.value.lastIndexOf("/") + 1);
        } else {
          return null;
        }
      },
      fileList() {
        return [{
          name: this.imageName,
          url: this.imageUrl
        }]
      },
      showFileList: {
        get: function () {
          return this.value !== null && this.value !== ''&& this.value!==undefined;
        },
        set: function (newValue) {
        }
      }
    },
    data() {
      return {
        dataObj: {
          policy: '',
          signature: '',
          key: '',
          ossaccessKeyId: '',
          dir: '',
          host: '',
          // callback:'',
        },
        dialogVisible: false
      };
    },
    methods: {
      emitInput(val) {
        this.$emit('input', val)
      },
      handleRemove(file, fileList) {
        this.emitInput('');
      },
      handlePreview(file) {
        this.dialogVisible = true;
      },
      beforeUpload(file) {
        let _self = this;
        return new Promise((resolve, reject) => {
          policy().then(response => {
            console.log("响应的数据",response);
            _self.dataObj.policy = response.data.policy;
            _self.dataObj.signature = response.data.signature;
            _self.dataObj.ossaccessKeyId = response.data.accessid;
            _self.dataObj.key = response.data.dir +getUUID()+'_${filename}';
            _self.dataObj.dir = response.data.dir;
            _self.dataObj.host = response.data.host;
            console.log("响应的数据222。。。",_self.dataObj);
            resolve(true)
          }).catch(err => {
            reject(false)
          })
        })
      },
      handleUploadSuccess(res, file) {
        console.log("上传成功...")
        this.showFileList = true;
        this.fileList.pop();
        this.fileList.push({name: file.name, url: this.dataObj.host + '/' + this.dataObj.key.replace("${filename}",file.name) });
        this.emitInput(this.fileList[0].url);
      }
    }
  }
</script>
<style>

</style>

```

`multiUpload.vue`：

```html
<template>
  <div>
    <el-upload
      action="http://tts-platform-oss.oss-cn-hangzhou.aliyuncs.com"
      :data="dataObj"
      :list-type="listType"
      :file-list="fileList"
      :before-upload="beforeUpload"
      :on-remove="handleRemove"
      :on-success="handleUploadSuccess"
      :on-preview="handlePreview"
      :limit="maxCount"
      :on-exceed="handleExceed"
      :show-file-list="showFile"
    >
      <i class="el-icon-plus"></i>
    </el-upload>
    <el-dialog :visible.sync="dialogVisible">
      <img width="100%" :src="dialogImageUrl" alt />
    </el-dialog>
  </div>
</template>
<script>
import { policy } from "./policy";
import { getUUID } from '@/utils'
export default {
  name: "multiUpload",
  props: {
    //图片属性数组
    value: Array,
    //最大上传图片数量
    maxCount: {
      type: Number,
      default: 30
    },
    listType:{
      type: String,
      default: "picture-card"
    },
    showFile:{
      type: Boolean,
      default: true
    }

  },
  data() {
    return {
      dataObj: {
        policy: "",
        signature: "",
        key: "",
        ossaccessKeyId: "",
        dir: "",
        host: "",
        uuid: ""
      },
      dialogVisible: false,
      dialogImageUrl: null
    };
  },
  computed: {
    fileList() {
      let fileList = [];
      for (let i = 0; i < this.value.length; i++) {
        fileList.push({ url: this.value[i] });
      }

      return fileList;
    }
  },
  mounted() {},
  methods: {
    emitInput(fileList) {
      let value = [];
      for (let i = 0; i < fileList.length; i++) {
        value.push(fileList[i].url);
      }
      this.$emit("input", value);
    },
    handleRemove(file, fileList) {
      this.emitInput(fileList);
    },
    handlePreview(file) {
      this.dialogVisible = true;
      this.dialogImageUrl = file.url;
    },
    beforeUpload(file) {
      let _self = this;
      return new Promise((resolve, reject) => {
        policy()
          .then(response => {
            console.log("这是什么${filename}");
            _self.dataObj.policy = response.data.policy;
            _self.dataObj.signature = response.data.signature;
            _self.dataObj.ossaccessKeyId = response.data.accessid;
            _self.dataObj.key = response.data.dir +getUUID()+"_${filename}";
            _self.dataObj.dir = response.data.dir;
            _self.dataObj.host = response.data.host;
            resolve(true);
          })
          .catch(err => {
            console.log("出错了...",err)
            reject(false);
          });
      });
    },
    handleUploadSuccess(res, file) {
      this.fileList.push({
        name: file.name,
        // url: this.dataObj.host + "/" + this.dataObj.dir + "/" + file.name； 替换${filename}为真正的文件名
        url: this.dataObj.host + "/" + this.dataObj.key.replace("${filename}",file.name)
      });
      this.emitInput(this.fileList);
    },
    handleExceed(files, fileList) {
      this.$message({
        message: "最多只能上传" + this.maxCount + "张图片",
        type: "warning",
        duration: 1000
      });
    }
  }
};
</script>
<style>
</style>
```

`policy.js`是对第三方请求的调用

```js
import http from '@/utils/httpRequest.js'
export function policy() {
   return new Promise((resolve,reject)=>{
        http({
            url: http.adornUrl("/thirdparty/oss/policy"),
            method: "get",
            params: http.adornParams({})
        }).then(({ data }) => {
            resolve(data);
        })
    });
}
```



在品牌增加修改视图`brand-add-or-update.vue`对品牌log使用单文件上传

```html
<template>
  <el-dialog
    :title="!dataForm.brandId ? '新增' : '修改'"
    :close-on-click-modal="false"
    :visible.sync="visible"
  >
    <el-form
      :model="dataForm"
      :rules="dataRule"
      ref="dataForm"
      @keyup.enter.native="dataFormSubmit()"
      label-width="140px"
    >
      <el-form-item label="品牌名" prop="name">
        <el-input v-model="dataForm.name" placeholder="品牌名"></el-input>
      </el-form-item>
      <el-form-item label="品牌logo地址" prop="logo">
        <!-- 这里应该是一个上传控件 -->
        <!-- <el-input v-model="dataForm.logo" placeholder="品牌logo地址"></el-input> -->
        <SingleUpload v-model="dataForm.logo"></SingleUpload>
      </el-form-item>
      <el-form-item label="介绍" prop="descript">
        <el-input v-model="dataForm.descript" placeholder="介绍"></el-input>
      </el-form-item>
      <el-form-item label="显示状态" prop="showStatus">
        <!-- 替换为switch控制 -->
        <!-- <el-input v-model="dataForm.showStatus" placeholder="显示状态[0-不显示；1-显示]"></el-input> -->
        <el-switch
          v-model="dataForm.showStatus"
          active-color="#13ce66"
          inactive-color="#ff4949"
        ></el-switch>
      </el-form-item>
      <el-form-item label="检索首字母" prop="firstLetter">
        <el-input
          v-model="dataForm.firstLetter"
          placeholder="检索首字母"
        ></el-input>
      </el-form-item>
      <el-form-item label="排序" prop="sort">
        <el-input v-model="dataForm.sort" placeholder="排序"></el-input>
      </el-form-item>
    </el-form>
    <span slot="footer" class="dialog-footer">
      <el-button @click="visible = false">取消</el-button>
      <el-button type="primary" @click="dataFormSubmit()">确定</el-button>
    </span>
  </el-dialog>
</template>

<script>
// 导入单文件上传
import SingleUpload from '@/components/upload/singleUpload'
export default {
  components: { SingleUpload: SingleUpload },
  data () {
    return {
      visible: false,
      dataForm: {
        brandId: 0,
        name: '',
        logo: '',
        descript: '',
        showStatus: '',
        firstLetter: '',
        sort: ''
      },
      dataRule: {
        name: [
          { required: true, message: '品牌名不能为空', trigger: 'blur' }
        ],
        logo: [
          { required: true, message: '品牌logo地址不能为空', trigger: 'blur' }
        ],
        descript: [
          { required: true, message: '介绍不能为空', trigger: 'blur' }
        ],
        showStatus: [
          { required: true, message: '显示状态[0-不显示；1-显示]不能为空', trigger: 'blur' }
        ],
        firstLetter: [
          { required: true, message: '检索首字母不能为空', trigger: 'blur' }
        ],
        sort: [
          { required: true, message: '排序不能为空', trigger: 'blur' }
        ]
      }
    }
  },
  methods: {
    init (id) {
      this.dataForm.brandId = id || 0
      this.visible = true
      this.$nextTick(() => {
        this.$refs['dataForm'].resetFields()
        if (this.dataForm.brandId) {
          this.$http({
            url: this.$http.adornUrl(`/product/brand/info/${this.dataForm.brandId}`),
            method: 'get',
            params: this.$http.adornParams()
          }).then(({ data }) => {
            if (data && data.code === 0) {
              this.dataForm.name = data.brand.name
              this.dataForm.logo = data.brand.logo
              this.dataForm.descript = data.brand.descript
              this.dataForm.showStatus = data.brand.showStatus
              this.dataForm.firstLetter = data.brand.firstLetter
              this.dataForm.sort = data.brand.sort
            }
          })
        }
      })
    },
    // 表单提交
    dataFormSubmit () {
      this.$refs['dataForm'].validate((valid) => {
        if (valid) {
          this.$http({
            url: this.$http.adornUrl(`/product/brand/${!this.dataForm.brandId ? 'save' : 'update'}`),
            method: 'post',
            data: this.$http.adornData({
              'brandId': this.dataForm.brandId || undefined,
              'name': this.dataForm.name,
              'logo': this.dataForm.logo,
              'descript': this.dataForm.descript,
              'showStatus': this.dataForm.showStatus,
              'firstLetter': this.dataForm.firstLetter,
              'sort': this.dataForm.sort
            })
          }).then(({ data }) => {
            if (data && data.code === 0) {
              this.$message({
                message: '操作成功',
                type: 'success',
                duration: 1500,
                onClose: () => {
                  this.visible = false
                  this.$emit('refreshDataList')
                }
              })
            } else {
              this.$message.error(data.msg)
            }
          })
        }
      })
    }
  }
}
</script>

```

前端上传文件后，报跨域错误

![image-20240225225002851](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240225225002851.png)

在OSS中，设置bucket为可跨域访问

![image-20240225225350153](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240225225350153.png)

![image-20240225225409798](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240225225409798.png)





再次上传，发现上传成功

![image-20240225225443350](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240225225443350.png)

![image-20240225225529554](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240225225529554.png)



通过vue插件，也可以看档此时回显的内容，会在log中动态填充回显地址，就是访问地址

![image-20240225230202751](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240225230202751.png)



##### 6.4、表单校验

brand.vue

```html
<template>
  <div class="mod-config">
    <el-form
      :inline="true"
      :model="dataForm"
      @keyup.enter.native="getDataList()"
    >
      <el-form-item>
        <el-input
          v-model="dataForm.key"
          placeholder="参数名"
          clearable
        ></el-input>
      </el-form-item>
      <el-form-item>
        <el-button @click="getDataList()">查询</el-button>
        <el-button
          v-if="isAuth('product:brand:save')"
          type="primary"
          @click="addOrUpdateHandle()"
          >新增</el-button
        >
        <el-button
          v-if="isAuth('product:brand:delete')"
          type="danger"
          @click="deleteHandle()"
          :disabled="dataListSelections.length <= 0"
          >批量删除</el-button
        >
      </el-form-item>
    </el-form>
    <el-table
      :data="dataList"
      border
      v-loading="dataListLoading"
      @selection-change="selectionChangeHandle"
      style="width: 100%"
    >
      <el-table-column
        type="selection"
        header-align="center"
        align="center"
        width="50"
      >
      </el-table-column>
      <el-table-column
        prop="brandId"
        header-align="center"
        align="center"
        label="品牌id"
      >
      </el-table-column>
      <el-table-column
        prop="name"
        header-align="center"
        align="center"
        label="品牌名"
      >
      </el-table-column>
      <el-table-column
        prop="logo"
        header-align="center"
        align="center"
        label="品牌logo地址"
      >
        <!-- 自定义模板 -->
        <template slot-scope="scope">
          <!-- 图像，从插槽中获取图片的地址，设置为contain -->
          <img :src="scope.row.logo" style="width: 100px; height: 80px" />
        </template>
      </el-table-column>
      <el-table-column
        prop="descript"
        header-align="center"
        align="center"
        label="介绍"
      >
      </el-table-column>
      <el-table-column
        prop="showStatus"
        header-align="center"
        align="center"
        label="显示状态"
      >
        <!-- 自定义列内容-这里显示一个switch -->
        <!-- 
            绑定一个监听事件，并调用updateBrandStatus方法, 
            参数：
            ①整行数据的参数

            注意：没有指定active-value和inactive-value, 默认值是true，false
          -->
        <template slot-scope="scope">
          <el-switch
            v-model="scope.row.showStatus"
            active-color="#13ce66"
            inactive-color="#ff4949"
            :active-value="1"
            :inactive-value="0"
            @change="updateBrandStatus(scope.row)"
          >
          </el-switch>
        </template>
      </el-table-column>
      <el-table-column
        prop="firstLetter"
        header-align="center"
        align="center"
        label="检索首字母"
      >
      </el-table-column>
      <el-table-column
        prop="sort"
        header-align="center"
        align="center"
        label="排序"
      >
      </el-table-column>
      <el-table-column
        fixed="right"
        header-align="center"
        align="center"
        width="150"
        label="操作"
      >
        <template slot-scope="scope">
          <el-button
            type="text"
            size="small"
            @click="addOrUpdateHandle(scope.row.brandId)"
            >修改</el-button
          >
          <el-button
            type="text"
            size="small"
            @click="deleteHandle(scope.row.brandId)"
            >删除</el-button
          >
        </template>
      </el-table-column>
    </el-table>
    <el-pagination
      @size-change="sizeChangeHandle"
      @current-change="currentChangeHandle"
      :current-page="pageIndex"
      :page-sizes="[10, 20, 50, 100]"
      :page-size="pageSize"
      :total="totalPage"
      layout="total, sizes, prev, pager, next, jumper"
    >
    </el-pagination>
    <!-- 弹窗, 新增 / 修改 -->
    <add-or-update
      v-if="addOrUpdateVisible"
      ref="addOrUpdate"
      @refreshDataList="getDataList"
    ></add-or-update>
  </div>
</template>

<script>
import AddOrUpdate from './brand-add-or-update'
export default {
  data () {
    return {
      dataForm: {
        key: ''
      },
      dataList: [],
      pageIndex: 1,
      pageSize: 10,
      totalPage: 0,
      dataListLoading: false,
      dataListSelections: [],
      addOrUpdateVisible: false
    }
  },
  components: {
    AddOrUpdate
  },
  activated () {
    this.getDataList()
  },
  methods: {
    // 获取数据列表
    getDataList () {
      this.dataListLoading = true
      this.$http({
        url: this.$http.adornUrl('/product/brand/list'),
        method: 'get',
        params: this.$http.adornParams({
          'page': this.pageIndex,
          'limit': this.pageSize,
          'key': this.dataForm.key
        })
      }).then(({ data }) => {
        if (data && data.code === 0) {
          this.dataList = data.page.list
          this.totalPage = data.page.totalCount
        } else {
          this.dataList = []
          this.totalPage = 0
        }
        this.dataListLoading = false
      })
    },
    // 更新品牌显示状态的监听方法
    updateBrandStatus (data) {
      // 开关打开 showStatus -> true  开关关闭 showStatus -> false
      console.log('当前行数据:', data)
      // 结构需要的参数
      let { brandId, showStatus } = data
      // 打印相关内容
      console.log('当前品牌id:', brandId)
      console.log('当前显示状态:', showStatus)
      // 发送修改请求
      this.$http({
        url: this.$http.adornUrl('/product/brand/update'),
        method: 'post',
        // 完整写法：data: this.$http.adornData({brandId：brandId, showStatus：showStatus}, false)
        data: this.$http.adornData({ brandId, showStatus }, false)
      }).then(({ data }) => {
        // 提示成功
        this.$message({
          type: 'success',
          message: '状态更新成功'
        })
      })
    },
    // 每页数
    sizeChangeHandle (val) {
      this.pageSize = val
      this.pageIndex = 1
      this.getDataList()
    },
    // 当前页
    currentChangeHandle (val) {
      this.pageIndex = val
      this.getDataList()
    },
    // 多选
    selectionChangeHandle (val) {
      this.dataListSelections = val
    },
    // 新增 / 修改
    addOrUpdateHandle (id) {
      this.addOrUpdateVisible = true
      this.$nextTick(() => {
        this.$refs.addOrUpdate.init(id)
      })
    },
    // 删除
    deleteHandle (id) {
      var ids = id ? [id] : this.dataListSelections.map(item => {
        return item.brandId
      })
      this.$confirm(`确定对[id=${ids.join(',')}]进行[${id ? '删除' : '批量删除'}]操作?`, '提示', {
        confirmButtonText: '确定',
        cancelButtonText: '取消',
        type: 'warning'
      }).then(() => {
        this.$http({
          url: this.$http.adornUrl('/product/brand/delete'),
          method: 'post',
          data: this.$http.adornData(ids, false)
        }).then(({ data }) => {
          if (data && data.code === 0) {
            this.$message({
              message: '操作成功',
              type: 'success',
              duration: 1500,
              onClose: () => {
                this.getDataList()
              }
            })
          } else {
            this.$message.error(data.msg)
          }
        })
      })
    }
  }
}
</script>

```



brand-add-or-update.vue

```html
<template>
  <el-dialog
    :title="!dataForm.brandId ? '新增' : '修改'"
    :close-on-click-modal="false"
    :visible.sync="visible"
  >
    <el-form
      :model="dataForm"
      :rules="dataRule"
      ref="dataForm"
      @keyup.enter.native="dataFormSubmit()"
      label-width="140px"
    >
      <el-form-item label="品牌名" prop="name">
        <el-input v-model="dataForm.name" placeholder="品牌名"></el-input>
      </el-form-item>
      <el-form-item label="品牌logo地址" prop="logo">
        <!-- 这里应该是一个上传控件 -->
        <!-- <el-input v-model="dataForm.logo" placeholder="品牌logo地址"></el-input> -->
        <SingleUpload v-model="dataForm.logo"></SingleUpload>
      </el-form-item>
      <el-form-item label="介绍" prop="descript">
        <el-input v-model="dataForm.descript" placeholder="介绍"></el-input>
      </el-form-item>
      <el-form-item label="显示状态" prop="showStatus">
        <!-- 替换为switch控制 -->
        <!-- <el-input v-model="dataForm.showStatus" placeholder="显示状态[0-不显示；1-显示]"></el-input> -->
        <!-- 修改显示的值 true/false -> 1/0 -->
        <el-switch
          v-model="dataForm.showStatus"
          active-color="#13ce66"
          inactive-color="#ff4949"
          active-value="1"
          inactive-value="0"
        ></el-switch>
      </el-form-item>
      <el-form-item label="检索首字母" prop="firstLetter">
        <el-input
          v-model="dataForm.firstLetter"
          placeholder="检索首字母"
        ></el-input>
      </el-form-item>
      <!-- v-model.number 接受一个数字 -->
      <el-form-item label="排序" prop="sort">
        <el-input v-model.number="dataForm.sort" placeholder="排序"></el-input>
      </el-form-item>
    </el-form>
    <span slot="footer" class="dialog-footer">
      <el-button @click="visible = false">取消</el-button>
      <el-button type="primary" @click="dataFormSubmit()">确定</el-button>
    </span>
  </el-dialog>
</template>

<script>
// 导入单文件上传
import SingleUpload from '@/components/upload/singleUpload'
export default {
  components: { SingleUpload },
  data () {
    return {
      visible: false,
      dataForm: {
        brandId: 0,
        name: '',
        logo: '',
        descript: '',
        showStatus: 1,
        firstLetter: '',
        sort: 0
      },
      dataRule: {
        name: [
          { required: true, message: '品牌名不能为空', trigger: 'blur' }
        ],
        logo: [
          { required: true, message: '品牌logo地址不能为空', trigger: 'blur' }
        ],
        descript: [
          { required: true, message: '介绍不能为空', trigger: 'blur' }
        ],
        showStatus: [
          { required: true, message: '显示状态[0-不显示；1-显示]不能为空', trigger: 'blur' }
        ],
        // 自定义校验器
        firstLetter: [
          {
            validator: (rule, value, callback) => {
              if (value === '') {
                callback(new Error('首字母必须填写'))
              } else if (!/^[a-zA-Z]$/.test(value)) {
                callback(new Error('首字母必须是a-z或者A-Z'))
              } else {
                callback()
              }
            },
            trigger: 'blur'
          }
        ],
        sort: [
          {
            validator: (rule, value, callback) => {
              if (value === '') {
                callback(new Error('排序字段必须填写'))
              } else if (!Number.isInteger(value) || value < 0) {
                callback(new Error('排序字段必须是一个大于等于0的整数'))
              } else {
                callback()
              }
            },
            trigger: 'blur'
          }
        ]
      }
    }
  },
  methods: {
    init (id) {
      this.dataForm.brandId = id || 0
      this.visible = true
      this.$nextTick(() => {
        this.$refs['dataForm'].resetFields()
        if (this.dataForm.brandId) {
          this.$http({
            url: this.$http.adornUrl(`/product/brand/info/${this.dataForm.brandId}`),
            method: 'get',
            params: this.$http.adornParams()
          }).then(({ data }) => {
            if (data && data.code === 0) {
              this.dataForm.name = data.brand.name
              this.dataForm.logo = data.brand.logo
              this.dataForm.descript = data.brand.descript
              this.dataForm.showStatus = data.brand.showStatus
              this.dataForm.firstLetter = data.brand.firstLetter
              this.dataForm.sort = data.brand.sort
            }
          })
        }
      })
    },
    // 表单提交
    dataFormSubmit () {
      this.$refs['dataForm'].validate((valid) => {
        if (valid) {
          this.$http({
            url: this.$http.adornUrl(`/product/brand/${!this.dataForm.brandId ? 'save' : 'update'}`),
            method: 'post',
            data: this.$http.adornData({
              'brandId': this.dataForm.brandId || undefined,
              'name': this.dataForm.name,
              'logo': this.dataForm.logo,
              'descript': this.dataForm.descript,
              'showStatus': this.dataForm.showStatus,
              'firstLetter': this.dataForm.firstLetter,
              'sort': this.dataForm.sort
            })
          }).then(({ data }) => {
            if (data && data.code === 0) {
              this.$message({
                message: '操作成功',
                type: 'success',
                duration: 1500,
                onClose: () => {
                  this.visible = false
                  this.$emit('refreshDataList')
                }
              })
            } else {
              this.$message.error(data.msg)
            }
          })
        }
      })
    }
  }
}
</script>

```



##### 6.5、修改前端发送请求

```html
// 更新品牌显示状态的监听方法
    updateBrandStatus (data) {
      // 开关打开 showStatus -> true  开关关闭 showStatus -> false
      console.log('当前行数据:', data)
      // 结构需要的参数
      let { brandId, showStatus } = data
      // 打印相关内容
      console.log('当前品牌id:', brandId)
      console.log('当前显示状态:', showStatus)
      // 发送修改请求
      this.$http({
        url: this.$http.adornUrl('/product/brand/update/status'),
        method: 'post',
        // 完整写法：data: this.$http.adornData({brandId：brandId, showStatus：showStatus}, false)
        data: this.$http.adornData({ brandId, showStatus }, false)
      }).then(({ data }) => {
        // 提示成功
        this.$message({
          type: 'success',
          message: '状态更新成功'
        })
      })
    },
```



#### 7、商品服务-平台属性

##### 7.1、前端组件的抽取、属性分组代码的编写、父子组件交互

抽取三级分类组件，用作是一个公共的类

![image-20240229202503568](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240229202503568.png)

创建属性的单文件组件

![image-20240229212214520](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240229212214520.png)

关于父子组件交互

子组件给父组件发送一个事件，并携带数据

```html
this.$emit('tree-node-click', data, node, component)
```

父组件，在使用子组件上编写回调方法

```html
<!-- 同过子组件发送的事件名称，监听子组件的事件, 并自定义一个方法 -->
<Category @tree-node-click="treeNodeClick"></Category>
```



通用三级分类：

```
<template>
  <!-- element-UI树形tree控件 -->
  <!-- @node-click绑定结点被点击时的回调 -->
  <el-tree
    :data="categorys"
    :props="defaultProps"
    node-key="catId"
    ref="categoryTree"
    @node-click="nodeClick"
  >
  </el-tree>
</template>

<script>
export default {
  components: {},
  props: {},
  data () {
    // 这里存放数据
    return {
      // 全部分类数据
      categorys: [],
      // 存储刷新页面后展开结点信息
      expandedKey: [],
      // 表单的可见
      dialogVisible: false,
      // 树结点默认的显示和子节点信息配置
      defaultProps: {
        children: 'children',
        label: 'name'
      }
    }
  },
  methods: {
    // 获取商品服务的三级分类信息
    getCategory () {
      // 发送http请求
      this.$http({
        url: this.$http.adornUrl('/product/category/list/tree'),
        method: 'get'
      }).then(({ data }) => {
        console.log('成功获取到商品菜单数据：', data.data)
        this.categorys = data.data
      })
    },
    // 点击回调事件
    nodeClick (data, node, component) {
      console.log('子组件category被点击:', data, node, component)
      /*
        向父组件发送事件
        参数1：事件名
        参数2、3、4、……：任意对象
      */
      this.$emit('tree-node-click', data, node, component)
    }
  },
  // vue生命周期 - 创建完成（可以访问当前this实例）
  created () {
    this.getCategory()
  }
}
</script>
<style lang='scss' scoped>
</style>
```



属性分组：

```
<template>
  <el-row :gutter="20">
    <!-- 树形菜单 -->
    <el-col :span="6">
      <!-- 同过子组件发送的事件名称，绑定子组件的事件, 并自定义一个方法 -->
      <Category @tree-node-click="treeNodeClick"></Category>
    </el-col>
    <!-- 表格 -->
    <el-col :span="18">
      <div class="mod-config">
        <el-form
          :inline="true"
          :model="dataForm"
          @keyup.enter.native="getDataList()"
        >
          <el-form-item>
            <el-input
              v-model="dataForm.key"
              placeholder="参数名"
              clearable
            ></el-input>
          </el-form-item>
          <el-form-item>
            <el-button @click="getDataList()">查询</el-button>
            <el-button
              v-if="isAuth('product:attrgroup:save')"
              type="primary"
              @click="addOrUpdateHandle()"
              >新增</el-button
            >
            <el-button
              v-if="isAuth('product:attrgroup:delete')"
              type="danger"
              @click="deleteHandle()"
              :disabled="dataListSelections.length <= 0"
              >批量删除</el-button
            >
          </el-form-item>
        </el-form>
        <el-table
          :data="dataList"
          border
          v-loading="dataListLoading"
          @selection-change="selectionChangeHandle"
          style="width: 100%"
        >
          <el-table-column
            type="selection"
            header-align="center"
            align="center"
            width="50"
          >
          </el-table-column>
          <el-table-column
            prop="attrGroupId"
            header-align="center"
            align="center"
            label="分组id"
          >
          </el-table-column>
          <el-table-column
            prop="attrGroupName"
            header-align="center"
            align="center"
            label="组名"
          >
          </el-table-column>
          <el-table-column
            prop="sort"
            header-align="center"
            align="center"
            label="排序"
          >
          </el-table-column>
          <el-table-column
            prop="descript"
            header-align="center"
            align="center"
            label="描述"
          >
          </el-table-column>
          <el-table-column
            prop="icon"
            header-align="center"
            align="center"
            label="组图标"
          >
          </el-table-column>
          <el-table-column
            prop="catelogId"
            header-align="center"
            align="center"
            label="所属分类id"
          >
          </el-table-column>
          <el-table-column
            fixed="right"
            header-align="center"
            align="center"
            width="150"
            label="操作"
          >
            <template slot-scope="scope">
              <el-button
                type="text"
                size="small"
                @click="addOrUpdateHandle(scope.row.attrGroupId)"
                >修改</el-button
              >
              <el-button
                type="text"
                size="small"
                @click="deleteHandle(scope.row.attrGroupId)"
                >删除</el-button
              >
            </template>
          </el-table-column>
        </el-table>
        <el-pagination
          @size-change="sizeChangeHandle"
          @current-change="currentChangeHandle"
          :current-page="pageIndex"
          :page-sizes="[10, 20, 50, 100]"
          :page-size="pageSize"
          :total="totalPage"
          layout="total, sizes, prev, pager, next, jumper"
        >
        </el-pagination>
        <!-- 弹窗, 新增 / 修改 -->
        <add-or-update
          v-if="addOrUpdateVisible"
          ref="addOrUpdate"
          @refreshDataList="getDataList"
        ></add-or-update></div
    ></el-col>
  </el-row>
</template>

<script>
// 导入公共三级分类组件
import Category from '../common/category'
// 属性增加或修改组件
import AddOrUpdate from './attrgroup-add-or-update'
export default {
  // 声明组件
  components: { Category, AddOrUpdate },
  props: {},
  data () {
    // 这里存放数据
    return {
      dataForm: {
        key: ''
      },
      dataList: [],
      pageIndex: 1,
      pageSize: 10,
      totalPage: 0,
      dataListLoading: false,
      dataListSelections: [],
      addOrUpdateVisible: false
    }
  },
  activated () {
    this.getDataList()
  },
  methods: {
    // 获取数据列表
    getDataList () {
      this.dataListLoading = true
      this.$http({
        url: this.$http.adornUrl('/product/attrgroup/list'),
        method: 'get',
        params: this.$http.adornParams({
          'page': this.pageIndex,
          'limit': this.pageSize,
          'key': this.dataForm.key
        })
      }).then(({ data }) => {
        if (data && data.code === 0) {
          this.dataList = data.page.list
          this.totalPage = data.page.totalCount
        } else {
          this.dataList = []
          this.totalPage = 0
        }
        this.dataListLoading = false
      })
    },
    // 感知子节点/树结点被点击
    // 参数为子组件的参数信息
    treeNodeClick (data, node, component) {
      console.log('子节点被点击……')
      console.log('子节点传递过来的详情：', data, node, component)
      console.log('当前点击子节点的菜单id:', data.catId)
    },
    // 每页数
    sizeChangeHandle (val) {
      this.pageSize = val
      this.pageIndex = 1
      this.getDataList()
    },
    // 当前页
    currentChangeHandle (val) {
      this.pageIndex = val
      this.getDataList()
    },
    // 多选
    selectionChangeHandle (val) {
      this.dataListSelections = val
    },
    // 新增 / 修改
    addOrUpdateHandle (id) {
      this.addOrUpdateVisible = true
      this.$nextTick(() => {
        this.$refs.addOrUpdate.init(id)
      })
    },
    // 删除
    deleteHandle (id) {
      var ids = id ? [id] : this.dataListSelections.map(item => {
        return item.attrGroupId
      })
      this.$confirm(`确定对[id=${ids.join(',')}]进行[${id ? '删除' : '批量删除'}]操作?`, '提示', {
        confirmButtonText: '确定',
        cancelButtonText: '取消',
        type: 'warning'
      }).then(() => {
        this.$http({
          url: this.$http.adornUrl('/product/attrgroup/delete'),
          method: 'post',
          data: this.$http.adornData(ids, false)
        }).then(({ data }) => {
          if (data && data.code === 0) {
            this.$message({
              message: '操作成功',
              type: 'success',
              duration: 1500,
              onClose: () => {
                this.getDataList()
              }
            })
          } else {
            this.$message.error(data.msg)
          }
        })
      })
    }
  }
}
</script>
<style lang='scss' scoped>
//@import url(); 引入公共 css 类
</style>
```



##### 7.2、获取分类属性分组

attrgroup.vue

```
<template>
  <el-row :gutter="20">
    <!-- 树形菜单 -->
    <el-col :span="6">
      <!-- 同过子组件发送的事件名称，绑定子组件的事件, 并自定义一个方法 -->
      <Category @tree-node-click="treeNodeClick"></Category>
    </el-col>
    <!-- 表格 -->
    <el-col :span="18">
      <div class="mod-config">
        <el-form
          :inline="true"
          :model="dataForm"
          @keyup.enter.native="getDataList()"
        >
          <el-form-item>
            <el-input
              v-model="dataForm.key"
              placeholder="参数名"
              clearable
            ></el-input>
          </el-form-item>
          <el-form-item>
            <el-button @click="getDataList()">查询</el-button>
            <el-button
              v-if="isAuth('product:attrgroup:save')"
              type="primary"
              @click="addOrUpdateHandle()"
              >新增</el-button
            >
            <el-button
              v-if="isAuth('product:attrgroup:delete')"
              type="danger"
              @click="deleteHandle()"
              :disabled="dataListSelections.length <= 0"
              >批量删除</el-button
            >
          </el-form-item>
        </el-form>
        <el-table
          :data="dataList"
          border
          v-loading="dataListLoading"
          @selection-change="selectionChangeHandle"
          style="width: 100%"
        >
          <el-table-column
            type="selection"
            header-align="center"
            align="center"
            width="50"
          >
          </el-table-column>
          <el-table-column
            prop="attrGroupId"
            header-align="center"
            align="center"
            label="分组id"
          >
          </el-table-column>
          <el-table-column
            prop="attrGroupName"
            header-align="center"
            align="center"
            label="组名"
          >
          </el-table-column>
          <el-table-column
            prop="sort"
            header-align="center"
            align="center"
            label="排序"
          >
          </el-table-column>
          <el-table-column
            prop="descript"
            header-align="center"
            align="center"
            label="描述"
          >
          </el-table-column>
          <el-table-column
            prop="icon"
            header-align="center"
            align="center"
            label="组图标"
          >
          </el-table-column>
          <el-table-column
            prop="catelogId"
            header-align="center"
            align="center"
            label="所属分类id"
          >
          </el-table-column>
          <el-table-column
            fixed="right"
            header-align="center"
            align="center"
            width="150"
            label="操作"
          >
            <template slot-scope="scope">
              <el-button
                type="text"
                size="small"
                @click="addOrUpdateHandle(scope.row.attrGroupId)"
                >修改</el-button
              >
              <el-button
                type="text"
                size="small"
                @click="deleteHandle(scope.row.attrGroupId)"
                >删除</el-button
              >
            </template>
          </el-table-column>
        </el-table>
        <el-pagination
          @size-change="sizeChangeHandle"
          @current-change="currentChangeHandle"
          :current-page="pageIndex"
          :page-sizes="[10, 20, 50, 100]"
          :page-size="pageSize"
          :total="totalPage"
          layout="total, sizes, prev, pager, next, jumper"
        >
        </el-pagination>
        <!-- 弹窗, 新增 / 修改 -->
        <add-or-update
          v-if="addOrUpdateVisible"
          ref="addOrUpdate"
          @refreshDataList="getDataList"
        ></add-or-update></div
    ></el-col>
  </el-row>
</template>

<script>
// 导入公共三级分类组件
import Category from '../common/category'
// 属性增加或修改组件
import AddOrUpdate from './attrgroup-add-or-update'
export default {
  // 声明组件
  components: { Category, AddOrUpdate },
  props: {},
  data () {
    // 这里存放数据
    return {
      // 三级分类id , 默认0
      catId: 0,
      dataForm: {
        key: ''
      },
      dataList: [],
      pageIndex: 1,
      pageSize: 10,
      totalPage: 0,
      dataListLoading: false,
      dataListSelections: [],
      addOrUpdateVisible: false
    }
  },
  activated () {
    this.getDataList()
  },
  methods: {
    // 获取数据列表
    getDataList () {
      this.dataListLoading = true
      this.$http({
        url: this.$http.adornUrl(`/product/attrgroup/list/${this.catId}`),
        method: 'get',
        params: this.$http.adornParams({
          'page': this.pageIndex,
          'limit': this.pageSize,
          'key': this.dataForm.key
        })
      }).then(({ data }) => {
        if (data && data.code === 0) {
          this.dataList = data.page.list
          this.totalPage = data.page.totalCount
        } else {
          this.dataList = []
          this.totalPage = 0
        }
        this.dataListLoading = false
      })
    },
    // 感知子节点/树结点被点击
    // 参数为子组件的参数信息
    treeNodeClick (data, node, component) {
      console.log('子节点被点击……')
      console.log('子节点传递过来的详情：', data, node, component)
      console.log('当前点击子节点的菜单id:', data.catId)
      if (node.level === 3) {
        // 当前是三级分类，需要改变分类id
        this.catId = data.catId
        // 重新获取数据
        this.getDataList()
      }
    },
    // 每页数
    sizeChangeHandle (val) {
      this.pageSize = val
      this.pageIndex = 1
      this.getDataList()
    },
    // 当前页
    currentChangeHandle (val) {
      this.pageIndex = val
      this.getDataList()
    },
    // 多选
    selectionChangeHandle (val) {
      this.dataListSelections = val
    },
    // 新增 / 修改
    addOrUpdateHandle (id) {
      this.addOrUpdateVisible = true
      this.$nextTick(() => {
        this.$refs.addOrUpdate.init(id)
      })
    },
    // 删除
    deleteHandle (id) {
      var ids = id ? [id] : this.dataListSelections.map(item => {
        return item.attrGroupId
      })
      this.$confirm(`确定对[id=${ids.join(',')}]进行[${id ? '删除' : '批量删除'}]操作?`, '提示', {
        confirmButtonText: '确定',
        cancelButtonText: '取消',
        type: 'warning'
      }).then(() => {
        this.$http({
          url: this.$http.adornUrl('/product/attrgroup/delete'),
          method: 'post',
          data: this.$http.adornData(ids, false)
        }).then(({ data }) => {
          if (data && data.code === 0) {
            this.$message({
              message: '操作成功',
              type: 'success',
              duration: 1500,
              onClose: () => {
                this.getDataList()
              }
            })
          } else {
            this.$message.error(data.msg)
          }
        })
      })
    }
  }
}
</script>
<style lang='scss' scoped>
//@import url(); 引入公共 css 类
</style>
```



##### 7.3、分组&级联选择器

```
<template>
  <el-dialog
    :title="!dataForm.attrGroupId ? '新增' : '修改'"
    :close-on-click-modal="false"
    :visible.sync="visible"
    @closed="dialogClose"
  >
    <el-form
      :model="dataForm"
      :rules="dataRule"
      ref="dataForm"
      @keyup.enter.native="dataFormSubmit()"
      label-width="80px"
    >
      <el-form-item label="组名" prop="attrGroupName">
        <el-input
          v-model="dataForm.attrGroupName"
          placeholder="组名"
        ></el-input>
      </el-form-item>
      <el-form-item label="排序" prop="sort">
        <el-input v-model="dataForm.sort" placeholder="排序"></el-input>
      </el-form-item>
      <el-form-item label="描述" prop="descript">
        <el-input v-model="dataForm.descript" placeholder="描述"></el-input>
      </el-form-item>
      <el-form-item label="组图标" prop="icon">
        <el-input v-model="dataForm.icon" placeholder="组图标"></el-input>
      </el-form-item>
      <el-form-item label="所属分类" prop="catelogId">
        <!-- <el-input v-model="dataForm.catelogId" placeholder="所属分类id"></el-input> -->
        <!-- 级联选择器：展示三级分类 -->
        <el-cascader
          filterable
          placeholder="搜索：手机"
          v-model="dataForm.catelogPath"
          :options="categorys"
          :props="props"
        ></el-cascader>
      </el-form-item>
    </el-form>
    <span slot="footer" class="dialog-footer">
      <el-button @click="visible = false">取消</el-button>
      <el-button type="primary" @click="dataFormSubmit()">确定</el-button>
    </span>
  </el-dialog>
</template>

<script>
export default {
  data () {
    return {
      // 级联菜单绑定的属性名
      props: {
        value: 'catId',
        label: 'name',
        children: 'children'
      },
      // 所有三级菜单
      categorys: [],
      visible: false,
      dataForm: {
        attrGroupId: 0,
        attrGroupName: '',
        sort: '',
        descript: '',
        icon: '',
        catelogPath: [],
        catelogId: 0
      },
      dataRule: {
        attrGroupName: [
          { required: true, message: '组名不能为空', trigger: 'blur' }
        ],
        sort: [
          { required: true, message: '排序不能为空', trigger: 'blur' }
        ],
        descript: [
          { required: true, message: '描述不能为空', trigger: 'blur' }
        ],
        icon: [
          { required: true, message: '组图标不能为空', trigger: 'blur' }
        ],
        catelogId: [
          { required: true, message: '所属分类id不能为空', trigger: 'blur' }
        ]
      }
    }
  },
  methods: {
    init (id) {
      this.dataForm.attrGroupId = id || 0
      this.visible = true
      this.$nextTick(() => {
        this.$refs['dataForm'].resetFields()
        if (this.dataForm.attrGroupId) {
          this.$http({
            url: this.$http.adornUrl(`/product/attrgroup/info/${this.dataForm.attrGroupId}`),
            method: 'get',
            params: this.$http.adornParams()
          }).then(({ data }) => {
            if (data && data.code === 0) {
              this.dataForm.attrGroupName = data.attrGroup.attrGroupName
              this.dataForm.sort = data.attrGroup.sort
              this.dataForm.descript = data.attrGroup.descript
              this.dataForm.icon = data.attrGroup.icon
              this.dataForm.catelogId = data.attrGroup.catelogId
              // 查询catelogId的完整路径
              this.dataForm.catelogPath = data.attrGroup.catelogPath
            }
          })
        }
      })
    },
    // 对话框关闭回调
    dialogClose () {
      this.dataForm.catelogPath = []
    },
    // 获取三级分类
    getCategorys () {
      this.$http({
        url: this.$http.adornUrl('/product/category/list/tree'),
        method: 'get'
      }).then(({ data }) => {
        this.categorys = data.data
      })
    },
    // 表单提交
    dataFormSubmit () {
      this.$refs['dataForm'].validate((valid) => {
        if (valid) {
          this.$http({
            url: this.$http.adornUrl(`/product/attrgroup/${!this.dataForm.attrGroupId ? 'save' : 'update'}`),
            method: 'post',
            data: this.$http.adornData({
              'attrGroupId': this.dataForm.attrGroupId || undefined,
              'attrGroupName': this.dataForm.attrGroupName,
              'sort': this.dataForm.sort,
              'descript': this.dataForm.descript,
              'icon': this.dataForm.icon,
              'catelogId': this.dataForm.catelogPath[this.dataForm.catelogPath.length - 1]
            })
          }).then(({ data }) => {
            if (data && data.code === 0) {
              this.$message({
                message: '操作成功',
                type: 'success',
                duration: 1500,
                onClose: () => {
                  this.visible = false
                  this.$emit('refreshDataList')
                }
              })
            } else {
              this.$message.error(data.msg)
            }
          })
        }
      })
    }
  },
  created () {
    // 初始化获取三级分类数据
    this.getCategorys()
  }
}
</script>

```

##### 7.4、分组修改回显

```
<template>
  <el-dialog
    :title="!dataForm.attrGroupId ? '新增' : '修改'"
    :close-on-click-modal="false"
    :visible.sync="visible"
    @closed="dialogClose"
  >
    <el-form
      :model="dataForm"
      :rules="dataRule"
      ref="dataForm"
      @keyup.enter.native="dataFormSubmit()"
      label-width="80px"
    >
      <el-form-item label="组名" prop="attrGroupName">
        <el-input
          v-model="dataForm.attrGroupName"
          placeholder="组名"
        ></el-input>
      </el-form-item>
      <el-form-item label="排序" prop="sort">
        <el-input v-model="dataForm.sort" placeholder="排序"></el-input>
      </el-form-item>
      <el-form-item label="描述" prop="descript">
        <el-input v-model="dataForm.descript" placeholder="描述"></el-input>
      </el-form-item>
      <el-form-item label="组图标" prop="icon">
        <el-input v-model="dataForm.icon" placeholder="组图标"></el-input>
      </el-form-item>
      <el-form-item label="所属分类" prop="catelogId">
        <!-- <el-input v-model="dataForm.catelogId" placeholder="所属分类id"></el-input> -->
        <!-- 级联选择器：展示三级分类 -->
        <el-cascader
          filterable
          placeholder="搜索：手机"
          v-model="dataForm.catelogPath"
          :options="categorys"
          :props="props"
        ></el-cascader>
      </el-form-item>
    </el-form>
    <span slot="footer" class="dialog-footer">
      <el-button @click="visible = false">取消</el-button>
      <el-button type="primary" @click="dataFormSubmit()">确定</el-button>
    </span>
  </el-dialog>
</template>

<script>
export default {
  data () {
    return {
      // 级联菜单绑定的属性名
      props: {
        value: 'catId',
        label: 'name',
        children: 'children'
      },
      // 所有三级菜单
      categorys: [],
      visible: false,
      dataForm: {
        attrGroupId: 0,
        attrGroupName: '',
        sort: '',
        descript: '',
        icon: '',
        catelogPath: [],
        catelogId: 0
      },
      dataRule: {
        attrGroupName: [
          { required: true, message: '组名不能为空', trigger: 'blur' }
        ],
        sort: [
          { required: true, message: '排序不能为空', trigger: 'blur' }
        ],
        descript: [
          { required: true, message: '描述不能为空', trigger: 'blur' }
        ],
        icon: [
          { required: true, message: '组图标不能为空', trigger: 'blur' }
        ],
        catelogId: [
          { required: true, message: '所属分类id不能为空', trigger: 'blur' }
        ]
      }
    }
  },
  methods: {
    init (id) {
      this.dataForm.attrGroupId = id || 0
      this.visible = true
      this.$nextTick(() => {
        this.$refs['dataForm'].resetFields()
        if (this.dataForm.attrGroupId) {
          this.$http({
            url: this.$http.adornUrl(`/product/attrgroup/info/${this.dataForm.attrGroupId}`),
            method: 'get',
            params: this.$http.adornParams()
          }).then(({ data }) => {
            if (data && data.code === 0) {
              this.dataForm.attrGroupName = data.attrGroup.attrGroupName
              this.dataForm.sort = data.attrGroup.sort
              this.dataForm.descript = data.attrGroup.descript
              this.dataForm.icon = data.attrGroup.icon
              this.dataForm.catelogId = data.attrGroup.catelogId
              // 查询catelogId的完整路径
              this.dataForm.catelogPath = data.attrGroup.catelogPath
            }
          })
        }
      })
    },
    // 对话框关闭回调
    dialogClose () {
      this.dataForm.catelogPath = []
    },
    // 获取三级分类
    getCategorys () {
      this.$http({
        url: this.$http.adornUrl('/product/category/list/tree'),
        method: 'get'
      }).then(({ data }) => {
        this.categorys = data.data
      })
    },
    // 表单提交
    dataFormSubmit () {
      this.$refs['dataForm'].validate((valid) => {
        if (valid) {
          this.$http({
            url: this.$http.adornUrl(`/product/attrgroup/${!this.dataForm.attrGroupId ? 'save' : 'update'}`),
            method: 'post',
            data: this.$http.adornData({
              'attrGroupId': this.dataForm.attrGroupId || undefined,
              'attrGroupName': this.dataForm.attrGroupName,
              'sort': this.dataForm.sort,
              'descript': this.dataForm.descript,
              'icon': this.dataForm.icon,
              'catelogId': this.dataForm.catelogPath[this.dataForm.catelogPath.length - 1]
            })
          }).then(({ data }) => {
            if (data && data.code === 0) {
              this.$message({
                message: '操作成功',
                type: 'success',
                duration: 1500,
                onClose: () => {
                  this.visible = false
                  this.$emit('refreshDataList')
                }
              })
            } else {
              this.$message.error(data.msg)
            }
          })
        }
      })
    }
  },
  created () {
    // 初始化获取三级分类数据
    this.getCategorys()
  }
}
</script>

```



### III、详情说明

#### 2、商品服务-品牌管理功能

##### 2.1、快速生成各品牌管理菜单

。。。

##### 2.2、快速优化与快速显示开关

。。。

##### 2.3、云存储开通与使用（附件上传）

**（1）不同类型的文件上传说明**

- 文件上传单体应用

将商品服务部署在一台服务器上，当浏览器上传文件或，该服务接受到文件后，将文件保存在该服务的某一个位置中

然后当浏览区需要该文件的时候，再进行返回显示

![image-20240224213908652](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240224213908652.png)

- 分布式文件上传

一台商品服务器可能不够，可能需要部署多台商品服务，以达到负载均衡的目的。

但是当我们上传文件的时候给了商品服务①，商品服务①会将文件保存在其服务中，当我们下次请求该文件的时候，由于负载均衡，请求到了商品服务②，而商品服务②中没有该文件，这样就会有问题。

![image-20240224214059758](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240224214059758.png)

- 统一的文件存储服务

![image-20240224214309871](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240224214309871.png)

自建服务器需要买服务器，并且搭建困难。

但是云存储只需要像第三方购买即可，即开即用，不需要搭建环境



因此我们这套项目采用的是阿里云对象存储。



**（2）阿里云对象存储oss的开通**

- 相关网址：

阿里云：

```
https://www.aliyun.com/product/oss?spm=a2c4g.11174283.J_4VYgf18xNlTAyFFbOuOQe.124.40f4de53qXFQ4r&scm=20140722.X_data-47ed1f95c8b1f5f652d4._.V_1
```

OOS帮助文档：

```
https://help.aliyun.com/zh/oss/developer-reference/description?spm=a2c4g.11186623.0.0.4d791855k57N26
```

JAVA SDK

```
https://help.aliyun.com/zh/oss/developer-reference/sdk-code-samples/?spm=a2c4g.11186623.0.i3
```

SDK快速入门上传文件

```
https://help.aliyun.com/zh/oss/developer-reference/getting-started?spm=a2c4g.11186623.0.i4
```





- 简介：

对象存储服务（Objejct Storage Service， OSS）是一种海量、安全、低成本、高可靠的云存储服务，适合存放任意类型的文件。容量和处理能力弹性扩展，多种存储类型供选择，全面优化存储成本。



- 上传服务的选择

① 阿里云对象存储-普通上传方式

文件先上传到应用服务器，再传到OSS

![image-20240224221648546](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240224221648546.png)

弊端：会占用大量的带宽



② 阿里云对象存储-服务端签名后直传

账号信息都保存在应用服务器，前端去向应用服务器获取伪签名，然后将文件和伪签名一起发到OSS中

OSS会进行校验

![image-20240224221708615](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240224221708615.png)





- 具体操作：

首先是一些实名认证，然后开通对象存储OSS

开通OSS后，进入管理控制台

一些相关资源术语描述：

![image-20240224220502569](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240224220502569.png)

创建一个新的存储空间（bucket）

![image-20240224220813896](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240224220813896.png)

![image-20240224221219386](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240224221219386.png)

![image-20240224221231061](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240224221231061.png)

创建完成

![image-20240224221311199](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240224221311199.png)



查看官方提供的文件上传（JAVA SDK，Software Development Kit，软件开发工具包）文档，使用原生的SDK实现文件的上传



首选在对应的项目中导入阿里云的对象存储依赖

```java
<dependency>
    <groupId>com.aliyun.oss</groupId>
    <artifactId>aliyun-sdk-oss</artifactId>
    <version>3.15.1</version>
</dependency>
```

开通使用子用户AccessKey（阿里云是一个主账号，主账号下可以有很多子用户）

![image-20240224222505569](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240224222505569.png)

![image-20240224222559014](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240224222559014.png)

使用OpenAPI调用访问，即我们可以在代码中，通过这个子用户的id和secret进行访问

控制台访问，就是我们可以使用这个子用户登录阿里云，进行控制台的访问

![image-20240224222728571](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240224222728571.png)

![image-20240224222817832](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240224222817832.png)

AccessKey ID：

```
LTAI5tHuankvMPQUGd8SHDnZ
```

AccessKey Secret：

```
js03wmaZMbFUtWteo807C0GaeH8Twf
```



为当前用户分配权限：

![image-20240224222925170](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240224222925170.png)

分配管理权限

![image-20240224222958849](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240224222958849.png)



**（3）SDK上传文件**

通过SDK编写文件上传的测试代码

```java
@Test
public void testUpload() throws FileNotFoundException, ClientException {
    // Endpoint以华东1（杭州）为例，其它Region请按实际情况填写。
    String endpoint = "oss-cn-hangzhou.aliyuncs.com";

    // 用户id 和 用户秘钥
    String accessKeyId = "LTAI5tHuankvMPQUGd8SHDnZ";
    String accessKeySecret = "js03wmaZMbFUtWteo807C0GaeH8Twf";

    // 填写Bucket名称，例如examplebucket。
    String bucketName = "tts-platform-oss";

    // 填写Object完整路径，例如exampledir/exampleobject.txt。Object完整路径中不能包含Bucket名称。
    String objectName = "test.jpg";

    // 创建OSSClient实例。
    OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);


    //上传文件流
    InputStream inputStream = new FileInputStream("D:\\offile\\YJY\\Photot (D A Y)\\QQ图片20180828193207.jpg");
    ossClient.putObject(bucketName, objectName, inputStream);

    System.out.println("上传文件成功");

}
```

![image-20240224224759333](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240224224759333.png)

![image-20240224224821770](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240224224821770.png)



**（4）SDK starter 上传文件**

以上是我们直接使用阿里云的原生sdk实现文件的上传的

我们在实际开发中，可以直接使用`Spring Cloud Alibaba`提供的`oss starter`去实现上面的功能

因为这是通用的，因此我们直接在`common`项目中导入对应的依赖

```xml
<!--阿里云对象存储的starter依赖-->
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alicloud-oss</artifactId>
</dependency>
```

然后我们可以在其中，也可以看到其引入了oss的sdk

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <groupId>com.alibaba.cloud</groupId>
        <artifactId>spring-cloud-starter-alicloud</artifactId>
        <version>2.1.0.RELEASE</version>
    </parent>
    <artifactId>spring-cloud-starter-alicloud-oss</artifactId>
    <name>Spring Cloud Starter Alibaba Cloud OSS</name>

    <dependencies>
        <dependency>
            <groupId>com.alibaba.cloud</groupId>
            <artifactId>spring-cloud-alicloud-oss</artifactId>
        </dependency>
        <dependency>
            <groupId>com.aliyun.oss</groupId>
            <artifactId>aliyun-sdk-oss</artifactId>
        </dependency>
    </dependencies>

</project>

```



然后，我们只需要在配置文件中将OSS中的AccessKey ID、secretKey和endpoint进行配置即可

```yml
spring:
  cloud:
    # 配置 nacos server注册中心地址
    nacos:
      discovery:
        server-addr: 127.0.0.1:8848
    # 配置阿里云存储对象的accessKey、secretKey和endpoint
    alicloud:
      access-key: LTAI5tHuankvMPQUGd8SHDnZ
      secret-key: js03wmaZMbFUtWteo807C0GaeH8Twf
      oss:
        endpoint: oss-cn-hangzhou.aliyuncs.com

```

只需要在业务代码中注入OSSClient，即可进行文件上传下载的操作

```java
@Autowired
OSSClient ossClient;

@Test
public void testUpload() throws FileNotFoundException, ClientException {
    // Endpoint以华东1（杭州）为例，其它Region请按实际情况填写。
    //String endpoint = "oss-cn-hangzhou.aliyuncs.com";

    // 用户id 和 用户秘钥
    //String accessKeyId = "LTAI5tHuankvMPQUGd8SHDnZ";
    //String accessKeySecret = "js03wmaZMbFUtWteo807C0GaeH8Twf";

    // 填写Bucket名称，例如examplebucket。
    String bucketName = "tts-platform-oss";

    // 填写Object完整路径，例如exampledir/exampleobject.txt。Object完整路径中不能包含Bucket名称。
    String objectName = "test2.jpg";

    // 创建OSSClient实例。
    //OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);


    //上传文件流
    InputStream inputStream = new FileInputStream("D:\\offile\\YJY\\Photot (D A Y)\\QQ图片20180828193207.jpg");
    ossClient.putObject(bucketName, objectName, inputStream);

    System.out.println("上传文件成功");

}
```

结果：上传成功

![image-20240224230959951](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240224230959951.png)



**（5）OSS获取服务端签名**

但是如果我们文件使用这种方式上传，我们首先要把文件提交到应用服务器上，这样做太麻烦了，总是要经过应用服务器！

最理想的就是浏览器只需要向我们的应用服务器要取签名数据，然后直接将文件提交到OSS即可。



因为之后我们会涉及到很多第三方功能，因此我们可以为其单独开一个微服务，详情见后端中的18.3的(1) 第三方微服务的创建



服务端签名直传的官方文档：

```
https://help.aliyun.com/zh/oss/use-cases/obtain-signature-information-from-the-server-and-upload-data-to-oss?spm=a2c4g.11186623.0.i8
```



请求流程：

![image-20240224235152545](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240224235152545.png)



具体的开发内容见18.3的（2）OSS获取服务端签名应用服务器核心代码解析





**（6）OSS前后联调测试上传**

OSS文件上传的前端代码见6.3、OSS文件上传实现



##### 2.4、表单校验&自定义校验器

（1）相关内容：

- 修改新增对话框中显示的值为true/false -> 1/0
- 列表显示图片，而不是显示图片地址文本内容（使用自定义模板）
- 表单校验（前端）
- 表单校验（服务端/后端）



（2）前端内容

见6.4、表单校验

见6.5、修改前端发送请求

(3） 后端内容

见18.4、JSR303数据校验

见18.5、统一处理异常

见18.6、JSR303分组校验

见18.7、JSR303自定义校验



##### 2.5、品牌分类与级联更新

（1）前端内容

直接将提供的common和product前端页面覆盖本地





（2）后端内容

品牌管理的模糊查询&分页显示

品牌分类关联



#### 3、商品服务-平台属性

##### 3.1、属性分组

（1）相关内容

平台属性-属性分组查询全部



（2）前端内容

7.1、前端组件的抽取、属性分组代码的编写、父子组件交互

7.2、获取分类属性分组

7.3、分组&级联选择器

7.4、分组修改回显

feature: 平台属性-属性分组查询全部

feature: 查询分组关联属性&删除关联（获取当前属性分组未关联的属性）



（3）后端内容

19.1、全量菜单初始化

19.2、获取分类属性分组

19.3、分组&级联选择器

19.4、分组修改回显

feature: 查询分组关联属性&删除关联

feature: 查询分组关联属性&删除关联（获取当前属性分组未关联的属性）

feature: 属性分组创建关联功能



##### 3.2、 规格参数

（1）前端内容

feature:规格参数新增

fixbug:规格可选值分割问题修复





（2）后端内容

feature:规格参数新增

feature: 规格参数列表

feature: 规格参数修改



##### 3.3、销售属性

（1）前端内容

feature: 销售属性维护



（2）后端内容

feature: 销售属性维护





#### 4、商品服务-商品维护

（1）前端内容

feature: 商品维护模块代码初始化

feate: 会员相关页面模块

feature: 获取分类关联的品牌

feature: 获取分类下所有分组以及属性

fixbug: 规格信息回显的路由配置和多选不显示问题修复





（2）后端内容

feature: 会员等级相关接口

feature: 获取分类关联的品牌

feature: 获取分类下所有分组以及属性

feature: 新增商品（保存SPU和SKU信息）

feature: 远程调用保存优惠价等信息&新增商品bug完善

feature: SPU检索

logic: mybatis自动插入时间信息配置

feature: SKU检索

feature: SPU规格维护（获取&修改）





#### 5、仓储服务-仓库管理

（1）前端内容

feature：整合ware服务

fixbug: 新增采购需求默认使用上次的采购单id



（2）后端内容

feature：整合ware服务&获取仓库列表的检索

feature: 查询库存&采购需求的检索

feature: 合并采购单

feature: 领取采购单

feature: 完成采购





#### 6、全文检索-ElasticSearch

##### 1.简介

https://www.elastic.co/cn/what-is/elasticsearch

全文搜索属于最常见的需求，开源的 Elasticsearch 是目前全文搜索引擎的首选。它可以快速地储存、搜索和分析海量数据。维基百科、Stack Overflow、Github 都采用它Elastic 的底层是开源库 Lucene。但是，你没法直接用 Lucene，必须自己写代码去调用它的接口。Elastic 是 Lucene 的封装，提供了 REST API 的操作接口，开箱即用。

REST API：天然的跨平台。

官方文档：https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html

官方中文：https://www.elastic.co/guide/cn/elasticsearch/guide/current/foreword_id.html

社区中文：

https://es.xiaoleilu.com/index.html

http://doc.codingdict.com/elasticsearch/0/



##### 2.基本概念

① Index（索引）

动词，相当于 MySQL 中的 insert；

名词，相当于 MySQL 中的 Database

② Type （类型）

在 Index（索引）中，可以定义一个或多个类型。

类似于 MySQL 中的 Table；每一种类型的数据放在一起；

③ Document（文档）

保存在某个索引（Index）下，某种类型（Type）的一个数据（Document），文档是 JSON 格

式的，Document 就像是 MySQL 中的某个 Table 里面的内容；

④ 倒排索引机制

![image-20240309205241922](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240309205241922.png)



对照图：

![image-20240309205401785](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240309205401785.png)





##### 3. docker安装ES

（1）下载ealastic search和kibana

```
// 存储和检索数据
docker pull elasticsearch:7.6.2			
// 可视化检索数据
docker pull kibana:7.6.2
```



![image-20240309211107719](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240309211107719.png)

（2）配置

```
mkdir -p /mydata/elasticsearch/config  创建目录
mkdir -p /mydata/elasticsearch/data
echo "http.host: 0.0.0.0" >/mydata/elasticsearch/config/elasticsearch.yml

//将mydata/elasticsearch/文件夹中文件都可读可写
chmod -R 777 /mydata/elasticsearch/
```



（3）启动Elastic search

```
// 9200 elas发送请求的端口
// 9300 elas集群状态下通讯的端口
docker run --name elasticsearch -p 9200:9200 -p 9300:9300 \
-e  "discovery.type=single-node" \
-e ES_JAVA_OPTS="-Xms64m -Xmx512m" \
-v /mydata/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml \
-v /mydata/elasticsearch/data:/usr/share/elasticsearch/data \
-v  /mydata/elasticsearch/plugins:/usr/share/elasticsearch/plugins \
-d elasticsearch:7.6.2 
```

![image-20240309220538168](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240309220538168.png)



设置开机启动elasticsearch

```
docker update elasticsearch --restart=always
```



（5）查看elasticsearch版本信息（测试）

![image-20240309221141577](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240309221141577.png)

显示elasticsearch 节点信息http://192.168.6.128:9200/_cat/nodes ，

```json
127.0.0.1 76 95 1 0.26 1.40 1.22 dilm * 0adeb7852e00
```





##### 5.docker启动Kibana

我们不装可视化界面，也可以通过postman以restful请求对es进行操作。

（1）启动kibana

```
docker run --name kibana -e ELASTICSEARCH_HOSTS=http://192.168.56.10:9200 -p 5601:5601 -d kibana:7.6.2
```

![image-20240309221001141](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240309221001141.png)

设置开机启动kibana

```
docker update kibana  --restart=always
```



（2）测试，使用kibana

访问Kibana： http://192.168.56.10:5601/app/kibana 

![image-20240309222048424](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240309222048424.png)



##### 6.初步检索

###### （1）_cat

用于查看ES的一些节点信息

- http://192.168.56.10:9200/_cat/nodes 查看所有节点信息

  注：*表示集群中的主节点

  ```
  127.0.0.1 61 91 11 0.08 0.49 0.87 dilm * 0adeb7852e00
  ```

- http://192.168.56.10:9200/_cat/health 查看es健康状况

  注：green表示健康值正常

  ```
  1588332616 11:30:16 elasticsearch green 1 1 3 3 0 0 0 0 - 100.0%
  ```

- http://192.168.56.10:9200/_cat/master 查看主节点

  ```
  vfpgxbusTC6-W3C2Np31EQ 127.0.0.1 127.0.0.1 0adeb7852e00
  ```

- http://192.168.56.10:9200/_cat/indices 查看所有索引 （类似mysql中的show databases）

  ```
  green open .kibana_task_manager_1   KWLtjcKRRuaV9so_v15WYg 1 0 2 0 39.8kb 39.8kb
  green open .apm-agent-configuration cuwCpJ5ER0OYsSgAJ7bVYA 1 0 0 0   283b   283b
  green open .kibana_1                PqK_LdUYRpWMy4fK0tMSPw 1 0 7 0 31.2kb 31.2kb
  ```

  

###### （2）索引一个文档

保存一个数据，保存在哪个索引的哪个类型下，指定用那个唯一标识
PUT customer/external/1;在customer索引下的external类型下保存1号数据为

关于PUT和POST的区别说明：

- POST新增。如果不指定id，会自动生成id。指定id就会修改这个数据，并新增版本号；
- PUT可以新增也可以修改。PUT必须指定id；由于PUT需要指定id，我们一般用来做修改操作，不指定id会报错。

注意：发送的数据都是json格式。



postman中使用PUT测试数据

![image-20240309232301143](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240309232301143.png)



创建数据成功后，显示201 created表示插入记录成功

```
{
    "_index": "customer",
    "_type": "external",
    "_id": "1",
    "_version": 1,
    "result": "created",
    "_shards": {
        "total": 2,
        "successful": 1,
        "failed": 0
    },
    "_seq_no": 0,
    "_primary_term": 1
}
```

这些返回的JSON串的含义；这些带有下划线开头的，称为元数据，反映了当前的基本信息。

- "_index": "customer" 表明该数据在哪个数据库下；

- "_type": "external"     表明该数据在哪个类型下；

- "_id": "1"                    表明被保存数据的id；

-  "_version": 1,            被保存数据的版本

- "result": "created"      这里是创建了一条数据，如果重新put一条数据，则该状态会变为updated，并且版本号也会发生变化。



postman中使用使用POST测试数据

添加数据的时候，不指定ID，会自动的生成id，并且类型是新增：

![image-20240309232335763](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240309232335763.png)

再次使用POST插入数据，仍然是新增的

![image-20240309232345659](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240309232345659.png)

添加数据的时候，指定ID，会使用该id，并且类型是新增：

![image-20240309232356612](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240309232356612.png)

再次使用POST插入数据，类型为updated

![image-20240309232407169](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240309232407169.png)



###### （3）查看文档

GET /customer/external/1

 http://192.168.6.128:9200/customer/external/1 

```json
{
    "_index": "customer",//在哪个索引
    "_type": "external",//在哪个类型
    "_id": "1",//记录id
    "_version": 3,//版本号
    "_seq_no": 6,//并发控制字段，每次更新都会+1，用来做乐观锁
    "_primary_term": 1,//同上，主分片重新分配，如重启，就会变化
    "found": true,
    "_source": {
        "name": "John Doe"
    }
}
```

 



通过“if_seq_no=1&if_primary_term=1 ”，当序列号匹配的时候，才进行修改，否则不修改。

实例：将id=1的数据更新为name=1，然后再次更新为name=2，起始_seq_no=6，_primary_term=1

将name更新为1

 http://192.168.6.128:9200/customer/external/1?if_seq_no=1&if_primary_term=1 

<img src="%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20200501212224983.png" alt="image-20200501212224983" style="zoom: 61%;" />

 将name更新为2，更新过程中使用seq_no=6

http://192.168.6.128:9200/customer/external/1?if_seq_no=6&if_primary_term=1 

<img src="%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20200501213047499.png" alt="image-20200501213047499" style="zoom: 60%;" />

出现更新错误。



查询新的数据

 http://192.168.6.128:9200/customer/external/1 

![image-20200501212924094](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20200501212924094.png)

能够看到_seq_no变为7。

再次更新，更新成功

 http://192.168.6.128:9200/customer/external/1?if_seq_no=7&if_primary_term=1 

![image-20240309233016483](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240309233016483.png)

###### （4） 更新文档

![image-20240309233617055](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240309233617055.png)

![image-20240309233636251](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240309233636251.png)

POST更新文档，带有_update

http://192.168.6.128:9200/customer/external/1/_update 

![image-20200501214810741](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20200501214810741.png)

如果再次执行更新，则不执行任何操作，序列号也不发生变化

![image-20200501214912607](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20200501214912607.png)

POST更新方式，会对比原来的数据，和原来的相同，则不执行任何操作（version和_seq_no）都不变。

 POST更新文档，不带_update

![image-20200501215358666](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20200501215358666.png)

在更新过程中，重复执行更新操作，数据也能够更新成功，不会和原来的数据进行对比。



###### （5） 删除文档或索引

```
DELETE customer/external/1
DELETE customer
```

注：elasticsearch并没有提供删除类型的操作，只提供了删除索引和文档的操作。



实例：删除id=1的数据，删除后继续查询

<img src="%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20200501220559094.png" alt="image-20200501220559094" style="zoom:67%;" />

实例：删除整个costomer索引数据

删除前，所有的索引

```
green  open .kibana_task_manager_1   KWLtjcKRRuaV9so_v15WYg 1 0 2 0 39.8kb 39.8kb
green  open .apm-agent-configuration cuwCpJ5ER0OYsSgAJ7bVYA 1 0 0 0   283b   283b
green  open .kibana_1                PqK_LdUYRpWMy4fK0tMSPw 1 0 7 0 31.2kb 31.2kb
yellow open customer                 nzDYCdnvQjSsapJrAIT8Zw 1 1 4 0  4.4kb  4.4kb
```

删除“ customer ”索引

![image-20200501221105476](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20200501221105476.png)

删除后，所有的索引

```
green  open .kibana_task_manager_1   KWLtjcKRRuaV9so_v15WYg 1 0 2 0 39.8kb 39.8kb
green  open .apm-agent-configuration cuwCpJ5ER0OYsSgAJ7bVYA 1 0 0 0   283b   283b
green  open .kibana_1                PqK_LdUYRpWMy4fK0tMSPw 1 0 7 0 31.2kb 31.2kb
```



###### （6） eleasticsearch的批量操作——bulk

语法格式：

```json
{action:{metadata}}\n   //例如index保存记录，update更新
{request body  }\n

{action:{metadata}}\n
{request body  }\n
```

这里的批量操作，当发生某一条执行发生失败时，其他的数据仍然能够接着执行，也就是说彼此之间是独立的。

bulk api以此按顺序执行所有的action（动作）。如果一个单个的动作因任何原因失败，它将继续处理它后面剩余的动作。当bulk api返回时，它将提供每个动作的状态（与发送的顺序相同），所以您可以检查是否一个指定的动作是否失败了。

实例1: 执行多条数据 (postman 报错，在kibana中的Dev_tools中执行)


```json
POST /customer/external/_bulk
{"index":{"_id":"1"}}
{"name":"John Doe"}
{"index":{"_id":"2"}}
{"name":"John Doe"}
```

执行结果

```json
#! Deprecation: [types removal] Specifying types in bulk requests is deprecated.
{
  "took" : 491,
  "errors" : false,
  "items" : [
    {
      "index" : {
        "_index" : "customer",
        "_type" : "external",
        "_id" : "1",
        "_version" : 1,
        "result" : "created",
        "_shards" : {
          "total" : 2,
          "successful" : 1,
          "failed" : 0
        },
        "_seq_no" : 0,
        "_primary_term" : 1,
        "status" : 201
      }
    },
    {
      "index" : {
        "_index" : "customer",
        "_type" : "external",
        "_id" : "2",
        "_version" : 1,
        "result" : "created",
        "_shards" : {
          "total" : 2,
          "successful" : 1,
          "failed" : 0
        },
        "_seq_no" : 1,
        "_primary_term" : 1,
        "status" : 201
      }
    }
  ]
}

```



实例2：对于整个索引执行批量操作

```json
POST /_bulk
{"delete":{"_index":"website","_type":"blog","_id":"123"}}
{"create":{"_index":"website","_type":"blog","_id":"123"}}
{"title":"my first blog post"}
{"index":{"_index":"website","_type":"blog"}}
{"title":"my second blog post"}
{"update":{"_index":"website","_type":"blog","_id":"123"}}
{"doc":{"title":"my updated blog post"}}
```

运行结果：

```json
#! Deprecation: [types removal] Specifying types in bulk requests is deprecated.
{
  "took" : 608,
  "errors" : false,
  "items" : [
    {
      "delete" : {
        "_index" : "website",
        "_type" : "blog",
        "_id" : "123",
        "_version" : 1,
        "result" : "not_found",
        "_shards" : {
          "total" : 2,
          "successful" : 1,
          "failed" : 0
        },
        "_seq_no" : 0,
        "_primary_term" : 1,
        "status" : 404
      }
    },
    {
      "create" : {
        "_index" : "website",
        "_type" : "blog",
        "_id" : "123",
        "_version" : 2,
        "result" : "created",
        "_shards" : {
          "total" : 2,
          "successful" : 1,
          "failed" : 0
        },
        "_seq_no" : 1,
        "_primary_term" : 1,
        "status" : 201
      }
    },
    {
      "index" : {
        "_index" : "website",
        "_type" : "blog",
        "_id" : "MCOs0HEBHYK_MJXUyYIz",
        "_version" : 1,
        "result" : "created",
        "_shards" : {
          "total" : 2,
          "successful" : 1,
          "failed" : 0
        },
        "_seq_no" : 2,
        "_primary_term" : 1,
        "status" : 201
      }
    },
    {
      "update" : {
        "_index" : "website",
        "_type" : "blog",
        "_id" : "123",
        "_version" : 3,
        "result" : "updated",
        "_shards" : {
          "total" : 2,
          "successful" : 1,
          "failed" : 0
        },
        "_seq_no" : 3,
        "_primary_term" : 1,
        "status" : 200
      }
    }
  ]
}

```



###### （7）样本测试数据

准备了一份顾客银行账户信息的虚构的JSON文档样本。每个文档都有下列的schema（模式）。

```json
{
	"account_number": 1,
	"balance": 39225,
	"firstname": "Amber",
	"lastname": "Duke",
	"age": 32,
	"gender": "M",
	"address": "880 Holmes Lane",
	"employer": "Pyrami",
	"email": "amberduke@pyrami.com",
	"city": "Brogan",
	"state": "IL"
}
```

 https://github.com/elastic/elasticsearch/blob/master/docs/src/test/resources/accounts.json?raw=true 或

https://github.com/elastic/elasticsearch/blob/7.5/docs/src/test/resources/accounts.json，导入测试数据，

POST bank/account/_bulk

![image-20240310001059305](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240310001059305.png)

![image-20240310001131685](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240310001131685.png)



##### 7.检索进阶

###### 0）官方文档

elastic.co/guide/index.html



###### 1）search Api

ES支持两种基本方式检索；

* 通过REST request uri 发送搜索参数 （uri +检索参数）；
* 通过REST request body 来发送它们（uri+请求体）；

信息检索

![image-20240310002017536](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240310002017536.png)

![image-20240310002041817](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240310002041817.png)

uri+请求体进行检索

```json
GET /bank/_search
{
  "query": { "match_all": {} },
  "sort": [
    { "account_number": "asc" },
    {"balance":"desc"}
  ]
}

```



HTTP客户端工具（），get请求不能够携带请求体，




```java
GET bank/_search?q=*&sort=account_number:asc
//q=* 查询所有，sort=account_number:asc 按照account_number进行asc升序排列sort
```

返回结果：

```
{
  "took" : 235,
  "timed_out" : false,
  "_shards" : {
    "total" : 1,
    "successful" : 1,
    "skipped" : 0,
    "failed" : 0
  },
  "hits" : {
    "total" : {
      "value" : 1000,
      "relation" : "eq"
    },
    "max_score" : null,
    "hits" : [
      {
        "_index" : "bank",
        "_type" : "account",
        "_id" : "0",
        "_score" : null,
        "_source" : {
          "account_number" : 0,
          "balance" : 16623,
          "firstname" : "Bradshaw",
          "lastname" : "Mckenzie",
          "age" : 29,
          "gender" : "F",
          "address" : "244 Columbus Place",
          "employer" : "Euron",
          "email" : "bradshawmckenzie@euron.com",
          "city" : "Hobucken",
          "state" : "CO"
        },
        "sort" : [
          0
        ]
      },
      {
        "_index" : "bank",
        "_type" : "account",
        "_id" : "1",
        "_score" : null,
        "_source" : {
          "account_number" : 1,
          "balance" : 39225,
          "firstname" : "Amber",
          "lastname" : "Duke",
          "age" : 32,
          "gender" : "M",
          "address" : "880 Holmes Lane",
          "employer" : "Pyrami",
          "email" : "amberduke@pyrami.com",
          "city" : "Brogan",
          "state" : "IL"
        },
        "sort" : [
          1
        ]
      },
      {
        "_index" : "bank",
        "_type" : "account",
        "_id" : "2",
        "_score" : null,
        "_source" : {
          "account_number" : 2,
          "balance" : 28838,
          "firstname" : "Roberta",
          "lastname" : "Bender",
          "age" : 22,
          "gender" : "F",
          "address" : "560 Kingsway Place",
          "employer" : "Chillium",
          "email" : "robertabender@chillium.com",
          "city" : "Bennett",
          "state" : "LA"
        },
        "sort" : [
          2
        ]
      },
      {
        "_index" : "bank",
        "_type" : "account",
        "_id" : "3",
        "_score" : null,
        "_source" : {
          "account_number" : 3,
          "balance" : 44947,
          "firstname" : "Levine",
          "lastname" : "Burks",
          "age" : 26,
          "gender" : "F",
          "address" : "328 Wilson Avenue",
          "employer" : "Amtap",
          "email" : "levineburks@amtap.com",
          "city" : "Cochranville",
          "state" : "HI"
        },
        "sort" : [
          3
        ]
      },
      {
        "_index" : "bank",
        "_type" : "account",
        "_id" : "4",
        "_score" : null,
        "_source" : {
          "account_number" : 4,
          "balance" : 27658,
          "firstname" : "Rodriquez",
          "lastname" : "Flores",
          "age" : 31,
          "gender" : "F",
          "address" : "986 Wyckoff Avenue",
          "employer" : "Tourmania",
          "email" : "rodriquezflores@tourmania.com",
          "city" : "Eastvale",
          "state" : "HI"
        },
        "sort" : [
          4
        ]
      },
      {
        "_index" : "bank",
        "_type" : "account",
        "_id" : "5",
        "_score" : null,
        "_source" : {
          "account_number" : 5,
          "balance" : 29342,
          "firstname" : "Leola",
          "lastname" : "Stewart",
          "age" : 30,
          "gender" : "F",
          "address" : "311 Elm Place",
          "employer" : "Diginetic",
          "email" : "leolastewart@diginetic.com",
          "city" : "Fairview",
          "state" : "NJ"
        },
        "sort" : [
          5
        ]
      },
      {
        "_index" : "bank",
        "_type" : "account",
        "_id" : "6",
        "_score" : null,
        "_source" : {
          "account_number" : 6,
          "balance" : 5686,
          "firstname" : "Hattie",
          "lastname" : "Bond",
          "age" : 36,
          "gender" : "M",
          "address" : "671 Bristol Street",
          "employer" : "Netagy",
          "email" : "hattiebond@netagy.com",
          "city" : "Dante",
          "state" : "TN"
        },
        "sort" : [
          6
        ]
      },
      {
        "_index" : "bank",
        "_type" : "account",
        "_id" : "7",
        "_score" : null,
        "_source" : {
          "account_number" : 7,
          "balance" : 39121,
          "firstname" : "Levy",
          "lastname" : "Richard",
          "age" : 22,
          "gender" : "M",
          "address" : "820 Logan Street",
          "employer" : "Teraprene",
          "email" : "levyrichard@teraprene.com",
          "city" : "Shrewsbury",
          "state" : "MO"
        },
        "sort" : [
          7
        ]
      },
      {
        "_index" : "bank",
        "_type" : "account",
        "_id" : "8",
        "_score" : null,
        "_source" : {
          "account_number" : 8,
          "balance" : 48868,
          "firstname" : "Jan",
          "lastname" : "Burns",
          "age" : 35,
          "gender" : "M",
          "address" : "699 Visitation Place",
          "employer" : "Glasstep",
          "email" : "janburns@glasstep.com",
          "city" : "Wakulla",
          "state" : "AZ"
        },
        "sort" : [
          8
        ]
      },
      {
        "_index" : "bank",
        "_type" : "account",
        "_id" : "9",
        "_score" : null,
        "_source" : {
          "account_number" : 9,
          "balance" : 24776,
          "firstname" : "Opal",
          "lastname" : "Meadows",
          "age" : 39,
          "gender" : "M",
          "address" : "963 Neptune Avenue",
          "employer" : "Cedward",
          "email" : "opalmeadows@cedward.com",
          "city" : "Olney",
          "state" : "OH"
        },
        "sort" : [
          9
        ]
      }
    ]
  }
}

```



（1）只有9条数据，这是因为存在分页查询；

（2）详细的字段信息，参照： https://www.elastic.co/guide/en/elasticsearch/reference/current/getting-started-search.html 

>
>
>The response also provides the following information about the search request:
>
>- `took` – how long it took Elasticsearch to run the query, in milliseconds
>- `timed_out` – whether or not the search request timed out
>- `_shards` – how many shards were searched and a breakdown of how many shards succeeded, failed, or were skipped.
>- `max_score` – the score of the most relevant document found
>- `hits.total.value` - how many matching documents were found
>- `hits.sort` - the document’s sort position (when not sorting by relevance score)
>- `hits._score` - the document’s relevance score (not applicable when using `match_all`)





###### 2）Query DSL

（1）.基本语法格式：

- Elasticsearch提供了一个可以执行查询的Json风格的DSL。这个被称为Query DSL，该查询语言非常全面。

一个查询语句的典型结构

```
QUERY_NAME:{
   ARGUMENT:VALUE,
   ARGUMENT:VALUE,...
}
```

- 如果针对于某个字段，那么它的结构如下：

```
{
  QUERY_NAME:{
     FIELD_NAME:{
       ARGUMENT:VALUE,
       ARGUMENT:VALUE,...
      }   
   }
}
```

eg:

```
GET bank/_search
{
  "query": {
    "match_all": {}
  },
  "from": 0,
  "size": 5,
  "sort": [
    {
      "account_number": {
        "order": "desc"
      }
    }
  ]
}
//match_al查询所有，从第0个数据拿5个数据
```

query定义如何查询；

- match_all查询类型【代表查询所有的所有】，es中可以在query中组合非常多的查询类型完成复杂查询；
- 除了query参数之外，我们可也传递其他的参数以改变查询结果，如sort，size；
- from+size限定，完成分页功能；
- sort排序，多字段排序，会在前序字段相等时后续字段内部排序，否则以前序为准；





（2）.返回部分字段:

```
GET bank/_search
{
  "query": {
    "match_all": {}
  },
  "from": 0,
  "size": 5,
  "sort": [
    {
      "account_number": {
        "order": "desc"
      }
    }
  ],
  "_source": ["balance","firstname"]
  
}

```

查询结果：

```
{
  "took" : 18,
  "timed_out" : false,
  "_shards" : {
    "total" : 1,
    "successful" : 1,
    "skipped" : 0,
    "failed" : 0
  },
  "hits" : {
    "total" : {
      "value" : 1000,
      "relation" : "eq"
    },
    "max_score" : null,
    "hits" : [
      {
        "_index" : "bank",
        "_type" : "account",
        "_id" : "999",
        "_score" : null,
        "_source" : {
          "firstname" : "Dorothy",
          "balance" : 6087
        },
        "sort" : [
          999
        ]
      },
      {
        "_index" : "bank",
        "_type" : "account",
        "_id" : "998",
        "_score" : null,
        "_source" : {
          "firstname" : "Letha",
          "balance" : 16869
        },
        "sort" : [
          998
        ]
      },
      {
        "_index" : "bank",
        "_type" : "account",
        "_id" : "997",
        "_score" : null,
        "_source" : {
          "firstname" : "Combs",
          "balance" : 25311
        },
        "sort" : [
          997
        ]
      },
      {
        "_index" : "bank",
        "_type" : "account",
        "_id" : "996",
        "_score" : null,
        "_source" : {
          "firstname" : "Andrews",
          "balance" : 17541
        },
        "sort" : [
          996
        ]
      },
      {
        "_index" : "bank",
        "_type" : "account",
        "_id" : "995",
        "_score" : null,
        "_source" : {
          "firstname" : "Phelps",
          "balance" : 21153
        },
        "sort" : [
          995
        ]
      }
    ]
  }
}

```

（3）.match 匹配查询

- 基本类型（非字符串），"account_number": 20 可加可不加“ ” 不加就是精确匹配

```
GET bank/_search
{
  "query": {
    "match": {
      "account_number": "20"
    }
  }
}
```

match返回account_number=20的数据，结果如下：

```
{
  "took" : 1,
  "timed_out" : false,
  "_shards" : {
    "total" : 1,
    "successful" : 1,
    "skipped" : 0,
    "failed" : 0
  },
  "hits" : {
    "total" : {
      "value" : 1,
      "relation" : "eq"
    },
    "max_score" : 1.0,
    "hits" : [
      {
        "_index" : "bank",
        "_type" : "account",
        "_id" : "20",
        "_score" : 1.0,
        "_source" : {
          "account_number" : 20,
          "balance" : 16418,
          "firstname" : "Elinor",
          "lastname" : "Ratliff",
          "age" : 36,
          "gender" : "M",
          "address" : "282 Kings Place",
          "employer" : "Scentric",
          "email" : "elinorratliff@scentric.com",
          "city" : "Ribera",
          "state" : "WA"
        }
      }
    ]
  }
}

```

- 字符串，全文检索“ ” 模糊查询

```
GET bank/_search
{
  "query": {
    "match": {
      "address": "kings"
    }
  }
}
```

全文检索，最终会按照评分进行排序，会对检索条件进行分词匹配。

查询结果：

```
{
  "took" : 30,
  "timed_out" : false,
  "_shards" : {
    "total" : 1,
    "successful" : 1,
    "skipped" : 0,
    "failed" : 0
  },
  "hits" : {
    "total" : {
      "value" : 2,
      "relation" : "eq"
    },
    "max_score" : 5.990829,
    "hits" : [
      {
        "_index" : "bank",
        "_type" : "account",
        "_id" : "20",
        "_score" : 5.990829,
        "_source" : {
          "account_number" : 20,
          "balance" : 16418,
          "firstname" : "Elinor",
          "lastname" : "Ratliff",
          "age" : 36,
          "gender" : "M",
          "address" : "282 Kings Place",
          "employer" : "Scentric",
          "email" : "elinorratliff@scentric.com",
          "city" : "Ribera",
          "state" : "WA"
        }
      },
      {
        "_index" : "bank",
        "_type" : "account",
        "_id" : "722",
        "_score" : 5.990829,
        "_source" : {
          "account_number" : 722,
          "balance" : 27256,
          "firstname" : "Roberts",
          "lastname" : "Beasley",
          "age" : 34,
          "gender" : "F",
          "address" : "305 Kings Hwy",
          "employer" : "Quintity",
          "email" : "robertsbeasley@quintity.com",
          "city" : "Hayden",
          "state" : "PA"
        }
      }
    ]
  }
}

```

（4）.match_phrase [短句匹配] 

将需要匹配的值当成一整个单词（不分词）进行检索

```
GET bank/_search
{
  "query": {
    "match_phrase": {
      "address": "mill road"
    }
  }
}
```

查处address中包含mill_road的所有记录，并给出相关性得分

查看结果：

```
{
  "took" : 32,
  "timed_out" : false,
  "_shards" : {
    "total" : 1,
    "successful" : 1,
    "skipped" : 0,
    "failed" : 0
  },
  "hits" : {
    "total" : {
      "value" : 1,
      "relation" : "eq"
    },
    "max_score" : 8.926605,
    "hits" : [
      {
        "_index" : "bank",
        "_type" : "account",
        "_id" : "970",
        "_score" : 8.926605,
        "_source" : {
          "account_number" : 970,
          "balance" : 19648,
          "firstname" : "Forbes",
          "lastname" : "Wallace",
          "age" : 28,
          "gender" : "M",
          "address" : "990 Mill Road",
          "employer" : "Pheast",
          "email" : "forbeswallace@pheast.com",
          "city" : "Lopezo",
          "state" : "AK"
        }
      }
    ]
  }
}

```

match_phrase和match的区别，观察如下实例：

match_phrase是做短语匹配

match是分词匹配，例如990 Mill匹配含有**990或者Mill**的结果

```
GET bank/_search
{
  "query": {
    "match_phrase": {
      "address": "990 Mill"
    }
  }
}
```

查询结果：

```
{
  "took" : 0,
  "timed_out" : false,
  "_shards" : {
    "total" : 1,
    "successful" : 1,
    "skipped" : 0,
    "failed" : 0
  },
  "hits" : {
    "total" : {
      "value" : 1,
      "relation" : "eq"
    },
    "max_score" : 10.806405,
    "hits" : [
      {
        "_index" : "bank",
        "_type" : "account",
        "_id" : "970",
        "_score" : 10.806405,
        "_source" : {
          "account_number" : 970,
          "balance" : 19648,
          "firstname" : "Forbes",
          "lastname" : "Wallace",
          "age" : 28,
          "gender" : "M",
          "address" : "990 Mill Road",
          "employer" : "Pheast",
          "email" : "forbeswallace@pheast.com",
          "city" : "Lopezo",
          "state" : "AK"
        }
      }
    ]
  }
}

```

使用match的keyword

```json
GET bank/_search
{
  "query": {
    "match": {
      "address.keyword": "990 Mill"
    }
  }
}
```

查询结果，一条也未匹配到

```json
{
  "took" : 0,
  "timed_out" : false,
  "_shards" : {
    "total" : 1,
    "successful" : 1,
    "skipped" : 0,
    "failed" : 0
  },
  "hits" : {
    "total" : {
      "value" : 0,
      "relation" : "eq"
    },
    "max_score" : null,
    "hits" : [ ]
  }
}

```



修改匹配条件为“990 Mill Road”

```json
GET bank/_search
{
  "query": {
    "match": {
      "address.keyword": "990 Mill Road"
    }
  }
}
```

查询出一条数据

```json
{
  "took" : 1,
  "timed_out" : false,
  "_shards" : {
    "total" : 1,
    "successful" : 1,
    "skipped" : 0,
    "failed" : 0
  },
  "hits" : {
    "total" : {
      "value" : 1,
      "relation" : "eq"
    },
    "max_score" : 6.5032897,
    "hits" : [
      {
        "_index" : "bank",
        "_type" : "account",
        "_id" : "970",
        "_score" : 6.5032897,
        "_source" : {
          "account_number" : 970,
          "balance" : 19648,
          "firstname" : "Forbes",
          "lastname" : "Wallace",
          "age" : 28,
          "gender" : "M",
          "address" : "990 Mill Road",
          "employer" : "Pheast",
          "email" : "forbeswallace@pheast.com",
          "city" : "Lopezo",
          "state" : "AK"
        }
      }
    ]
  }
}

```



文本字段的匹配，使用keyword，匹配的条件就是要显示字段的全部值，要进行精确匹配的。

match_phrase是做短语匹配，只要文本中包含匹配条件既包含这个短语，就能匹配到

（5）.multi_math【多字段匹配】

```
GET bank/_search
{
  "query": {
    "multi_match": {
      "query": "mill",
      "fields": [
        "state",
        "address"
      ]
    }
  }
}
```

state或者address中包含mill，并且在查询过程中，会对于查询条件进行分词。

查询结果：

```
{
  "took" : 28,
  "timed_out" : false,
  "_shards" : {
    "total" : 1,
    "successful" : 1,
    "skipped" : 0,
    "failed" : 0
  },
  "hits" : {
    "total" : {
      "value" : 4,
      "relation" : "eq"
    },
    "max_score" : 5.4032025,
    "hits" : [
      {
        "_index" : "bank",
        "_type" : "account",
        "_id" : "970",
        "_score" : 5.4032025,
        "_source" : {
          "account_number" : 970,
          "balance" : 19648,
          "firstname" : "Forbes",
          "lastname" : "Wallace",
          "age" : 28,
          "gender" : "M",
          "address" : "990 Mill Road",
          "employer" : "Pheast",
          "email" : "forbeswallace@pheast.com",
          "city" : "Lopezo",
          "state" : "AK"
        }
      },
      {
        "_index" : "bank",
        "_type" : "account",
        "_id" : "136",
        "_score" : 5.4032025,
        "_source" : {
          "account_number" : 136,
          "balance" : 45801,
          "firstname" : "Winnie",
          "lastname" : "Holland",
          "age" : 38,
          "gender" : "M",
          "address" : "198 Mill Lane",
          "employer" : "Neteria",
          "email" : "winnieholland@neteria.com",
          "city" : "Urie",
          "state" : "IL"
        }
      },
      {
        "_index" : "bank",
        "_type" : "account",
        "_id" : "345",
        "_score" : 5.4032025,
        "_source" : {
          "account_number" : 345,
          "balance" : 9812,
          "firstname" : "Parker",
          "lastname" : "Hines",
          "age" : 38,
          "gender" : "M",
          "address" : "715 Mill Avenue",
          "employer" : "Baluba",
          "email" : "parkerhines@baluba.com",
          "city" : "Blackgum",
          "state" : "KY"
        }
      },
      {
        "_index" : "bank",
        "_type" : "account",
        "_id" : "472",
        "_score" : 5.4032025,
        "_source" : {
          "account_number" : 472,
          "balance" : 25571,
          "firstname" : "Lee",
          "lastname" : "Long",
          "age" : 32,
          "gender" : "F",
          "address" : "288 Mill Street",
          "employer" : "Comverges",
          "email" : "leelong@comverges.com",
          "city" : "Movico",
          "state" : "MT"
        }
      }
    ]
  }
}

```

（6).bool用来做复合查询

复合语句可以合并，任何其他查询语句，包括符合语句。这也就意味着，复合语句之间
可以互相嵌套，可以表达非常复杂的逻辑。

must：必须达到must所列举的所有条件

```json
GET bank/_search
{
   "query":{
        "bool":{
             "must":[
              {"match":{"address":"mill"}},
              {"match":{"gender":"M"}}
             ]
         }
    }
}
```

must_not，必须不匹配must_not所列举的所有条件。

should，应该满足should所列举的条件。



实例：查询gender=m，并且address=mill的数据

```json
GET bank/_search
{
  "query": {
    "bool": {
      "must": [
        {
          "match": {
            "gender": "M"
          }
        },
        {
          "match": {
            "address": "mill"
          }
        }
      ]
    }
  }
}
```

查询结果：

```json
{
  "took" : 1,
  "timed_out" : false,
  "_shards" : {
    "total" : 1,
    "successful" : 1,
    "skipped" : 0,
    "failed" : 0
  },
  "hits" : {
    "total" : {
      "value" : 3,
      "relation" : "eq"
    },
    "max_score" : 6.0824604,
    "hits" : [
      {
        "_index" : "bank",
        "_type" : "account",
        "_id" : "970",
        "_score" : 6.0824604,
        "_source" : {
          "account_number" : 970,
          "balance" : 19648,
          "firstname" : "Forbes",
          "lastname" : "Wallace",
          "age" : 28,
          "gender" : "M",
          "address" : "990 Mill Road",
          "employer" : "Pheast",
          "email" : "forbeswallace@pheast.com",
          "city" : "Lopezo",
          "state" : "AK"
        }
      },
      {
        "_index" : "bank",
        "_type" : "account",
        "_id" : "136",
        "_score" : 6.0824604,
        "_source" : {
          "account_number" : 136,
          "balance" : 45801,
          "firstname" : "Winnie",
          "lastname" : "Holland",
          "age" : 38,
          "gender" : "M",
          "address" : "198 Mill Lane",
          "employer" : "Neteria",
          "email" : "winnieholland@neteria.com",
          "city" : "Urie",
          "state" : "IL"
        }
      },
      {
        "_index" : "bank",
        "_type" : "account",
        "_id" : "345",
        "_score" : 6.0824604,
        "_source" : {
          "account_number" : 345,
          "balance" : 9812,
          "firstname" : "Parker",
          "lastname" : "Hines",
          "age" : 38,
          "gender" : "M",
          "address" : "715 Mill Avenue",
          "employer" : "Baluba",
          "email" : "parkerhines@baluba.com",
          "city" : "Blackgum",
          "state" : "KY"
        }
      }
    ]
  }
}

```

**must_not：必须不是指定的情况**

实例：查询gender=m，并且address=mill的数据，但是age不等于38的

```json
GET bank/_search
{
  "query": {
    "bool": {
      "must": [
        {
          "match": {
            "gender": "M"
          }
        },
        {
          "match": {
            "address": "mill"
          }
        }
      ],
      "must_not": [
        {
          "match": {
            "age": "38"
          }
        }
      ]
    }
  }

```

查询结果：

```json
{
  "took" : 4,
  "timed_out" : false,
  "_shards" : {
    "total" : 1,
    "successful" : 1,
    "skipped" : 0,
    "failed" : 0
  },
  "hits" : {
    "total" : {
      "value" : 1,
      "relation" : "eq"
    },
    "max_score" : 6.0824604,
    "hits" : [
      {
        "_index" : "bank",
        "_type" : "account",
        "_id" : "970",
        "_score" : 6.0824604,
        "_source" : {
          "account_number" : 970,
          "balance" : 19648,
          "firstname" : "Forbes",
          "lastname" : "Wallace",
          "age" : 28,
          "gender" : "M",
          "address" : "990 Mill Road",
          "employer" : "Pheast",
          "email" : "forbeswallace@pheast.com",
          "city" : "Lopezo",
          "state" : "AK"
        }
      }
    ]
  }
}

```





**should：应该达到should列举的条件，如果到达会增加相关文档的评分，并不会改变查询的结果。如果query中只有should且只有一种匹配规则，那么should的条件就会被作为默认匹配条件二区改变查询结果。**

实例：匹配lastName应该等于Wallace的数据

```json
GET bank/_search
{
  "query": {
    "bool": {
      "must": [
        {
          "match": {
            "gender": "M"
          }
        },
        {
          "match": {
            "address": "mill"
          }
        }
      ],
      "must_not": [
        {
          "match": {
            "age": "18"
          }
        }
      ],
      "should": [
        {
          "match": {
            "lastname": "Wallace"
          }
        }
      ]
    }
  }
}
```



查询结果：

```json
{
  "took" : 5,
  "timed_out" : false,
  "_shards" : {
    "total" : 1,
    "successful" : 1,
    "skipped" : 0,
    "failed" : 0
  },
  "hits" : {
    "total" : {
      "value" : 3,
      "relation" : "eq"
    },
    "max_score" : 12.585751,
    "hits" : [
      {
        "_index" : "bank",
        "_type" : "account",
        "_id" : "970",
        "_score" : 12.585751,
        "_source" : {
          "account_number" : 970,
          "balance" : 19648,
          "firstname" : "Forbes",
          "lastname" : "Wallace",
          "age" : 28,
          "gender" : "M",
          "address" : "990 Mill Road",
          "employer" : "Pheast",
          "email" : "forbeswallace@pheast.com",
          "city" : "Lopezo",
          "state" : "AK"
        }
      },
      {
        "_index" : "bank",
        "_type" : "account",
        "_id" : "136",
        "_score" : 6.0824604,
        "_source" : {
          "account_number" : 136,
          "balance" : 45801,
          "firstname" : "Winnie",
          "lastname" : "Holland",
          "age" : 38,
          "gender" : "M",
          "address" : "198 Mill Lane",
          "employer" : "Neteria",
          "email" : "winnieholland@neteria.com",
          "city" : "Urie",
          "state" : "IL"
        }
      },
      {
        "_index" : "bank",
        "_type" : "account",
        "_id" : "345",
        "_score" : 6.0824604,
        "_source" : {
          "account_number" : 345,
          "balance" : 9812,
          "firstname" : "Parker",
          "lastname" : "Hines",
          "age" : 38,
          "gender" : "M",
          "address" : "715 Mill Avenue",
          "employer" : "Baluba",
          "email" : "parkerhines@baluba.com",
          "city" : "Blackgum",
          "state" : "KY"
        }
      }
    ]
  }
}

```

能够看到相关度越高，得分也越高。

（7).Filter【结果过滤】

并不是所有的查询都需要产生分数，特别是哪些仅用于filtering过滤的文档。为了不计算分数，elasticsearch会自动检查场景并且优化查询的执行。

```
GET bank/_search
{
  "query": {
    "bool": {
      "must": [
        {
          "match": {
            "address": "mill"
          }
        }
      ],
      "filter": {
        "range": {
          "balance": {
            "gte": "10000",
            "lte": "20000"
          }
        }
      }
    }
  }
}

```

这里先是查询所有匹配address=mill的文档，然后再根据10000<=balance<=20000进行过滤查询结果

查询结果：

```json
{
  "took" : 2,
  "timed_out" : false,
  "_shards" : {
    "total" : 1,
    "successful" : 1,
    "skipped" : 0,
    "failed" : 0
  },
  "hits" : {
    "total" : {
      "value" : 1,
      "relation" : "eq"
    },
    "max_score" : 5.4032025,
    "hits" : [
      {
        "_index" : "bank",
        "_type" : "account",
        "_id" : "970",
        "_score" : 5.4032025,
        "_source" : {
          "account_number" : 970,
          "balance" : 19648,
          "firstname" : "Forbes",
          "lastname" : "Wallace",
          "age" : 28,
          "gender" : "M",
          "address" : "990 Mill Road",
          "employer" : "Pheast",
          "email" : "forbeswallace@pheast.com",
          "city" : "Lopezo",
          "state" : "AK"
        }
      }
    ]
  }
}

```



Each `must`, `should`, and `must_not` element in a Boolean query is referred to as a query clause. How well a document meets the criteria in each `must` or `should` clause contributes to the document’s *relevance score*. The higher the score, the better the document matches your search criteria. By default, Elasticsearch returns documents ranked by these relevance scores.

 在boolean查询中，`must`, `should` 和`must_not` 元素都被称为查询子句 。 文档是否符合每个“must”或“should”子句中的标准，决定了文档的“相关性得分”。  得分越高，文档越符合您的搜索条件。  默认情况下，Elasticsearch返回根据这些相关性得分排序的文档。 

The criteria in a `must_not` clause is treated as a *filter*. It affects whether or not the document is included in the results, but does not contribute to how documents are scored. You can also explicitly specify arbitrary filters to include or exclude documents based on structured data.

`“must_not”子句中的条件被视为“过滤器”。` 它影响文档是否包含在结果中，  但**不影响文档的评分方式**。  还可以显式地指定任意过滤器来包含或排除基于结构化数据的文档。 

**filter在使用过程中，并不会计算相关性得分_score：**

```json
GET bank/_search
{
  "query": {
    "bool": {
      "must": [
        {
          "match": {
            "address": "mill"
          }
        }
      ],
      "filter": {
        "range": {
          "balance": {
            "gte": "10000",
            "lte": "20000"
          }
        }
      }
    }
  }
}
//gte:>=  lte:<=
```

查询结果：

```json
{
  "took" : 1,
  "timed_out" : false,
  "_shards" : {
    "total" : 1,
    "successful" : 1,
    "skipped" : 0,
    "failed" : 0
  },
  "hits" : {
    "total" : {
      "value" : 213,
      "relation" : "eq"
    },
    "max_score" : 0.0,
    "hits" : [
      {
        "_index" : "bank",
        "_type" : "account",
        "_id" : "20",
        "_score" : 0.0,
        "_source" : {
          "account_number" : 20,
          "balance" : 16418,
          "firstname" : "Elinor",
          "lastname" : "Ratliff",
          "age" : 36,
          "gender" : "M",
          "address" : "282 Kings Place",
          "employer" : "Scentric",
          "email" : "elinorratliff@scentric.com",
          "city" : "Ribera",
          "state" : "WA"
        }
      },
      {
        "_index" : "bank",
        "_type" : "account",
        "_id" : "37",
        "_score" : 0.0,
        "_source" : {
          "account_number" : 37,
          "balance" : 18612,
          "firstname" : "Mcgee",
          "lastname" : "Mooney",
          "age" : 39,
          "gender" : "M",
          "address" : "826 Fillmore Place",
          "employer" : "Reversus",
          "email" : "mcgeemooney@reversus.com",
          "city" : "Tooleville",
          "state" : "OK"
        }
      },
      {
        "_index" : "bank",
        "_type" : "account",
        "_id" : "51",
        "_score" : 0.0,
        "_source" : {
          "account_number" : 51,
          "balance" : 14097,
          "firstname" : "Burton",
          "lastname" : "Meyers",
          "age" : 31,
          "gender" : "F",
          "address" : "334 River Street",
          "employer" : "Bezal",
          "email" : "burtonmeyers@bezal.com",
          "city" : "Jacksonburg",
          "state" : "MO"
        }
      },
      {
        "_index" : "bank",
        "_type" : "account",
        "_id" : "56",
        "_score" : 0.0,
        "_source" : {
          "account_number" : 56,
          "balance" : 14992,
          "firstname" : "Josie",
          "lastname" : "Nelson",
          "age" : 32,
          "gender" : "M",
          "address" : "857 Tabor Court",
          "employer" : "Emtrac",
          "email" : "josienelson@emtrac.com",
          "city" : "Sunnyside",
          "state" : "UT"
        }
      },
      {
        "_index" : "bank",
        "_type" : "account",
        "_id" : "121",
        "_score" : 0.0,
        "_source" : {
          "account_number" : 121,
          "balance" : 19594,
          "firstname" : "Acevedo",
          "lastname" : "Dorsey",
          "age" : 32,
          "gender" : "M",
          "address" : "479 Nova Court",
          "employer" : "Netropic",
          "email" : "acevedodorsey@netropic.com",
          "city" : "Islandia",
          "state" : "CT"
        }
      },
      {
        "_index" : "bank",
        "_type" : "account",
        "_id" : "176",
        "_score" : 0.0,
        "_source" : {
          "account_number" : 176,
          "balance" : 18607,
          "firstname" : "Kemp",
          "lastname" : "Walters",
          "age" : 28,
          "gender" : "F",
          "address" : "906 Howard Avenue",
          "employer" : "Eyewax",
          "email" : "kempwalters@eyewax.com",
          "city" : "Why",
          "state" : "KY"
        }
      },
      {
        "_index" : "bank",
        "_type" : "account",
        "_id" : "183",
        "_score" : 0.0,
        "_source" : {
          "account_number" : 183,
          "balance" : 14223,
          "firstname" : "Hudson",
          "lastname" : "English",
          "age" : 26,
          "gender" : "F",
          "address" : "823 Herkimer Place",
          "employer" : "Xinware",
          "email" : "hudsonenglish@xinware.com",
          "city" : "Robbins",
          "state" : "ND"
        }
      },
      {
        "_index" : "bank",
        "_type" : "account",
        "_id" : "222",
        "_score" : 0.0,
        "_source" : {
          "account_number" : 222,
          "balance" : 14764,
          "firstname" : "Rachelle",
          "lastname" : "Rice",
          "age" : 36,
          "gender" : "M",
          "address" : "333 Narrows Avenue",
          "employer" : "Enaut",
          "email" : "rachellerice@enaut.com",
          "city" : "Wright",
          "state" : "AZ"
        }
      },
      {
        "_index" : "bank",
        "_type" : "account",
        "_id" : "227",
        "_score" : 0.0,
        "_source" : {
          "account_number" : 227,
          "balance" : 19780,
          "firstname" : "Coleman",
          "lastname" : "Berg",
          "age" : 22,
          "gender" : "M",
          "address" : "776 Little Street",
          "employer" : "Exoteric",
          "email" : "colemanberg@exoteric.com",
          "city" : "Eagleville",
          "state" : "WV"
        }
      },
      {
        "_index" : "bank",
        "_type" : "account",
        "_id" : "272",
        "_score" : 0.0,
        "_source" : {
          "account_number" : 272,
          "balance" : 19253,
          "firstname" : "Lilly",
          "lastname" : "Morgan",
          "age" : 25,
          "gender" : "F",
          "address" : "689 Fleet Street",
          "employer" : "Biolive",
          "email" : "lillymorgan@biolive.com",
          "city" : "Sunbury",
          "state" : "OH"
        }
      }
    ]
  }
}

```

**能看到所有文档的 "_score" : 0.0。**

（8).term

和match一样。匹配某个属性的值。全文检索字段用match，其他**非text字段**匹配用term。

> Avoid using the `term` query for [`text`](https://www.elastic.co/guide/en/elasticsearch/reference/7.6/text.html) fields.
>
> 避免对文本字段使用“term”查询
>
> By default, Elasticsearch changes the values of `text` fields as part of [analysis](). This can make finding exact matches for `text` field values difficult.
>
> 默认情况下，Elasticsearch作为[analysis]()的一部分更改' text '字段的值。这使得为“text”字段值寻找精确匹配变得困难。 
>
> To search `text` field values, use the match.
>
> 要搜索“text”字段值，请使用匹配。
>
> https://www.elastic.co/guide/en/elasticsearch/reference/7.6/query-dsl-term-query.html 

使用term匹配查询

```json
GET bank/_search
{
  "query": {
    "term": {
      "age": "28"
    }
  }
}
```

如果是text则查不到：

```
GET bank/_search
{
  "query": {
    "term": {
      "gender" : "F"
    }
  }
}
```



```json
{
  "took" : 0,
  "timed_out" : false,
  "_shards" : {
    "total" : 1,
    "successful" : 1,
    "skipped" : 0,
    "failed" : 0
  },
  "hits" : {
    "total" : {
      "value" : 0,
      "relation" : "eq"
    },
    "max_score" : null,
    "hits" : [ ]
  }
}

```

一条也没有匹配到

而更换为match匹配时，能够匹配到32个文档

![image-20200502120921830](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20200502120921830.png)

也就是说，**全文检索字段用match，其他非text字段匹配用term**。

（9).Aggregation（执行聚合，数据分析）

聚合提供了从数据中分组和提取数据的能力。最简单的聚合方法大致等于SQL Group by和SQL聚合函数。在elasticsearch中，执行搜索返回this（命中结果），并且同时返回聚合结果，把以响应中的所有hits（命中结果）分隔开的能力。这是非常强大且有效的，你可以执行查询和多个聚合，并且在一次使用中得到各自的（任何一个的）返回结果，使用一次简洁和简化的API啦避免网络往返。



"size":0

size:0不显示搜索数据
aggs：执行聚合。聚合语法如下：

```
"aggs":{
    "aggs_name这次聚合的名字，方便展示在结果集中":{
        "AGG_TYPE聚合的类型(avg,term,terms)":{}
     }
}，
```



具体实例：

① 搜索address中包含mill的所有人的年龄分布以及平均年龄，但不显示这些人的详情

```
GET bank/_search
{
  "query": {
    "match": {
      "address": "Mill"
    }
  },
  "aggs": {
    "ageAgg": {
      "terms": {
        "field": "age",
        "size": 10			// 假设age有100中可能，只取出其中10个
      }
    },
    "ageAvg": {
      "avg": {
        "field": "age"
      }
    },
    "balanceAvg": {
      "avg": {
        "field": "balance"
      }
    }
  },
  "size": 0
}
//ageAgg:聚合名字  terms：聚合类型  "field": "age":按照age字段聚合  size:10：取出前十种age
//avg：平均值聚合类型
//不显示这些人的详情，只看聚合结果
```

查询结果：

```
{
  "took" : 2,
  "timed_out" : false,
  "_shards" : {
    "total" : 1,
    "successful" : 1,
    "skipped" : 0,
    "failed" : 0
  },
  "hits" : {
    "total" : {
      "value" : 4,
      "relation" : "eq"
    },
    "max_score" : null,
    "hits" : [ ]
  },
  "aggregations" : {
    "ageAgg" : {
      "doc_count_error_upper_bound" : 0,
      "sum_other_doc_count" : 0,
      "buckets" : [
        {
          "key" : 38,
          "doc_count" : 2
        },
        {
          "key" : 28,
          "doc_count" : 1
        },
        {
          "key" : 32,
          "doc_count" : 1
        }
      ]
    },
    "ageAvg" : {
      "value" : 34.0
    },
    "balanceAvg" : {
      "value" : 25208.0
    }
  }
}

```



② 按照年龄聚合，并且求这些年龄段的这些人的平均薪资

```
GET bank/_search
{
  "query": {
    "match_all": {}
  },
  "aggs": {
    "ageAgg": {
      "terms": {
        "field": "age",
        "size": 100
      },
      "aggs": {
        "ageAvg": {
          "avg": {
            "field": "balance"
          }
        }
      }
    }
  },
  "size": 0
}
```

输出结果：

```
{
  "took" : 49,
  "timed_out" : false,
  "_shards" : {
    "total" : 1,
    "successful" : 1,
    "skipped" : 0,
    "failed" : 0
  },
  "hits" : {
    "total" : {
      "value" : 1000,
      "relation" : "eq"
    },
    "max_score" : null,
    "hits" : [ ]
  },
  "aggregations" : {
    "ageAgg" : {
      "doc_count_error_upper_bound" : 0,
      "sum_other_doc_count" : 0,
      "buckets" : [
        {
          "key" : 31,
          "doc_count" : 61,
          "ageAvg" : {
            "value" : 28312.918032786885
          }
        },
        {
          "key" : 39,
          "doc_count" : 60,
          "ageAvg" : {
            "value" : 25269.583333333332
          }
        },
        {
          "key" : 26,
          "doc_count" : 59,
          "ageAvg" : {
            "value" : 23194.813559322032
          }
        },
        {
          "key" : 32,
          "doc_count" : 52,
          "ageAvg" : {
            "value" : 23951.346153846152
          }
        },
        {
          "key" : 35,
          "doc_count" : 52,
          "ageAvg" : {
            "value" : 22136.69230769231
          }
        },
        {
          "key" : 36,
          "doc_count" : 52,
          "ageAvg" : {
            "value" : 22174.71153846154
          }
        },
        {
          "key" : 22,
          "doc_count" : 51,
          "ageAvg" : {
            "value" : 24731.07843137255
          }
        },
        {
          "key" : 28,
          "doc_count" : 51,
          "ageAvg" : {
            "value" : 28273.882352941175
          }
        },
        {
          "key" : 33,
          "doc_count" : 50,
          "ageAvg" : {
            "value" : 25093.94
          }
        },
        {
          "key" : 34,
          "doc_count" : 49,
          "ageAvg" : {
            "value" : 26809.95918367347
          }
        },
        {
          "key" : 30,
          "doc_count" : 47,
          "ageAvg" : {
            "value" : 22841.106382978724
          }
        },
        {
          "key" : 21,
          "doc_count" : 46,
          "ageAvg" : {
            "value" : 26981.434782608696
          }
        },
        {
          "key" : 40,
          "doc_count" : 45,
          "ageAvg" : {
            "value" : 27183.17777777778
          }
        },
        {
          "key" : 20,
          "doc_count" : 44,
          "ageAvg" : {
            "value" : 27741.227272727272
          }
        },
        {
          "key" : 23,
          "doc_count" : 42,
          "ageAvg" : {
            "value" : 27314.214285714286
          }
        },
        {
          "key" : 24,
          "doc_count" : 42,
          "ageAvg" : {
            "value" : 28519.04761904762
          }
        },
        {
          "key" : 25,
          "doc_count" : 42,
          "ageAvg" : {
            "value" : 27445.214285714286
          }
        },
        {
          "key" : 37,
          "doc_count" : 42,
          "ageAvg" : {
            "value" : 27022.261904761905
          }
        },
        {
          "key" : 27,
          "doc_count" : 39,
          "ageAvg" : {
            "value" : 21471.871794871793
          }
        },
        {
          "key" : 38,
          "doc_count" : 39,
          "ageAvg" : {
            "value" : 26187.17948717949
          }
        },
        {
          "key" : 29,
          "doc_count" : 35,
          "ageAvg" : {
            "value" : 29483.14285714286
          }
        }
      ]
    }
  }
}
```



③ 查出所有年龄分布，并且这些年龄段中M的平均薪资和F的平均薪资以及这个年龄段的总体平均薪资

```
GET bank/_search
{
  "query": {
    "match_all": {}
  },
  "aggs": {
    "ageAgg": {
      "terms": {
        "field": "age",
        "size": 100
      },
      "aggs": {
        "genderAgg": {
          "terms": {
            "field": "gender.keyword"
          },
          "aggs": {
            "balanceAvg": {
              "avg": {
                "field": "balance"
              }
            }
          }
        },
        "ageBalanceAvg": {
          "avg": {
            "field": "balance"
          }
        }
      }
    }
  },
  "size": 0
}
//"field": "gender.keyword" gender是txt没法聚合 必须加.keyword精确替代
```

输出结果：

```
{
  "took" : 119,
  "timed_out" : false,
  "_shards" : {
    "total" : 1,
    "successful" : 1,
    "skipped" : 0,
    "failed" : 0
  },
  "hits" : {
    "total" : {
      "value" : 1000,
      "relation" : "eq"
    },
    "max_score" : null,
    "hits" : [ ]
  },
  "aggregations" : {
    "ageAgg" : {
      "doc_count_error_upper_bound" : 0,
      "sum_other_doc_count" : 0,
      "buckets" : [
        {
          "key" : 31,
          "doc_count" : 61,
          "genderAgg" : {
            "doc_count_error_upper_bound" : 0,
            "sum_other_doc_count" : 0,
            "buckets" : [
              {
                "key" : "M",
                "doc_count" : 35,
                "balanceAvg" : {
                  "value" : 29565.628571428573
                }
              },
              {
                "key" : "F",
                "doc_count" : 26,
                "balanceAvg" : {
                  "value" : 26626.576923076922
                }
              }
            ]
          },
          "ageBalanceAvg" : {
            "value" : 28312.918032786885
          }
        }
      ]
        .......//省略其他
    }
  }
}

```



###### 3）Mapping

对于mysql，建表的时候需要指定各个字段的类型，而es会在传入json的时候，默认确定对应的类型。

（1）字段类型

![image-20240310112852915](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240310112852915.png)

（2）映射

Mapping(映射)
Maping是用来定义一个文档（document），以及它所包含的属性（field）是如何存储和索引的。比如：使用maping来定义：

* 哪些字符串属性应该被看做全文本属性（full text fields）；

* 哪些属性包含数字，日期或地理位置；

* 文档中的所有属性是否都嫩被索引（all 配置）；

* 日期的格式；

* 自定义映射规则来执行动态添加属性；

* 查看mapping信息
  GET bank/_mapping

  

```
{
  "bank" : {
    "mappings" : {
      "properties" : {
        "account_number" : {
          "type" : "long"
        },
        "address" : {
          "type" : "text",
          "fields" : {
            "keyword" : {
              "type" : "keyword",
              "ignore_above" : 256
            }
          }
        },
        "age" : {
          "type" : "long"
        },
        "balance" : {
          "type" : "long"
        },
        "city" : {
          "type" : "text",
          "fields" : {
            "keyword" : {
              "type" : "keyword",
              "ignore_above" : 256
            }
          }
        },
        "email" : {
          "type" : "text",
          "fields" : {
            "keyword" : {
              "type" : "keyword",
              "ignore_above" : 256
            }
          }
        },
        "employer" : {
          "type" : "text",
          "fields" : {
            "keyword" : {
              "type" : "keyword",
              "ignore_above" : 256
            }
          }
        },
        "firstname" : {
          "type" : "text",
          "fields" : {
            "keyword" : {
              "type" : "keyword",
              "ignore_above" : 256
            }
          }
        },
        "gender" : {
          "type" : "text",
          "fields" : {
            "keyword" : {
              "type" : "keyword",
              "ignore_above" : 256
            }
          }
        },
        "lastname" : {
          "type" : "text",
          "fields" : {
            "keyword" : {
              "type" : "keyword",
              "ignore_above" : 256
            }
          }
        },
        "state" : {
          "type" : "text",
          "fields" : {
            "keyword" : {
              "type" : "keyword",
              "ignore_above" : 256
            }
          }
        }
      }
    }
  }
}
```

修改mapping信息

![image-20240310112944846](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240310112944846.png)



（3）新版本改变

ElasticSearch7-去掉type概念

1. 关系型数据库中两个数据表示是独立的，即使他们里面有相同名称的列也不影响使用，但ES中不是这样的。elasticsearch是基于Lucene开发的搜索引擎，而ES中不同type下名称相同的filed最终在Lucene中的处理方式是一样的。

   - 两个不同type下的两个user_name，在ES同一个索引下其实被认为是同一个filed，你必须在两个不同的type中定义相同的filed映射。否则，不同type中的相同字段名称就会在处理中出现冲突的情况，导致Lucene处理效率下降。
   - 去掉type就是为了提高ES处理数据的效率。

2. Elasticsearch 7.x URL中的type参数为可选。比如，索引一个文档不再要求提供文档类型。

3. Elasticsearch 8.x 不再支持URL中的type参数。

4. 解决：
   将索引从多类型迁移到单类型，每种类型文档一个独立索引

   将已存在的索引下的类型数据，全部迁移到指定位置即可。详见数据迁移

> **Elasticsearch 7.x**
>
> - Specifying types in requests is deprecated. For instance, indexing a document no longer requires a document `type`. The new index APIs are `PUT {index}/_doc/{id}` in case of explicit ids and `POST {index}/_doc` for auto-generated ids. Note that in 7.0, `_doc` is a permanent part of the path, and represents the endpoint name rather than the document type.
> - The `include_type_name` parameter in the index creation, index template, and mapping APIs will default to `false`. Setting the parameter at all will result in a deprecation warning.
> - The `_default_` mapping type is removed.
>
> **Elasticsearch 8.x**
>
> - Specifying types in requests is no longer supported.
> - The `include_type_name` parameter is removed.

创建映射

创建索引并指定属性的映射规则（**相当于新建表并制定字段和字段类型**）

```json
PUT /my_index
{
  "mappings": {
    "properties": {
      "age": {
        "type": "integer"
      },
      "email": {
        "type": "keyword"
      },
      "name": {
        "type": "text"
      }
    }
  }
}
```

 输出：

```json
{
  "acknowledged" : true,
  "shards_acknowledged" : true,
  "index" : "my_index"
}

```

查看映射

```json
GET /my_index
```

输出结果：

```json
//"index" : false 是否被索引即能被检索到，默认是true
{
  "my_index" : {
    "aliases" : { },
    "mappings" : {
      "properties" : {
        "age" : {
          "type" : "integer"
        },
        "email" : {
          "type" : "keyword"
        },
        "employee-id" : {
          "type" : "keyword",
          "index" : false
        },
        "name" : {
          "type" : "text"
        }
      }
    },
    "settings" : {
      "index" : {
        "creation_date" : "1588410780774",
        "number_of_shards" : "1",
        "number_of_replicas" : "1",
        "uuid" : "ua0lXhtkQCOmn7Kh3iUu0w",
        "version" : {
          "created" : "7060299"
        },
        "provided_name" : "my_index"
      }
    }
  }
}
```

添加新的字段映射

```json
PUT /my_index/_mapping
{
  "properties": {
    "employee-id": {
      "type": "keyword",
      "index": false
    }
  }
}
```

这里的 "index": false，表明新增的字段不能被检索，只是一个冗余字段。



更新映射

对于已经存在的字段映射，我们不能更新。更新必须创建新的索引，进行数据迁移。



数据迁移

先创建new_twitter的正确映射。然后使用如下方式进行数据迁移。

```json
POST reindex [固定写法]
{
  "source":{
      "index":"twitter"
   },
  "dest":{
      "index":"new_twitters"
   }
}
```



将旧索引的type下的数据进行迁移

```json
POST reindex [固定写法]
{
  "source":{
      "index":"twitter",
      "twitter":"twitter"
   },
  "dest":{
      "index":"new_twitters"
   }
}
```

更多详情见： https://www.elastic.co/guide/en/elasticsearch/reference/7.6/docs-reindex.html 





GET /bank/_search

```json
{
  "took" : 0,
  "timed_out" : false,
  "_shards" : {
    "total" : 1,
    "successful" : 1,
    "skipped" : 0,
    "failed" : 0
  },
  "hits" : {
    "total" : {
      "value" : 1000,
      "relation" : "eq"
    },
    "max_score" : 1.0,
    "hits" : [
      {
        "_index" : "bank",
        "_type" : "account",//类型为account
        "_id" : "1",
        "_score" : 1.0,
        "_source" : {
          "account_number" : 1,
          "balance" : 39225,
          "firstname" : "Amber",
          "lastname" : "Duke",
          "age" : 32,
          "gender" : "M",
          "address" : "880 Holmes Lane",
          "employer" : "Pyrami",
          "email" : "amberduke@pyrami.com",
          "city" : "Brogan",
          "state" : "IL"
        }
      },
      ...
```



```
GET /bank/_search
```

![image-20200502174825233](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20200502174825233.png)

想要将年龄修改为integer

```json
PUT /newbank
{
  "mappings": {
    "properties": {
      "account_number": {
        "type": "long"
      },
      "address": {
        "type": "text"
      },
      "age": {
        "type": "integer"
      },
      "balance": {
        "type": "long"
      },
      "city": {
        "type": "keyword"
      },
      "email": {
        "type": "keyword"
      },
      "employer": {
        "type": "keyword"
      },
      "firstname": {
        "type": "text"
      },
      "gender": {
        "type": "keyword"
      },
      "lastname": {
        "type": "text",
        "fields": {
          "keyword": {
            "type": "keyword",
            "ignore_above": 256
          }
        }
      },
      "state": {
        "type": "keyword"
      }
    }
  }
}
```

查看“newbank”的映射：

GET /newbank/_mapping

![image-20200502175901959](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20200502175901959.png)

能够看到age的映射类型被修改为了integer.



将bank中的数据迁移到newbank中

```json
POST _reindex
{
  "source": {
    "index": "bank",
    "type": "account"
  },
  "dest": {
    "index": "newbank"
  }
}
```

运行输出：

```json
#! Deprecation: [types removal] Specifying types in reindex requests is deprecated.
{
  "took" : 768,
  "timed_out" : false,
  "total" : 1000,
  "updated" : 0,
  "created" : 1000,
  "deleted" : 0,
  "batches" : 1,
  "version_conflicts" : 0,
  "noops" : 0,
  "retries" : {
    "bulk" : 0,
    "search" : 0
  },
  "throttled_millis" : 0,
  "requests_per_second" : -1.0,
  "throttled_until_millis" : 0,
  "failures" : [ ]
}
```



查看newbank中的数据

![image-20240310113043969](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240310113043969.png)





###### 4）分词

一个tokenizer（分词器）接收一个字符流，将之分割为独立的tokens（词元，通常是独立的单词），然后输出tokens流。

例如：whitespace tokenizer遇到空白字符时分割文本。它会将文本“Quick brown fox!”分割为[Quick,brown,fox!]。

该tokenizer（分词器）还负责记录各个terms(词条)的顺序或position位置（用于phrase短语和word proximity词近邻查询），以及term（词条）所代表的原始word（单词）的start（起始）和end（结束）的character offsets（字符串偏移量）（用于高亮显示搜索的内容）。

elasticsearch提供了很多内置的分词器，可以用来构建custom analyzers（自定义分词器

关于分词器： https://www.elastic.co/guide/en/elasticsearch/reference/7.6/analysis.html 



```
POST _analyze
{
  "analyzer": "standard",
  "text": "The 2 QUICK Brown-Foxes jumped over the lazy dog's bone."
}
```

执行结果：

```
{
  "tokens" : [
    {
      "token" : "the",
      "start_offset" : 0,
      "end_offset" : 3,
      "type" : "<ALPHANUM>",
      "position" : 0
    },
    {
      "token" : "2",
      "start_offset" : 4,
      "end_offset" : 5,
      "type" : "<NUM>",
      "position" : 1
    },
    {
      "token" : "quick",
      "start_offset" : 6,
      "end_offset" : 11,
      "type" : "<ALPHANUM>",
      "position" : 2
    },
    {
      "token" : "brown",
      "start_offset" : 12,
      "end_offset" : 17,
      "type" : "<ALPHANUM>",
      "position" : 3
    },
    {
      "token" : "foxes",
      "start_offset" : 18,
      "end_offset" : 23,
      "type" : "<ALPHANUM>",
      "position" : 4
    },
    {
      "token" : "jumped",
      "start_offset" : 24,
      "end_offset" : 30,
      "type" : "<ALPHANUM>",
      "position" : 5
    },
    {
      "token" : "over",
      "start_offset" : 31,
      "end_offset" : 35,
      "type" : "<ALPHANUM>",
      "position" : 6
    },
    {
      "token" : "the",
      "start_offset" : 36,
      "end_offset" : 39,
      "type" : "<ALPHANUM>",
      "position" : 7
    },
    {
      "token" : "lazy",
      "start_offset" : 40,
      "end_offset" : 44,
      "type" : "<ALPHANUM>",
      "position" : 8
    },
    {
      "token" : "dog's",
      "start_offset" : 45,
      "end_offset" : 50,
      "type" : "<ALPHANUM>",
      "position" : 9
    },
    {
      "token" : "bone",
      "start_offset" : 51,
      "end_offset" : 55,
      "type" : "<ALPHANUM>",
      "position" : 10
    }
  ]
}

```



（1）安装分词器

所有的语言分词，默认使用的都是“Standard Analyzer”，但是这些分词器针对于中文的分词，并不友好。为此需要安装中文的分词器。



注意：不能用默认elasticsearch-plugin install xxx.zip 进行自动安装
https://github.com/medcl/elasticsearch-analysis-ik/releases/download 对应es版本安装



在前面安装的elasticsearch时，我们已经将elasticsearch容器的“/usr/share/elasticsearch/plugins”目录，映射到宿主机的“ /mydata/elasticsearch/plugins”目录下，所以比较方便的做法就是下载“/elasticsearch-analysis-ik-7.6.2.zip”文件，然后解压到该文件夹下即可。安装完毕后，需要重启elasticsearch容器。

 

如果不嫌麻烦，还可以采用如下的方式。

① 查看elasticsearch版本号：

```
[root@hadoop-104 ~]# curl http://localhost:9200
{
  "name" : "0adeb7852e00",
  "cluster_name" : "elasticsearch",
  "cluster_uuid" : "9gglpP0HTfyOTRAaSe2rIg",
  "version" : {
    "number" : "7.6.2",      #版本号为7.6.2
    "build_flavor" : "default",
    "build_type" : "docker",
    "build_hash" : "ef48eb35cf30adf4db14086e8aabd07ef6fb113f",
    "build_date" : "2020-03-26T06:34:37.794943Z",
    "build_snapshot" : false,
    "lucene_version" : "8.4.0",
    "minimum_wire_compatibility_version" : "6.8.0",
    "minimum_index_compatibility_version" : "6.0.0-beta1"
  },
  "tagline" : "You Know, for Search"
}
[root@hadoop-104 ~]# 
```

② 进入es容器内部plugin目录

- docker exec -it 容器id /bin/bash

```
[root@hadoop-104 ~]# docker exec -it elasticsearch /bin/bash
[root@0adeb7852e00 elasticsearch]# 
```

因为我们之前挂载出来了，所以进入挂载的目录即可

```
[root@localhost vagrant]# cd /mydata/elasticsearch/plugins/
```

- 安装wget

```
[root@localhost plugins]# yum install wget
```

![image-20240310120244623](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240310120244623.png)

- wget  https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.6.2/elasticsearch-analysis-ik-7.6.2.zip

下载ik分词器

```
[root@0adeb7852e00 elasticsearch]# pwd
/usr/share/elasticsearch
#下载ik7.6.2
[root@0adeb7852e00 elasticsearch]# wget https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.6.2/elasticsearch-analysis-ik-7.6.2.zip
```

![image-20240310120700047](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240310120700047.png)

<img src="%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240310120646656.png" alt="image-20240310120646656" style="zoom:150%;" />

- 安装unzip解压工具

```
yum install -y unzip zip
```



- 通过unzip解压 下载的文件

```
[root@0adeb7852e00 elasticsearch]# unzip elasticsearch-analysis-ik-7.6.2.zip -d ink
Archive:  elasticsearch-analysis-ik-7.6.2.zip
   creating: ik/config/
  inflating: ik/config/main.dic      
  inflating: ik/config/quantifier.dic  
  inflating: ik/config/extra_single_word_full.dic  
  inflating: ik/config/IKAnalyzer.cfg.xml  
  inflating: ik/config/surname.dic   
  inflating: ik/config/suffix.dic    
  inflating: ik/config/stopword.dic  
  inflating: ik/config/extra_main.dic  
  inflating: ik/config/extra_stopword.dic  
  inflating: ik/config/preposition.dic  
  inflating: ik/config/extra_single_word_low_freq.dic  
  inflating: ik/config/extra_single_word.dic  
  inflating: ik/elasticsearch-analysis-ik-7.6.2.jar  
  inflating: ik/httpclient-4.5.2.jar  
  inflating: ik/httpcore-4.4.4.jar   
  inflating: ik/commons-logging-1.2.jar  
  inflating: ik/commons-codec-1.9.jar  
  inflating: ik/plugin-descriptor.properties  
  inflating: ik/plugin-security.policy  
[root@0adeb7852e00 elasticsearch]#
#移动到plugins目录下
[root@0adeb7852e00 elasticsearch]# mv ik plugins/
```

![image-20240310121156143](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240310121156143.png)

![image-20240310121206936](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240310121206936.png)

- 删除解压包

```
[root@0adeb7852e00 elasticsearch]# rm -rf elasticsearch-analysis-ik-7.6.2.zip 
```

![image-20240310121241096](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240310121241096.png)

- 检查该插件是否装上

进入容器内容

```
 docker exec -it elasticsearch /bin/bash
 cd bin
 elasticsearch-plugin list // 查看已经装好的插件
```

结果：

```
[root@7ff2251fe891 bin]# elasticsearch-plugin list
ink
```

- 重启es

```
[root@localhost plugins]# docker restart elasticsearch
elasticsearch
```



（2）测试分词器

使用默认

```
GET _analyze
{
   "text":"我是中国人"
}
```

结果：

```
{
  "tokens" : [
    {
      "token" : "我",
      "start_offset" : 0,
      "end_offset" : 1,
      "type" : "<IDEOGRAPHIC>",
      "position" : 0
    },
    {
      "token" : "是",
      "start_offset" : 1,
      "end_offset" : 2,
      "type" : "<IDEOGRAPHIC>",
      "position" : 1
    },
    {
      "token" : "中",
      "start_offset" : 2,
      "end_offset" : 3,
      "type" : "<IDEOGRAPHIC>",
      "position" : 2
    },
    {
      "token" : "国",
      "start_offset" : 3,
      "end_offset" : 4,
      "type" : "<IDEOGRAPHIC>",
      "position" : 3
    },
    {
      "token" : "人",
      "start_offset" : 4,
      "end_offset" : 5,
      "type" : "<IDEOGRAPHIC>",
      "position" : 4
    }
  ]
}

```



使用ik：

```
  GET _analyze
{
   "analyzer": "ik_smart", 
   "text":"我是中国人"
}
```

结果：

```
{
  "tokens" : [
    {
      "token" : "我",
      "start_offset" : 0,
      "end_offset" : 1,
      "type" : "CN_CHAR",
      "position" : 0
    },
    {
      "token" : "是",
      "start_offset" : 1,
      "end_offset" : 2,
      "type" : "CN_CHAR",
      "position" : 1
    },
    {
      "token" : "中国人",
      "start_offset" : 2,
      "end_offset" : 5,
      "type" : "CN_WORD",
      "position" : 2
    }
  ]
}

```





（3）自定义词库

- 需要安装nginx，可见后端20、安装nginx

ik会向对应的地址发送请求，从而获得对应的自定义词库内容，我们这里实现有两种：①

①自定义服务，然后取处理对应请求，然后返回自定义词库内容

②将自定义词库内容配置在nginx中



- 首先我们在nginx的配置文件的html下创建/es/fenci.txt

```
vi /mydata/nginx/html/es/fenci.txt
```

![image-20240310145716089](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240310145716089.png)



- 修改/usr/share/elasticsearch/plugins/ik/config中的IKAnalyzer.cfg.xml

直接对挂载出来的配置文件进行修改

```
vi /mydata/elasticsearch/plugins/ink/config/IKAnalyzer.cfg.xml
```

原：

```
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE properties SYSTEM "http://java.sun.com/dtd/properties.dtd">
<properties>
        <comment>IK Analyzer 扩展配置</comment>
        <!--用户可以在这里配置自己的扩展字典 -->
        <entry key="ext_dict"></entry>
         <!--用户可以在这里配置自己的扩展停止词字典-->
        <entry key="ext_stopwords"></entry>
        <!--用户可以在这里配置远程扩展字典 -->
        <!-- <entry key="remote_ext_dict">words_location</entry> -->
        <!--用户可以在这里配置远程扩展停止词字典-->
        <!-- <entry key="remote_ext_stopwords">words_location</entry> -->
</properties>
~                 
```

修改后：

```
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE properties SYSTEM "http://java.sun.com/dtd/properties.dtd">
<properties>
        <comment>IK Analyzer 扩展配置</comment>
        <!--用户可以在这里配置自己的扩展字典 -->
        <entry key="ext_dict"></entry>
         <!--用户可以在这里配置自己的扩展停止词字典-->
        <entry key="ext_stopwords"></entry>
        <!--用户可以在这里配置远程扩展字典 -->
        <entry key="remote_ext_dict">http://192.168.56.10/es/fenci.txt</entry>
        <!--用户可以在这里配置远程扩展停止词字典-->
        <!-- <entry key="remote_ext_stopwords">words_location</entry> -->
</properties>
```

- 重启elasticsearch

```
docker restart elasticsearch
```



- 测试

入参：

```
  GET _analyze
{
   "analyzer": "ik_smart", 
   "text":"我是无情哈拉少"
}
```

出参：

```
{
  "tokens" : [
    {
      "token" : "我",
      "start_offset" : 0,
      "end_offset" : 1,
      "type" : "CN_CHAR",
      "position" : 0
    },
    {
      "token" : "是",
      "start_offset" : 1,
      "end_offset" : 2,
      "type" : "CN_CHAR",
      "position" : 1
    },
    {
      "token" : "无情哈拉少",
      "start_offset" : 2,
      "end_offset" : 7,
      "type" : "CN_WORD",
      "position" : 2
    }
  ]
}

```



##### 8.elasticsearch-Rest-Client

es的客户端主要有一下两类：

① 9300: TCP

- spring-data-elasticsearch:transport-api.jar;

  * springboot版本不同，ransport-api.jar不同，不能适配es版本

  * 7.x已经不建议使用，8以后就要废弃

② 9200: HTTP

 * jestClient: 非官方，更新慢；
 * RestTemplate：模拟HTTP请求，ES很多操作需要自己封装，麻烦；
 * HttpClient：同上；

* Elasticsearch-Rest-Client：官方RestClient，封装了ES操作，API层次分明，上手简单；
  最终选择Elasticsearch-Rest-Client（elasticsearch-rest-high-level-client）；
   https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/java-rest-high.html 



##### 9.SpringBoot整合ElasticSearch

整合：

- 单独创建检索服务

![image-20240310152822905](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240310152822905.png)



- 导入依赖

这里的版本要和所按照的ELK版本匹配

```xml
<dependency>
    <groupId>org.elasticsearch.client</groupId>
    <artifactId>elasticsearch-rest-high-level-client</artifactId>
    <version>7.4.2</version>
</dependency>
```

在spring-boot-dependencies（父类）中所依赖的ELK版本位6.8.7，所以要进行修改	

```xml
 <properties>
    <elasticsearch.version>7.4.2</elasticsearch.version>
</properties>
```



- 编写配置类，注入高阶的客户端类

```java
@Configuration
public class TtsElasticSearchConfig {

    @Bean
    public RestHighLevelClient getEsRestClient(){
        RestHighLevelClient client = new RestHighLevelClient(
                RestClient.builder(new HttpHost("192.168.56.10", 9200, "http")));
        return client;
    }
}
```



- 加入到注册中心

略……





具体可见提交代码&es操作测试：feature: 集成es

详情可见官方文档

>  https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/java-rest-high-document-index.html 



① 测试保存

```java
// 测试存储数据到es
@Test
public void indexData() throws IOException {
    IndexRequest indexRequest = new IndexRequest ("users");

    User user = new User();
    user.setUserName("张三");
    user.setAge(20);
    user.setGender("男");
    String jsonString = JSON.toJSONString(user);
    //设置要保存的内容
    indexRequest.source(jsonString, XContentType.JSON);
    //执行创建索引和保存数据
    IndexResponse index = restHighLevelClient.index(indexRequest, TtsElasticSearchConfig.COMMON_OPTIONS);

    System.out.println(index);
}

@Data
class User{
    private String userName;

    private Integer age;

    private String gender;
}
```



测试获取

```
Get users/_search
```

测试前：

```
{
  "error" : {
    "root_cause" : [
      {
        "type" : "index_not_found_exception",
        "reason" : "no such index [users]",
        "resource.type" : "index_or_alias",
        "resource.id" : "users",
        "index_uuid" : "_na_",
        "index" : "users"
      }
    ],
    "type" : "index_not_found_exception",
    "reason" : "no such index [users]",
    "resource.type" : "index_or_alias",
    "resource.id" : "users",
    "index_uuid" : "_na_",
    "index" : "users"
  },
  "status" : 404
}

```

测试后：

```
{
  "took" : 14,
  "timed_out" : false,
  "_shards" : {
    "total" : 1,
    "successful" : 1,
    "skipped" : 0,
    "failed" : 0
  },
  "hits" : {
    "total" : {
      "value" : 1,
      "relation" : "eq"
    },
    "max_score" : 1.0,
    "hits" : [
      {
        "_index" : "users",
        "_type" : "_doc",
        "_id" : "1",
        "_score" : 1.0,
        "_source" : {
          "age" : 20,
          "gender" : "男",
          "userName" : "张三"
        }
      }
    ]
  }
}

```



② 搜索address中包含mill的所有人的年龄分布以及平均年龄，平均薪资

```
GET bank/_search
{
  "query": {
    "match": {
      "address": "Mill"
    }
  },
  "aggs": {
    "ageAgg": {
      "terms": {
        "field": "age",
        "size": 10
      }
    },
    "ageAvg": {
      "avg": {
        "field": "age"
      }
    },
    "balanceAvg": {
      "avg": {
        "field": "balance"
      }
    }
  }
}
```

java实现：

```java
/**
 * 复杂检索:在bank中搜索address中包含mill的所有人的年龄分布以及平均年龄，平均薪资
 * @throws IOException
 */
@Test
public void searchData() throws IOException {
    //1. 创建检索请求
    SearchRequest searchRequest = new SearchRequest();

    //1.1）指定索引
    searchRequest.indices("bank");
    //1.2）构造检索条件
    SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();
    sourceBuilder.query(QueryBuilders.matchQuery("address","Mill"));

    //1.2.1)按照年龄分布进行聚合
    TermsAggregationBuilder ageAgg=AggregationBuilders.terms("ageAgg").field("age").size(10);
    sourceBuilder.aggregation(ageAgg);

    //1.2.2)计算平均年龄
    AvgAggregationBuilder ageAvg = AggregationBuilders.avg("ageAvg").field("age");
    sourceBuilder.aggregation(ageAvg);
    //1.2.3)计算平均薪资
    AvgAggregationBuilder balanceAvg = AggregationBuilders.avg("balanceAvg").field("balance");
    sourceBuilder.aggregation(balanceAvg);

    System.out.println("检索条件："+sourceBuilder);
    searchRequest.source(sourceBuilder);
    //2. 执行检索
    SearchResponse searchResponse = client.search(searchRequest, RequestOptions.DEFAULT);
    System.out.println("检索结果："+searchResponse);

    //3. 将检索结果封装为Bean
    SearchHits hits = searchResponse.getHits();
    SearchHit[] searchHits = hits.getHits();
    for (SearchHit searchHit : searchHits) {
        String sourceAsString = searchHit.getSourceAsString();
        Account account = JSON.parseObject(sourceAsString, Account.class);
        System.out.println(account);

    }

    //4. 获取聚合信息
    Aggregations aggregations = searchResponse.getAggregations();

    Terms ageAgg1 = aggregations.get("ageAgg");

    for (Terms.Bucket bucket : ageAgg1.getBuckets()) {
        String keyAsString = bucket.getKeyAsString();
        System.out.println("年龄："+keyAsString+" ==> "+bucket.getDocCount());
    }
    Avg ageAvg1 = aggregations.get("ageAvg");
    System.out.println("平均年龄："+ageAvg1.getValue());

    Avg balanceAvg1 = aggregations.get("balanceAvg");
    System.out.println("平均薪资："+balanceAvg1.getValue());


}  
```



#### 7、商城业务-商品上架

##### 1. sku在es中存储模型分析

注意点：

- sku上架后，竟可能保证将重要的数据存放在es中，因为es是将数据保存在内存中的，资源比较昂贵。
- 最后采用空间换时间的方法，即存冗余字段，而不是为了减小冗余，而牺牲时间（具体看P128分析）
- 当搜索商品名时，查询的是 sku 的标题 sku_title，可能通过 sku 的标题、销量、价格区间检索

具体设计分析：

① 方案一：空间换时间（最终采用方式）

```json
{
    skuId:1
    spuId:11
    skyTitile:华为xx
    price:999
    saleCount:99
    attrs:[
        {尺寸:5存},
        {CPU:高通945},
        {分辨率:全高清}
	]
}
# 缺点：会产生冗余字段，对于相同类型的商品，attrs 属性字段会重复，空间占用大
# 好处：方便检索
```

② 方案二：时间换空间

```
sku索引
{
    skuId:1
    spuId:11
}
attr索引
{
    spuId:11
    attrs:[
        {尺寸:5寸},
        {CPU:高通945},
        {分辨率:全高清}
	]
}
# 缺点：选择公共属性attr时,会检索当前属性的所有商品分类，然后再查询当前商品分类的所有可能属性；
# 		 导致耗时长。
# 好处：空间利用率高
```





##### 2.关于nested数据类型场景

- Object 数据类型的数组会被扁平化处理为一个简单的键与值的列表，即对象的相同属性会放到同一个数组中，在检索时会出现错误。参考官网：[How arrays of objects are flattened](https://www.elastic.co/guide/en/elasticsearch/reference/current/nested.html#nested-arrays-flattening-objects)
- 对于 Object 类型的数组，要使用 nested 字段类型。参考官网：[Using nested fields for arrays of objects](https://www.elastic.co/guide/en/elasticsearch/reference/current/nested.html#nested-fields-array-objects)



原因图示：

![image-20240310194011739](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240310194011739.png)



##### 3.商品上架功能实现

es中，sku存储结构：

```
PUT product
{
  "mappings": {
    "properties": {
      "skuId": { "type": "long" },
      "spuId": { "type": "keyword" },
      "skuTitle": {
        "type": "text",
        "analyzer": "ik_smart"
      },
      "skuPrice": { "type": "keyword" },
      "skuImg": {
        "type": "keyword",
        "index": false,
        "doc_values": false
      },
      "saleCount":{ "type":"long" },
      "hasStock": { "type": "boolean" },
      "hotScore": { "type": "long"  },
      "brandId":  { "type": "long" },
      "catalogId": { "type": "long"  },
      "brandName": {
        "type": "keyword",
        "index": false,
        "doc_values": false
      },
      "brandImg":{
        "type": "keyword",
        "index": false,
        "doc_values": false
      },
      "catalogName": {
        "type": "keyword",
        "index": false,
        "doc_values": false
      },
      "attrs": {
        "type": "nested",
        "properties": {
          "attrId": {"type": "long"  },
          "attrName": {
            "type": "keyword",
            "index": false,
            "doc_values": false
          },
          "attrValue": { "type": "keyword" }
        }
      }
    }
  }
}
```

mapping结构字段说明：

```
"mappings": {
  "properties": {
    "skuId": { "type": "long" },
    "spuId": { "type": "keyword" }, # 精确检索，不分词
    "skuTitle": {
      "type": "text", # 全文检索
      "analyzer": "ik_smart" # ik中文分词器
    },
    "skuPrice": { "type": "keyword" },
    "skuImg": {
      "type": "keyword",
      "index": false, # false 不可被检索
      "doc_values": false # false 不可被聚合
    },
    "saleCount":{ "type":"long" }, # 商品销量
    "hasStock": { "type": "boolean" }, # 商品是否有库存
    "hotScore": { "type": "long"  }, # 商品热度评分
    "brandId":  { "type": "long" }, # 品牌id
    "catalogId": { "type": "long"  }, # 分类id
    "brandName": {	# 品牌名，只用来查看，不用来检索和聚合
      "type": "keyword",
      "index": false,
      "doc_values": false
    },
    "brandImg":{	# 品牌图片，只用来查看，不用来检索和聚合
      "type": "keyword",
      "index": false,
      "doc_values": false
    },
    "catalogName": {	# 分类名，只用来查看，不用来检索和聚合
      "type": "keyword",
      "index": false,
      "doc_values": false
    },
    "attrs": {	# 属性对象
      "type": "nested",	# 嵌入式，内部属性
      "properties": {
        "attrId": {"type": "long"  },
        "attrName": {	# 属性名
          "type": "keyword",
          "index": false,
          "doc_values": false
        },
        "attrValue": { "type": "keyword" }	# 属性值
      }
    }
  }
}
```



后端代码：

feature: 商品上架功能



#### 8、商品业务-首页

##### 1.整体架构：

动静分离：以适应高并发场景，以免图片也需要访问应用服务器的情况出现。

![image-20240311140759504](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240311140759504.png)

##### 2.整合thymeleaf渲染页面

在商品服务（tts-product）导入模板引擎依赖

```
<!-- 模板引擎 -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-thymeleaf</artifactId>
</dependency>
```



feature: 整合thymeleaf渲染首页



##### 3.整合热部署工具（dev-tools）并渲染一级分类数据

feature: 渲染一级分类数据



##### 4.渲染二级三级分类数据

feature: 渲染二级三级分类数据







#### 9、商城业务-nginx

##### 1.搭建域名访问环境一（反向代理配置）

- 通过switchhost设定host域名映射：

![image-20240311160859357](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240311160859357.png)

![image-20240311160933974](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240311160933974.png)



通过域名进行访问es，进行测试，可以发现访问成功

![image-20240311161021509](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240311161021509.png)

我们如果直接访问域名，访问的使nginx

![image-20240311161249358](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240311161249358.png)



- 让nginx帮我们进行反向代理，所有来自原tts.com的请求，都转到商品服务

首先对nginx配置文件进行一个说明：

![image-20240311161539737](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240311161539737.png)



看一下docker中挂载出来的nginx的配置cat /mydata/nginx/conf/nginx.conf

```
user  nginx;
worker_processes  1;

error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;

events {
    worker_connections  1024;
}

http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';

    access_log  /var/log/nginx/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    keepalive_timeout  65;

    #gzip  on;

    include /etc/nginx/conf.d/*.conf;
}
```

可以看到，在 http 块中最后有 include /etc/nginx/conf.d/*.conf; 这句配置说明在 conf.d 目录下所有 .conf 后缀的文件内容都会作为 nginx 配置文件 http 块中的配置。这是为了防止主配置文件太复杂，也可以对不同的配置进行分类。

下面我们参考 conf.d 目录下的配置，来配置 tts 的 server 块配置

首先获取本机的ip地址

![image-20240311163152776](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240311163152776.png)



复制一份conf.d 目录下的nginx配置，作为我们当前项目tts的nginx的 http 块中的配置

```
cd /mydata/nginx/conf/conf.d
cp default.conf tts.conf
```

在tts.conf中配置代理

```
server {
    listen       80;
    server_name  tts.com;

    #charset koi8-r;
    #access_log  /var/log/nginx/log/host.access.log  main;

    location / {
        proxy_pass http://192.168.56.1:12000;
    }

    #error_page  404              /404.html;

    # redirect server error pages to the static page /50x.html
    #
    error_page   500 502 503 504  /50x.html;
    location = /50x.html {
        root   /usr/share/nginx/html;
    }

    # proxy the PHP scripts to Apache listening on 127.0.0.1:80
    #
    #location ~ \.php$ {
    #    proxy_pass   http://127.0.0.1;
    #}

    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000
    #
    #location ~ \.php$ {
    #    root           html;
    #    fastcgi_pass   127.0.0.1:9000;
    #    fastcgi_index  index.php;
    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;
    #    include        fastcgi_params;
    #}

    # deny access to .htaccess files, if Apache's document root
    # concurs with nginx's one
    #
    #location ~ /\.ht {
    #    deny  all;
    #}
}


```



重启nginx后，再次进行访问

```
docker restart nginx
```

![image-20240311164046167](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240311164046167.png)



此时，nginx对访问80端口，并且域名host是tts.com的请求进行监听，并将其转发到本地的12000端口。



图示：

![image-20240311164150344](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240311164150344.png)





##### 2.反向代理：nginx 代理网关由网关进行转发

- 在nginx主配置文件中增加上游服务器

```
vim /mydata/nginx/conf/nginx.conf
```

在server块中，配置上游服务器为网关地址

```

user  nginx;
worker_processes  1;

error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;


events {
    worker_connections  1024;
}


http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';

    access_log  /var/log/nginx/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    keepalive_timeout  65;

    #gzip  on;

    upstream tts{
        server 192.168.56.1:88;
    }

    include /etc/nginx/conf.d/*.conf;
}

```



- 在http块中配置转发到网关

配置代理的地址为上面配置的上游服务器名称，即地址为上游服务器的地址

注意：nginx代理给网关的时候，会丢失请求的host信息，因此我们可以通过`proxy_set_header Host $host;`加上

```
server {
    listen       80;
    server_name  tts.com;

    #charset koi8-r;
    #access_log  /var/log/nginx/log/host.access.log  main;

    location / {
    	proxy_set_header Host $host;
        proxy_pass http://tts;
    }

    #error_page  404              /404.html;

    # redirect server error pages to the static page /50x.html
    #
    error_page   500 502 503 504  /50x.html;
    location = /50x.html {
        root   /usr/share/nginx/html;
    }

    # proxy the PHP scripts to Apache listening on 127.0.0.1:80
    #
    #location ~ \.php$ {
    #    proxy_pass   http://127.0.0.1;
    #}

    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000
    #
    #location ~ \.php$ {
    #    root           html;
    #    fastcgi_pass   127.0.0.1:9000;
    #    fastcgi_index  index.php;
    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;
    #    include        fastcgi_params;
    #}

    # deny access to .htaccess files, if Apache's document root
    # concurs with nginx's one
    #
    #location ~ /\.ht {
    #    deny  all;
    #}
}


```



- 在后端网关服务中，添加对于指定域名tts.com的处理

```xml
- id: tts_host_route
  uri: lb://tts-product
  predicates:
    - Host=**.tts.com, tts.com
```



- 重启nginx

- 访问页面

![image-20240311172500565](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240311172500565.png)



- 补充说明：

①域名映射效果

经过上面的配置

```
请求接口：tts.com
请求页面：tts.com

nginx直接代理给网关，网关判断：
如果/api/** 转交给对应的服务
如果是满足域名，站交给对应的服务
```



②上述流程分析

当前通过域名的方式，请求 tts的时候

根据host的配置，会将请求域名为tts.com发送到虚拟机ip

此时虚拟机上的nginx监听的使80端口，然后经过nginx中的配置转发到后端项目的网关

根据网关的配置再进行对应服务的转发操作。



#### 10、压力测试

##### 1.压力测试结果说明

- 中间件使用越多，性能（吞吐量、响应时间）损失越大，大多抖损失在网络交互上。
- 业务上
  - DB（Mysql的优化，添加索引）
  - 模版的渲染速度（如为thymeleaf添加缓存）
  - 静态资源的的位置（放在应用服务器上的效率不如直接放在nginx上）

##### 2.优化策略一、nginx动静分离

- 在 nginx 的目录 /mydata/nginx/html/下创建static目录，用来存放我们的静态资源

```
mkdir  /mydata/nginx/html/static
```

- 将之前的所有静态文件都放到目录/mydata/nginx/html/static中
- 给模板中所有静态资源的请求路径前都加上 /static

![image-20240311194605090](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240311194605090.png)

- 配置nginx文件	/mydata/nginx/conf/conf.d/tts.conf

将访问路径中有static的都转到html下

```
# /static/ 下所有的请求都转给 nginx
 location /static/ {
          root /usr/share/nginx/html;
    }
```

直接指定挂载的目录好像不行

```
/mydata/nginx/html
```



- 删除原先应用程序上存放的静态资源

feature: nginx动静分离



##### 3.优化策略二、优化查询三级分类数据

方式：将多次查询数据库变为一次，先将数据全部查询出来，再进行处理。

feature: 优化查询三级分类数据





#### 11、缓存-缓存使用

##### 1.为什么使用缓存

为了系统性能的提升，我们一般都会将部分数据放入缓存中，加速访问。而 db 承担数据落盘工作。

**哪些数据适合放入缓存？**

- 即时性、数据一致性要求不高的

- 访问量大且更新频率不高的数据（读多，写少）

举例：电商类应用，商品分类，商品列表等适合缓存并加一个失效时间(根据数据更新频率来定)，后台如果发布一个商品，买家需要 5 分钟才能看到新的商品一般还是可以接受的。

![image-20240311204953434](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240311204953434.png)

伪代码：

```
data = cache.load(id);//从缓存加载数据
If(data == null){
    data = db.load(id);//从数据库加载数据
    cache.put(id,data);//保存到 cache 中
}
return data;
```

**注意：**在开发中，凡是放入缓存中的数据我们都应该指定过期时间，使其可以在系统即使没有主动更新数据也能自动触发数据加载进缓存的流程。避免业务崩溃导致的数据永久不一致问题。



**本地缓存的弊端：**

- 不适用分布式系统，由于负载均衡，导致某一个服务内容的缓存更新了，但其他缓存没有更新
- 分布式系统重，负载均衡后，修改某一项目的缓存后，需要对各个服务中本地的缓存都进行修改
- 哪以集中控制统一管理



##### 2.整合redis

引入redis依赖

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
```

配置redis

```yml
spring:
    redis:
        host: 192.168.56.10
        port: 6379	
```



测试操作：

```java
@Autowired
StringRedisTemplate stringRedisTemplate;
@Test
public void testStringRedisTemplate(){
    ValueOperations<String, String> ops = stringRedisTemplate.opsForValue();
    ops.set("hello","world_"+ UUID.randomUUID().toString());
    String hello = ops.get("hello");
    System.out.println(hello);
}
```



##### 3.改造三级分类业务

feature: 使用redis改造三级分类业务

```java
@Override
public Map<String, List<Catalog2Vo>> getCatalogJson() {
    // 从缓存中取
    Object catalogJSON = redisTemplate.opsForValue().get(CacheConstant.prefix + CacheConstant.catalogJSON);
    if(ObjectUtil.isNull(catalogJSON)){
        // 缓存中没有，查询数据库
        Map<String, List<Catalog2Vo>> catalogJsonDB = getCatalogJsonDB();
        // 查询到的数据加入到缓存中
        String catalogJsonString = JSON.toJSONString(catalogJsonDB);
        redisTemplate.opsForValue().set(CacheConstant.prefix + CacheConstant.catalogJSON, catalogJsonString);
        return catalogJsonDB;
    }

    // 缓存中有
    Map<String, List<Catalog2Vo>> result = JSON.parseObject(catalogJSON.toString(), new TypeReference<Map<String, List<Catalog2Vo>>>() {
    });
    return result;
}

 @Override
public Map<String, List<Catalog2Vo>> getCatalogJsonDB() {

    // 先预处理所有的分类数据
    List<CategoryEntity> categoryEntityList = baseMapper.selectList(null);


    // 查询所有一级分类
    List<CategoryEntity> level1Categories = getParentCid(categoryEntityList, 0L);

    // 封装数据
    Map<String, List<Catalog2Vo>> parentCid = level1Categories.stream().collect(Collectors.toMap(
            k -> k.getCatId().toString(), v -> {
                // 每一个分类的一级分类，插到这个一级分类的二级分类
                List<CategoryEntity> categoryEntities = getParentCid(categoryEntityList, v.getCatId());

                // 封装结果
                List<Catalog2Vo> catalog2Vos = null;
                if (CollectionUtils.isNotEmpty(categoryEntities)) {
                    catalog2Vos = categoryEntities.stream().map(l2 -> {
                        Catalog2Vo catalog2Vo = new Catalog2Vo(v.getCatId().toString(), null,
                                l2.getCatId().toString(), l2.getName());
                        // 找到二级分类的三季分类封装成vo
                        List<CategoryEntity> level3Catelog = getParentCid(categoryEntityList, l2.getCatId());

                        if (CollectionUtils.isNotEmpty(level3Catelog)) {
                            List<Catalog2Vo.Category3Vo> collect = level3Catelog.stream().map(l3 -> {
                                Catalog2Vo.Category3Vo category3Vo = new Catalog2Vo.Category3Vo(l2.getCatId().toString(),
                                        l3.getCatId().toString(), l3.getName());
                                return category3Vo;
                            }).collect(Collectors.toList());
                            catalog2Vo.setCatalog3List(collect);
                        }
                        return catalog2Vo;
                    }).collect(Collectors.toList());
                }
                return catalog2Vos;
            }
    ));
    return parentCid;
}
```



##### 4.堆外内存溢出异常

这里可能会产生堆外内存溢出异常：OutOfDirectMemoryError。

下面进行分析：

- SpringBoot 2.0 以后默认使用 lettuce 作为操作 redis 的客户端，它使用 netty 进行网络通信；
- lettuce 的 bug 导致 netty 堆外内存溢出；
- netty 如果没有指定堆外内存，默认使用 -Xmx 参数指定的内存； 
- 可以通过 -Dio.netty.maxDirectMemory 进行设置；



解决方案：不能只使用 -Xmx 参数 去调大堆外内存，这样只会延缓异常出现的时间。

关于lettuce、jedis都是操作redis的底层客户端，spring再次封装redisTemplate;

- 升级 lettuce 客户端，或使用 jedis 客户端

```xml
<!-- redis -->
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-data-redis</artifactId>
  <exclusions>
    <exclusion>
      <groupId>io.lettuce</groupId>
      <artifactId>lettuce-core</artifactId>
    </exclusion>
  </exclusions>
</dependency>
<dependency>
  <groupId>redis.clients</groupId>
  <artifactId>jedis</artifactId>
</dependency>
```



fixbug: 解决堆外内存溢出异常



##### 5.高并发下缓存失效问题

- 缓存穿透

缓存穿透是指 查询一个一定不存在的数据，由于缓存是不命中，将去查询数据库，但是数据库也无此记录，我们没有将这次查询的 null 写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。

在流量大时，可能 DB 就挂掉了，要是有人利用不存在的 key 频繁攻击我们的应用，这就是漏洞。

解决方法：缓存空结果、并且设置短的过期时间。

- 缓存雪崩

缓存雪崩是指在我们设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到 DB，DB 瞬时压力过重雪崩。

解决方法：原有的失效时间基础上增加一个随机值，比如 1-5 分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。

- 缓存击穿

对于一些设置了过期时间的 key，如果这些 key 可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。

这个时候，需要考虑一个问题：如果这个 key 在大量请求同时进来前正好失效，那么所有对这个 key 的数据查询都落到 db，我们称为缓存击穿。

解决方法：加锁。大量并发只让一个人去查，其他人等待，查到之后释放锁，其他人获取到锁，先查缓存，就会有数据，不用去查数据库。

##### 6.分布式锁

本地所在分布式的情况下，不适用，本地锁只能锁住当前服务、当前进程。

本地锁只能锁住当前服务的进程，每一个单独的服务都会有一个进程读取数据库，不能达到只读取依次数据库的效果，所以需要分布式锁。

![image.png](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/1618324213008-86933bcb-1e7e-4666-a421-7d43242deb60.webp)



通过redisTemplate实现分布式锁：

删除锁要通过lua脚本，实现业务执行完毕后，删除锁的原子性。

如果存在非原子性操作，中间可能会因为并发性的各种偶然，操作加锁解锁出现问题。

![image-20240312110514845](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240312110514845.png)

redis 中有一个 SETNX 命令，该命令会向 redis 中保存一条数据，如果不存在则保存成功，存在则返回失败。

我们约定保存成功即为加锁成功，之后加锁成功的线程才能执行真正的业务操作

具体的代码改造：

```java
/**
* 从数据库查询并封装数据::分布式锁
*
* @return
*/
public Map<String, List<Catalogs2Vo>> getCatalogJsonFromDbWithRedisLock() {

    //1、占分布式锁。去redis占坑 设置过期时间必须和加锁是同步的，保证原子性（避免死锁）
    String uuid = UUID.randomUUID().toString();
    Boolean lock = redisTemplate.opsForValue().setIfAbsent("lock", uuid, 300, TimeUnit.SECONDS);
    if (lock) {
        System.out.println("获取分布式锁成功...");
        Map<String, List<Catalogs2Vo>> dataFromDb = null;
        try {
            //加锁成功...执行业务
            dataFromDb = getCatalogJsonFromDB();
        } finally {
            // lua 脚本解锁
            String script = "if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end";
            // 删除锁
            redisTemplate.execute(new DefaultRedisScript<>(script, Long.class), Collections.singletonList("lock"), uuid);
        }
        //先去redis查询下保证当前的锁是自己的
        //获取值对比，对比成功删除=原子性 lua脚本解锁
        // String lockValue = stringRedisTemplate.opsForValue().get("lock");
        // if (uuid.equals(lockValue)) {
        //     //删除我自己的锁
        //     stringRedisTemplate.delete("lock");
        // }
        return dataFromDb;
    } else {
        System.out.println("获取分布式锁失败...等待重试...");
        //加锁失败...重试机制
        //休眠一百毫秒
        try {
            TimeUnit.MILLISECONDS.sleep(100);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return getCatalogJsonFromDbWithRedisLock();     //自旋的方式
    }
}
```



##### 7.Redisson作为分布式锁

（1）官方文档：

https://github.com/redisson/redisson/wiki

Redisson中的每一个锁操作都是lua脚本，都可以保证原子性，适用于分布式。



（2）引入Redisson依赖

```xml
 <dependency>
   <groupId>org.redisson</groupId>
   <artifactId>redisson</artifactId>
   <version>3.11.1</version>
</dependency>
```



（3）配置redisson的相关配置

```java
/**
 * @author banana
 * @create 2024-03-12 11:19
 */
@Configuration
public class MyRedissonConfig {

    /**
     * 所有对 Redisson 的使用都是通过 RedissonClient对象
     *
     * @return
     * @throws IOException
     */
    @Bean(destroyMethod = "shutdown")   // 指定销毁方法
    public RedissonClient redisson() throws IOException {
        // 1、创建配置
        Config config = new Config();
        // Redis url should start with redis:// or rediss://
        // 使用单结点模式
        config.useSingleServer().setAddress("redis://192.168.56.10:6379");

        // 2、根据 Config 创建出 RedissonClient 实例
        return Redisson.create(config);
    }
}

```

通过单元测试，可以发现已经能够成功获取RedissonClient





（4）使用

①Redisson中的锁是java.util的实现，因此和使用java.util的本地锁的操作是一样的，只不过Redisson提供的实现类能够应对分布式的场景。

```java
// 1. 获取一把锁，只要保证锁的名字一样，就是同一把锁
Rlock lock = redisson.getLock("my-lock");

// 2. 加锁, 阻塞式等待（里面会有一个while循环去不断抢占锁）
/*
特点：
（1）默认加锁的时间都是30s
（2）锁的自动续期，如果业务超长，运行期间自动给锁续上新的30s,不用担心业务时间长，锁自动过期被删掉（看门狗机制，方式死锁）
（3）加锁的业务只要运行完成，就不会给当前锁续期，即是不手动解锁，锁默认在30s以后自动删除
*/
lock.lock();
try {
	System.out.println("加锁成功，执行业务...");
    // 睡眠
    Thread.sleep(3000);
} catch (Exception e) {
} finally {
	// 3. 解锁 假设解锁代码没有运行，Redisson 会出现死锁吗？（不会,加锁时会自动加时间，会过期）
    lock.unlock();
}
```



②手动自动设置锁的时间

这里设置10s自动解锁

```java
lock.lock(10, TimeUnit.SECONDS)
```

但是，自动解锁的时间一定要大于业务的执行时间，因为其不会涉及到锁的自动续期

如果A抢占到了该锁，但是A的业务时长是30s,同时B也抢占该锁，那么B会在10s时，A抢占的锁过期后，抢占到该锁，并且A在业务执行后，通过lock.unlock解锁的时候，发现此时不是自己的锁（B的锁），并且会报错

根据源码总结：

1.如果们传递了锁的超时时间，就发送给redis执行脚本，进行占锁，默认超时就是我们指定的时间。

2.如果我们没有指定超时时间，就使用30 * 1000 【locakWatchdogTimeout看门狗的默认时间】

只要占锁成功，就会启动一个定时任务【重新给锁设置时间，新的过期时间就是看门狗的默认时间】

重新设置锁的时间为internallockLeaseTime[看门狗时间]	/ 3， 即10s

3.一般我们手动指定时间，省掉续期的操作，然后手动去进行解锁。



③ 尝试加锁

和lock.Lock不同，其不是阻塞等待

而是可以设定一个事件去尝试加锁，如果超过了这个指定的时间，就不再去尝试抢占该锁

```
lock.tryLock(100, 10, TimeUnit.SECONDS)
```



④公平锁

如果有一百个线程来请求锁，按照先手顺序进行抢占获取。

```
redisson.getFairLock("anyLock")
```



⑤读写锁

保证一定能读到最新数据，修改期间，写锁是一个排他锁（互斥锁、独享锁），读锁是一个共享锁，写锁没有释放，就必须等待。

情况分析：

- 读 + 读

相当于无锁，并发度，只会在redis中记录这所有当前的读锁，他们都会同时加锁成功。

- 写 + 读

等待写锁释放

- 写 + 写

阻塞方法

- 读 + 写

有读锁，写锁也需要等待。

因此，只要有些的存在，都需要等待。

具体示例：

写（通过redis模拟读写）：

```java
@GetMapping("/write")
@ResponseBody
public String writeValue(){
    RReadWriteLock lock = redisson.getReadWriteLock("rw-lock");
	String s = "";
    RLock rLock = lock.writeLock();
    try{
        // 写数据，加写锁
        rLock.lock();
        s = UUID.randomUUID().toString();
        Thread.sleep(30000)
        redisTemplate.opsForValue().set("writeValue", s);
    } catch (InterruptedException ex){
        e.printStackTrace();
    }finally{
        // 释放写锁
        rLock.unlock();
    }
    return s;
}
```

读：

```java
@GetMapping("/read")
@ResponseBody
public String readValue(){
    RReadWriteLock lock = redisson.getReadWriteLock("rw-lock");
	String s = "";
    // 加读锁
    RLock rLock = lock.readLock();
    rLock.lock();
    try{
        s = redisTemplate.opsForValue().get("writeValue");
    } catch (InterruptedException ex){
        e.printStackTrace();
    }finally{
        rLock.unlock();
    }
    return s;
}
```



⑥信号量

场景：三个车位，停车

具体实例：

需要在redis中放一个key为park，value是一个数量的数据（如数量是3，则表示最多可以停3辆车）

停：

```java
public String park() throws InterruptedException{
    // 获取一个信号，获取一个值，占一个车位
	RSemaphore park = redisson.getSemaphore("park");
    
    // 也可以尝试获取，然后去执行其他逻辑
    // park.tryAcquire()
    
    return "park";
}
```

开走：

```java
public String go() throws InterruptedException{
	RSemaphore park = redisson.getSemaphore("park");
    park.release();	// 释放车位
    return "go";
}
```

总结：

通过信号量也可以用来作为分布式的限流



⑦闭锁（CountDownLatch）

场景：五个班级，全部走完人，关门

具体代码示例：

放假：

```java
@GetMapping("/lockDoor")
@ResponseBody
public String lockDoor(){
	RCountDownLatch door = redisson.getCountDownLatch("door");
    door.trySetCiybt(5);	// 设置5个班级
    door.await();	// 等待闭锁都完成
    return "放假了"
}
```

走人：

```java
@GetMapping("/gogogo/{id}")
@ResponseBody
public String gogogo(@PathVariable("id") Long id){
	RCountDownLatch door = redisson.getCountDownLatch("door");
    door.countDown();	//  计数减一
    
    return id + "班的人都走了……"
}
```



##### 8.通过redission改造获取三级分类的方法

（1）缓存数据的一致性

保证每次读的时候，都可以读到最新的数据（缓存里的数据如何和数据库的数据保持一致），即缓存数据的一致性。

① 双写模式

![image-20240312140943430](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240312140943430.png)

②失效模式

![image-20240312140955702](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240312140955702.png)



（2）改进方式

① 分布式读写锁

分布式读写锁。读数据等待写数据整个操作完成

②中间件cannal

![image-20240312141102811](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240312141102811.png)



（3）解决方案

![image-20240312141328153](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240312141328153.png)





（4）改造结果

```
    /**
     * 缓存里的数据如何和数据库的数据保持一致？？
     * 缓存数据一致性
     * 1)、双写模式
     * 2)、失效模式
     *
     * @return
     */
    public Map<String, List<Catalogs2Vo>> getCatalogJsonFromDbWithRedissonLock() {

        //1、占分布式锁。去redis占坑
        //（锁的粒度，越细越快:具体缓存的是某个数据，11号商品） product-11-lock
        //RLock catalogJsonLock = redissonClient.getLock("catalogJson-lock");
        //创建读锁
        RReadWriteLock readWriteLock = redissonClient.getReadWriteLock("catalogJson-lock");

        RLock rLock = readWriteLock.readLock();

        Map<String, List<Catalogs2Vo>> dataFromDb = null;
        try {
            rLock.lock();
            //加锁成功...执行业务
            dataFromDb = getCatalogJsonFromDB();
        } finally {
            rLock.unlock();
        }
        return dataFromDb;
    }
```



#### 12、缓存 - SpringCache

##### 1.简介

![image-20240312142348844](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240312142348844.png)

##### 2.整合SpringCache

（1）引入依赖：

- springCache依赖

```
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-cache</artifactId>
</dependency>
```

- redis依赖

如果想通过redis进行缓存，还需要引入redis的依赖



（2）配置：

- 自动配置

在CacheAutoConfiguration中的CacheConfigurationImportSelector方法中，会遍历各个选择器

其中会导入RedisCacheConfiguration（redis的缓存配置）

在redisCacheConfiguration中自动配置好了缓存管理器RedisCacheManager

```java
@Bean
RedisCacheManager cacheManager(CacheProperties cacheProperties, CacheManagerCustomizers cacheManagerCustomizers,
                               ObjectProvider<org.springframework.data.redis.cache.RedisCacheConfiguration> redisCacheConfiguration,
                               ObjectProvider<RedisCacheManagerBuilderCustomizer> redisCacheManagerBuilderCustomizers,
                               RedisConnectionFactory redisConnectionFactory, ResourceLoader resourceLoader) {
    RedisCacheManagerBuilder builder = RedisCacheManager.builder(redisConnectionFactory).cacheDefaults(
        determineConfiguration(cacheProperties, redisCacheConfiguration, resourceLoader.getClassLoader()));
    List<String> cacheNames = cacheProperties.getCacheNames();
    if (!cacheNames.isEmpty()) {
        builder.initialCacheNames(new LinkedHashSet<>(cacheNames));
    }
    redisCacheManagerBuilderCustomizers.orderedStream().forEach((customizer) -> customizer.customize(builder));
    return cacheManagerCustomizers.customize(builder.build());
}
```



- 手动配置

在配置文件中声明，需要使用redis作为缓存

```yml
spring:
	catch:
		type: redis
```



（3）开启缓存功能

```
@EnableCaching
```



##### 3.测试使用缓存

（1）相关注解

- @Cacheable: 触发将数据保存到缓存的操作
- @CacheEvict: 触发将数据从缓存删除的操作
- @CachePut: 不影响方法执行更新缓存
- @Caching： 组合以上多个操作
- @CacheConfig: 在类级别共享缓存的相同配置





（2）使用示例：

```java
@Cacheable({"category"})
public Data getSome(){
	// ……
}
```



上述操作的默认行为：

- 如果缓存中有，getSome方法不会被调用
- key默认自动生成，缓存的key名字：SimpleKey[] ，自动生成的key值
- 缓存的valuee值，默认使用jdk序列化机制，将序列化后的数据存到redis
- 默认的ttl时间为-1（即没有限制时间）



（3）自定义使用示例

自定义操作：

- 指定生成的缓存的key，key属性指定，可以接受一个sqEl表达式，详情见官方文档

```java
@Cacheable(value = {"category"}, key = "#root.method.nae")
public Data getSome(){
	// ……
}
```



- 指定缓存的数据的存活时间

在配置文件中进行配置

```yml
spring.cache.redis.time-to-live=16000 (单位：毫秒)
```



- 将数据value保存为json格式

在CacheAutoConfiguration中的CacheConfigurationImportSelector方法中，会遍历各个选择器，其中会导入org.springframework.boot.autoconfigure.cache.RedisCacheConfiguration（redis的缓存配置）

在redis的缓存配置中，通过cacheManager方法，又帮我们配置了RedisCacheManager缓存管理器，其会传入一个org.springframework.data.redis.cache.RedisCacheConfiguration,在其中指定了一些序列化的机制等信息。

如果没有org.springframework.data.redis.cache.RedisCacheConfiguration这个bean实例

那么在调用如下方法的时候

```
private org.springframework.data.redis.cache.RedisCacheConfiguration determineConfiguration(
			CacheProperties cacheProperties,
			ObjectProvider<org.springframework.data.redis.cache.RedisCacheConfiguration> redisCacheConfiguration,
			ClassLoader classLoader) {
		return redisCacheConfiguration.getIfAvailable(() -> createConfiguration(cacheProperties, classLoader));
	}
```

会通过createConfiguration方法去创建一个默认的org.springframework.data.redis.cache.RedisCacheConfiguration

![image-20240312153221455](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240312153221455.png)





因此我们自己去创建一个配置对象org.springframework.data.redis.cache.RedisCacheConfiguration，去指定其中的序列化等相关的配置

```java
package com.yjy.tts.product.config;

import com.alibaba.fastjson.support.spring.GenericFastJsonRedisSerializer;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.cache.CacheProperties;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.cache.RedisCacheConfiguration;
import org.springframework.data.redis.serializer.RedisSerializationContext;
import org.springframework.data.redis.serializer.StringRedisSerializer;

/**
 * @author banana
 * @create 2024-03-12 15:38
 */
// 开启缓存
@EnableCaching
@Configuration
@EnableConfigurationProperties(CacheProperties.class)
public class MyCacheConfig {

    //  通过在下面的@Bean中以方法的方式注入也可以
    @Autowired
    private CacheProperties cacheProperties;

    @Bean
    RedisCacheConfiguration redisCacheConfiguration(){
        // 现获取默认的redis缓存配置，在默认的基础上进行扩展
        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig();

        // key的序列化
        config = config.serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(new StringRedisSerializer()));
        // value的序列化
        config = config.serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(new GenericFastJsonRedisSerializer()));
        
        // 配置文件中的配置的引入
        CacheProperties.Redis redisProperties = cacheProperties.getRedis();
        if (redisProperties.getTimeToLive() != null) {
            config = config.entryTtl(redisProperties.getTimeToLive());
        }
        if (redisProperties.getKeyPrefix() != null) {
            config = config.prefixKeysWith(redisProperties.getKeyPrefix());
        }
        if (!redisProperties.isCacheNullValues()) {
            config = config.disableCachingNullValues();
        }
        if (!redisProperties.isUseKeyPrefix()) {
            config = config.disableKeyPrefix();
        }

        return config;
    }

}

```



一些相关的配置

```yml
spring:
  cache:
    # 指定缓存类型为redis
    type: redis
    redis:
      # 超时时间，毫秒为单位
      time-to-live: 3600000
      # 使用key的前缀
      use-key-prefix: true
      #是否缓存空值，防止缓存穿透
      cache-null-values: true
      # 自定义前缀
      # key-prefix: cache_
```



测试：

获取一级分类

```java
 @Override
    @Cacheable(value = {"category"},key = "#root.method.name")
    public List<CategoryEntity> getLevel1Categorys() {
        List<CategoryEntity> categoryEntities = baseMapper.selectList(Wrappers.<CategoryEntity>lambdaQuery()
                .eq(CategoryEntity::getParentCid, 0L));
        return categoryEntities;
    }
```

![image-20240312155822906](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240312155822906.png)



##### 5.一些总结

Spring-Cache的不足：

1）读模式

- 缓存穿透：查询一个null数据。解决方案：缓存空数据（通过springCache注解：ache-null-values=ture）
- 缓存击穿：大量并发进来同时查询一个正好过期的数据。解决方案：加锁 ? 默认是无加锁的;使用sync = true来解决击穿问题（只在cacheable注解中有，涉及查询操作的时候，其本质是一个本地锁，而不是分布式锁）
- 缓存雪崩：大量的key同时过期。解决：加随机时间（可能会有最后过期时间都还是一样的可能性）。加上过期时间（针对大项目）

2）写模式（缓存与数据库一致）

* 读写加锁。
 * 引入Canal,感知到MySQL的更新去更新Redis
 * 读多写多，直接去数据库查询就行



总结：
 * 常规数据（读多写少，即时性，一致性要求不高的数据，完全可以使用Spring-Cache）：写模式(只要缓存的数据有过期时间就足够了)
 * 特殊数据：特殊设计



原理：
 * CacheManager(RedisCacheManager)->Cache(RedisCache)->Cache负责缓存的读写



##### 6.获取三级分类集合SpringCache的改造

原：

```java
package com.yjy.tts.product.service.impl;

import cn.hutool.core.util.ObjectUtil;
import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.TypeReference;
import com.baomidou.mybatisplus.core.toolkit.CollectionUtils;
import com.baomidou.mybatisplus.core.toolkit.ObjectUtils;
import com.baomidou.mybatisplus.core.toolkit.Wrappers;
import com.yjy.tts.product.model.vo.Catalog2Vo;
import com.yjy.tts.product.service.CategoryBrandRelationService;
import org.apache.commons.lang3.StringUtils;
import org.redisson.Redisson;
import org.redisson.api.RLock;
import org.redisson.api.RReadWriteLock;
import org.redisson.api.RedissonClient;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.cache.CacheProperties;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.baomidou.mybatisplus.core.metadata.IPage;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.yjy.common.utils.PageUtils;
import com.yjy.common.utils.Query;

import com.yjy.tts.product.mapper.CategoryMapper;
import com.yjy.tts.product.entity.CategoryEntity;
import com.yjy.tts.product.service.CategoryService;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.bind.annotation.ExceptionHandler;
import com.yjy.tts.product.constant.CacheConstant;


@Service("categoryService")
public class CategoryServiceImpl extends ServiceImpl<CategoryMapper, CategoryEntity> implements CategoryService {

    @Autowired
    private CategoryBrandRelationService categoryBrandRelationService;

    @Autowired
    private RedisTemplate redisTemplate;

    @Autowired
    private RedissonClient redissonClient;

    @Override
    public List<CategoryEntity> listWithTree() {
        //1. 获取所有的商品的分类信息
        List<CategoryEntity> allCategory = baseMapper.selectList(null);

        //2. 递归构造商品分类的树形结构
        List<CategoryEntity> level1Category = allCategory.stream()
                // 过滤出所有父级商品分类信息（parentCid == 0）
                .filter(r -> r.getParentCid().equals(0L))
                // 设置当前商品分类的子分类
                .map(category -> {
                    category.setChildren(getCategoryChildrens(category, allCategory));
                    return category;
                })
                //根据商品分类的category字段进行排序
                .sorted((category1, category2) -> {
                    return (ObjectUtils.isNull(category1.getSort()) ? 0 : category1.getSort()) -
                            (ObjectUtils.isNull(category2.getSort()) ? 0 : category2.getSort());
                })
                // 转化为列表
                .collect(Collectors.toList());
        return level1Category;
    }

    @Override
    public void removeCategoryByIds(List<Long> catIds) {
        //todo 1、检查当前删除的菜单，是否被别的地方应用

        //逻辑批量删除
        baseMapper.deleteBatchIds(catIds);
    }

    @Override
    public Long[] findCatelogPath(Long catelogId) {

        List<Long> paths = new ArrayList<>();

        // 递归查询是否还有父结点
        List<Long> parentPath = findParentPath(catelogId, paths);

        return (Long[]) parentPath.toArray(new Long[parentPath.size()]);

    }

    /**
     * 级联更新所有关联的数据
     *
     * @CacheEvict:失效模式
     * @CachePut:双写模式，需要有返回值
     * 1、同时进行多种缓存操作：@Caching
     * 2、指定删除某个分区下的所有数据 @CacheEvict(value = "category",allEntries = true)
     * 3、存储同一类型的数据，都可以指定为同一分区
     * @param category
     */
    // @Caching(evict = {
    //         @CacheEvict(value = "category",key = "'getLevel1Categorys'"),
    //         @CacheEvict(value = "category",key = "'getCatalogJson'")
    // })
    @CacheEvict(value = "category", allEntries = true)       //删除某个分区下的所有数据 保证数据一致性
    @Override
    @Transactional(rollbackFor = Exception.class)
    public void updateDetail(CategoryEntity category) {
        // 更新原表数据
        this.updateById(category);

        // 保证冗余字段的数据一致
        if(StringUtils.isNotBlank(category.getName())){
            // todo 同步更新其他关联表中的数据
            // 品牌和分类关系表
            categoryBrandRelationService.updateCategoryNameById(category.getCatId(), category.getName());
        }
    }


    /**
     * 缓存里的数据如何和数据库的数据保持一致？？
     * 缓存数据一致性
     * 1)、双写模式
     * 2)、失效模式
     *
     * @return
     */
    public Map<String, List<Catalog2Vo>> getCatalogJsonFromDbWithRedissonLock(){
        //1、占分布式锁。去redis占坑
        //（锁的粒度，越细越快:具体缓存的是某个数据，11号商品） product-11-lock
        //RLock catalogJsonLock = redissonClient.getLock("catalogJson-lock");
        //创建读锁
        RReadWriteLock readWriteLock = redissonClient.getReadWriteLock("catalogJson-lock");

        RLock rLock = readWriteLock.readLock();

        Map<String, List<Catalog2Vo>> dataFromDb = null;
        try {
            rLock.lock();
            //加锁成功...执行业务
            dataFromDb = getCatalogJsonDB();
        } finally {
            rLock.unlock();
        }
        return dataFromDb;
    }

    @Override
    public Map<String, List<Catalog2Vo>> getCatalogJson() {
        // 从缓存中取
        Object catalogJSON = redisTemplate.opsForValue().get(CacheConstant.prefix + CacheConstant.catalogJSON);
        if(ObjectUtil.isNull(catalogJSON)){
            // 缓存中没有，查询数据库
            Map<String, List<Catalog2Vo>> catalogJsonDB = getCatalogJsonDB();
            // 查询到的数据加入到缓存中
            String catalogJsonString = JSON.toJSONString(catalogJsonDB);
            redisTemplate.opsForValue().set(CacheConstant.prefix + CacheConstant.catalogJSON, catalogJsonString);
            return catalogJsonDB;
        }

        // 缓存中有
        Map<String, List<Catalog2Vo>> result = JSON.parseObject(catalogJSON.toString(), new TypeReference<Map<String, List<Catalog2Vo>>>() {
        });
        return result;
    }

    @Override
    @Cacheable(value = "category",key = "#root.methodName")
    public Map<String, List<Catalog2Vo>> getCatalogJsonDB() {

        // 先预处理所有的分类数据
        List<CategoryEntity> categoryEntityList = baseMapper.selectList(null);


        // 查询所有一级分类
        List<CategoryEntity> level1Categories = getParentCid(categoryEntityList, 0L);

        // 封装数据
        Map<String, List<Catalog2Vo>> parentCid = level1Categories.stream().collect(Collectors.toMap(
                k -> k.getCatId().toString(), v -> {
                    // 每一个分类的一级分类，插到这个一级分类的二级分类
                    List<CategoryEntity> categoryEntities = getParentCid(categoryEntityList, v.getCatId());

                    // 封装结果
                    List<Catalog2Vo> catalog2Vos = null;
                    if (CollectionUtils.isNotEmpty(categoryEntities)) {
                        catalog2Vos = categoryEntities.stream().map(l2 -> {
                            Catalog2Vo catalog2Vo = new Catalog2Vo(v.getCatId().toString(), null,
                                    l2.getCatId().toString(), l2.getName());
                            // 找到二级分类的三季分类封装成vo
                            List<CategoryEntity> level3Catelog = getParentCid(categoryEntityList, l2.getCatId());

                            if (CollectionUtils.isNotEmpty(level3Catelog)) {
                                List<Catalog2Vo.Category3Vo> collect = level3Catelog.stream().map(l3 -> {
                                    Catalog2Vo.Category3Vo category3Vo = new Catalog2Vo.Category3Vo(l2.getCatId().toString(),
                                            l3.getCatId().toString(), l3.getName());
                                    return category3Vo;
                                }).collect(Collectors.toList());
                                catalog2Vo.setCatalog3List(collect);
                            }
                            return catalog2Vo;
                        }).collect(Collectors.toList());
                    }
                    return catalog2Vos;
                }
        ));
        return parentCid;
    }

    @Override
    @Cacheable(value = {"category"}, key = "#root.method.name", sync = true)
    public List<CategoryEntity> getLevel1Categorys() {
        List<CategoryEntity> categoryEntities = baseMapper.selectList(Wrappers.<CategoryEntity>lambdaQuery()
                .eq(CategoryEntity::getParentCid, 0L));
        return categoryEntities;
    }

    private List<CategoryEntity> getParentCid(List<CategoryEntity> selectList, Long parentCid) {
        return selectList.stream().filter(item -> item.getParentCid().equals(parentCid)).collect(Collectors.toList());
    }

    // 递归查询父路径
    private List<Long> findParentPath(Long catelogId, List<Long> paths) {

        //根据当前分类id查询信息
        CategoryEntity byId = this.getById(catelogId);

        //如果当前不是父分类，继续向上查询
        if (byId.getParentCid() != 0) {
            findParentPath(byId.getParentCid(), paths);
        }
        paths.add(catelogId);

        return paths;
    }

    /**
     * 递归获取当前商品分类的子分类信息
     * @param root 当前商品分类信息
     * @param all 所有的商品分类信息
     * @return 当前商品分类的子分类信息
     */
    private List<CategoryEntity> getCategoryChildrens(CategoryEntity root, List<CategoryEntity> all){
        //获取以root为父级的所有商品分类信息
        List<CategoryEntity> childrenCategory = all.stream()
                // 过滤出所有以root为父级商品的分类信息
                .filter(category -> category.getParentCid().equals(root.getCatId()))
                // 设置当前商品分类的子分类
                .map(category -> {
                    category.setChildren(getCategoryChildrens(category, all));
                    return category;
                })
                //根据商品分类的category字段进行排序
                .sorted((category1, category2) -> {
                    return (ObjectUtils.isNull(category1.getSort()) ? 0 : category1.getSort()) -
                            (ObjectUtils.isNull(category2.getSort()) ? 0 : category2.getSort());
                })
                // 转化为列表
                .collect(Collectors.toList());

        return childrenCategory;
    }


}
```



feature: 获取三级分类集合SpringCache的改造



#### 13、商城业务-检索服务

##### 1.搭建页面环境

feature: 搭建检索页面环境

- 配置域名映射

![image-20240312174419475](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240312174419475.png)

- 网关过滤器

```yml
# 指定搜索页面域名的处理
- id: tts_search_route
  uri: lb://tts-search
  predicates:
    - Host=search.tts.com
```

- nginx配置

将所有的域名映射都转到网管

```
server {
    listen       80;
    server_name  *.tts.com tts.com;

    #charset koi8-r;
    #access_log  /var/log/nginx/log/host.access.log  main;

    location /static/ {
          root /usr/share/nginx/html;
    }

    location / {
        proxy_set_header Host $host;
        proxy_pass http://tts;
    }

    #error_page  404              /404.html;

    # redirect server error pages to the static page /50x.html
    #
    error_page   500 502 503 504  /50x.html;
    location = /50x.html {
        root   /usr/share/nginx/html;
    }

    # proxy the PHP scripts to Apache listening on 127.0.0.1:80
    #
    #location ~ \.php$ {
    #    proxy_pass   http://127.0.0.1;
    #}

    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000
    #
    #location ~ \.php$ {
    #    root           html;
    #    fastcgi_pass   127.0.0.1:9000;
    #    fastcgi_index  index.php;
    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;
    #    include        fastcgi_params;
    #}

    # deny access to .htaccess files, if Apache's document root
    # concurs with nginx's one
    #
    #location ~ /\.ht {
    #    deny  all;
    #}
}


```

- 重启docker

```
docker restart nginx
```

- 测试

![image-20240312175455056](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240312175455056.png)

##### 2.调整页面跳转

feature: 调整页面跳转



##### 3.检索查询参数抽取

feature: 检索查询参数抽取



##### 4.检索返回结果抽取

feature: 检索返回结果抽取



##### 5.检索DSL测试

```json
# ========================== 一些tts的操作！======================

# 删除tts_product结构
DELETE tts_product

# 创建tts_product结构
PUT tts_product
{
  "mappings": {
    "properties": {
      "skuId": { "type": "long" },
      "spuId": { "type": "keyword" },
      "skuTitle": {
        "type": "text",
        "analyzer": "ik_smart"
      },
      "skuPrice": { "type": "keyword" },
      "skuImg": {
        "type": "keyword",
        "index": false,
        "doc_values": false
      },
      "saleCount":{ "type":"long" },
      "hasStock": { "type": "boolean" },
      "hotScore": { "type": "long"  },
      "brandId":  { "type": "long" },
      "catalogId": { "type": "long"  },
      "brandName": {
        "type": "keyword",
        "index": false,
        "doc_values": false
      },
      "brandImg":{
        "type": "keyword",
        "index": false,
        "doc_values": false
      },
      "catalogName": {
        "type": "keyword",
        "index": false,
        "doc_values": false
      },
      "attrs": {
        "type": "nested",
        "properties": {
          "attrId": {"type": "long"  },
          "attrName": {
            "type": "keyword",
            "index": false,
            "doc_values": false
          },
          "attrValue": { "type": "keyword" }
        }
      }
    }
  }
}

# 新映射结构
PUT /tts_product
{
  "mappings": {
    "properties": {
      "skuId": {
        "type": "long"
      },
      "spuId": {
        "type": "long"
      },
      "skuTitle": {
        "type": "text",
        "analyzer": "ik_smart"
      },
      "skuPrice": {
        "type": "keyword"
      },
      "skuImg": {
        "type": "keyword"
      },
      "saleCount": {
        "type": "long"
      },
      "hosStock": {
        "type": "boolean"
      },
      "hotScore": {
        "type": "long"
      },
      "brandId": {
        "type": "long"
      },
      "catalogId": {
        "type": "long"
      },
      "brandName": {
        "type": "keyword"
      },
      "brandImg": {
        "type": "keyword"
      },
      "catalogName": {
        "type": "keyword"
      },
      "attrs": {
        "type": "nested",
        "properties": {
          "attrId": {
            "type": "long"
          },
          "attrName": {
            "type": "keyword"
          },
          "attrValue": {
            "type": "keyword"
          }
        }
      }
    }
  }
}



# 查看结构
GET tts_product/_mapping

# 查询所有的商品信息
GET tts_product/_search



# 查询条件组装
# 模糊匹配、过滤（按照属性、分类、品牌、价格区间、库存），排序，分页，高亮
GET tts_product/_search
{
  "query": {
    "bool": {
      "must": [
        {
          "match": {
            "skuTitle": "大黄鱼"
          }
        }
      ],
      "filter": [
        {
          "term": {
            "catalogId": "1435"
          }
        },
        {
          "terms": {
            "brandId": [
              "1",
              "24"
            ]
          }
        },
        {
          "nested": {
            "path": "attrs",
            "query": {
              "bool": {
                "must": [
                  {
                    "term": {
                      "attrs.attrId": {
                        "value": "15"
                      }
                    }
                  },
                  {
                    "terms": {
                      "attrs.attrValue": [
                        "15cm",
                        "20cm"
                      ]
                    }
                  }
                ]
              }
            }
          }
        },
        {
          "term": {
            "hasStock": {
              "value": "false"
            }
          }
        },
        {
          "range": {
            "skuPrice": {
              "gte": 10,
              "lte": 20
            }
          }
        }
      ]
    }
  },
  "sort": [
    {
      "skuPrice": {
        "order": "desc"
      }
    }
  ],
  "from": 0,
  "size": 20,
  "highlight": {
    "fields": {"skuTitle": {}},
    "pre_tags": "<b style='color:red'",
    "post_tags": "</b>"
  }
}


# 聚合条件组装
# 如果是嵌入式的，查询都要使用嵌入式的方式
GET tts_product/_search
{
  "query": {
    "match_all": {}
  },
  "aggs": {
    "brand_agg": {
      "terms": {
        "field": "brandId",
        "size": 10
      },
      "aggs": {
        "brand_name_agg": {
          "terms": {
            "field": "brandName",
            "size": 10
          }
        },
        "brand_img_agg": {
          "terms": {
            "field": "brandImg",
            "size": 10
          }
        }
      }
    },
    "attr_agg": {
      "nested": {
        "path": "attrs"
      },
      "aggs": {
        "attr_id": {
          "terms": {
            "field": "attrs.attrId",
            "size": 10
          },
          "aggs": {
            "attr_name_age": {
              "terms": {
                "field": "attrs.attrName",
                "size": 10
              }
            },
            "attr_value_age": {
              "terms": {
                "field": "attrs.attrValue",
                "size": 10
              }
            }
          }
        }
      }
    },
    "catalog_agg":{
      "terms": {
        "field": "catalogId",
        "size": 10
      },
      "aggs": {
        "catalog_name_agg": {
          "terms": {
            "field": "catalogName",
            "size": 10
          }
        }
      }
    }
  }
}


# 一个完整的就是 查询条件组装 +  聚合条件组装
get tts_product
{
  "query": {
    "bool": {
      "must": [ {"match": {  "skuTitle": "华为" }} ], # 检索出华为
      "filter": [ # 过滤
        { "term": { "catalogId": "225" } },
        { "terms": {"brandId": [ "2"] } }, 
        { "term": { "hasStock": "false"} },
        {
          "range": {
            "skuPrice": { # 价格1K~7K
              "gte": 1000,
              "lte": 7000
            }
          }
        },
        {
          "nested": {
            "path": "attrs", # 聚合名字
            "query": {
              "bool": {
                "must": [
                  {
                    "term": { "attrs.attrId": { "value": "6"} }
                  }
                ]
              }
            }
          }
        }
      ]
    }
  },
  "sort": [ {"skuPrice": {"order": "desc" } } ],
  "from": 0,
  "size": 5,
  "highlight": {  
    "fields": {"skuTitle": {}}, # 高亮的字段
    "pre_tags": "<b style='color:red'>",  # 前缀
    "post_tags": "</b>"
  },
  "aggs": { # 查完后聚合
    "brandAgg": {
      "terms": {
        "field": "brandId",
        "size": 10
      },
      "aggs": { # 子聚合
        "brandNameAgg": {  # 每个商品id的品牌
          "terms": {
            "field": "brandName",
            "size": 10
          }
        },
      
        "brandImgAgg": {
          "terms": {
            "field": "brandImg",
            "size": 10
          }
        }
        
      }
    },
    "catalogAgg":{
      "terms": {
        "field": "catalogId",
        "size": 10
      },
      "aggs": {
        "catalogNameAgg": {
          "terms": {
            "field": "catalogName",
            "size": 10
          }
        }
      }
    },
    "attrs":{
      "nested": {"path": "attrs" },
      "aggs": {
        "attrIdAgg": {
          "terms": {
            "field": "attrs.attrId",
            "size": 10
          },
          "aggs": {
            "attrNameAgg": {
              "terms": {
                "field": "attrs.attrName",
                "size": 10
              }
            }
          }
        }
      }
    }
  }
}

```



##### 6.检索DSL的初步实现

feature: 检索DSL的初步实现



##### 7.页面基本数据渲染

feature: 页面基本数据渲染



##### 8.页面分页数据渲染

feature: 页面分页数据渲染

##### 9.页面价格区间&bug修复

feature:页面价格区间&bug修复



##### 10.面包屑

feature:面包屑



#### 14、商城业务-异步

略



#### 15、商城业务-商品详情

##### 1.环境初始化

feature: 商品详情环境初始化

- 配置详情页域名映射

![image-20240314100039677](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240314100039677.png)

- 修改nginx配置

因为之前配的是`*.tts.com`，因此可以不用管，都会转发到网关中

- 配置网关

```yml
# 指定首页域名的处理
- id: tts_host_route
  uri: lb://tts-product
  predicates:
    - Host=tts.com,item.tts.com
```

- 静态资源位置的修改

默认的静态资源都是访问static目录下的，因此将item.html的静态资源的路径进行修改（这里目前没有采用动静分离）

- 访问页面的编写

控制层：

```java
package com.yjy.tts.product.web;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;

/**
 * @author banana
 * @create 2024-03-14 10:08
 */
@Controller
public class ItemController {

    /**
     * 展示当前sku详情
     * @param skuId sku的id
     * @return
     */
    @GetMapping("/{skuId}.html")
    public String skuItem(@PathVariable("skuId")Long skuId){
        System.out.println("当前查询的skuId:" + skuId);

        return "item";
    }
}

```



##### 2.模型抽取

feature: 商品详情模型抽取



##### 3.商品详情完成&商品详情异步编排

feature: 商品详情完成

feature: 商品详情异步编排





#### 16、商品业务-认证服务

##### 1.环境初始化

feature: 环境初始化

- 新增模块

![image-20240314184239890](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240314184239890.png)

![image-20240314184334948](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240314184334948.png)

- 认证服务域名配置

![image-20240314185544230](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240314185544230.png)

- 配置网关

```
# 指定认证域名的处理
- id: tts_auth_route
  uri: lb://tts-auth
  predicates:
    - Host=auth.tts.com
```

- 图片等静态资源相关内容

……



##### 2.验证码倒计时& 映射配置

feature： 验证码倒计时&映射配置



##### 3.整合短信验证码

feature： 短信验证码功能

进入阿里云，点击云市场

![image-20240314210313453](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240314210313453.png)

去找对应的短信验证码，然后根据对应的文档进行编写，注意验证码具体发送要写在后端服务器，不能在前端服务器暴露给别人，并且在后端要做好防刷等措施！



由于验证码是收费的，这里就采用模拟的方式，在控制台打印。



##### 4.前后端认证

feature： 注册信息验证



##### 5.用户注册&md5加密

feature: 用户注册&md5加密



##### 6.用户账号密码登录

feature: 用户账号密码登录



##### 7.OAuth2.0

（1）介绍：

- OAuth： ： OAuth（开放授权）是一个开放标准，允许用户授权第三方网站访问他们存储在另外的服务提供者上的信息，而不需要将用户名和密码提供给第三方网站或分享他们数据的所有内容。

- OAuth2.0 ：对于用户相关的 OpenAPI（例如获取用户信息，动态同步，照片，日志，分享等），为了保护用户数据的安全和隐私，第三方网站访问用户数据前都需要显式的向用户征求授权。



（2）第三方授权流程图：

![image.png](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/1619865588369-2678e26b-0552-4d74-a43d-625123830f17.webp)





（3）weibo登录测试（略）

进入微博的开放平台：https://open.weibo.com/

选择微连接的网站接入

![image-20240315141514667](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240315141514667.png)

![image-20240315141546904](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240315141546904.png)

![image-20240315141856987](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240315141856987.png)



![image-20240315142507196](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240315142507196.png)



##### 8.分布式session

（1）session原理：

![image-20240315155633049](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240315155633049.png)

（2）分布式下 Session 存在的不共享、不同步问题：

![image-20240315155647875](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240315155647875.png)



（3）Session共享问题解决

Session 复制：

![image.png](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/1620650409677-0308820b-3621-4364-a198-9e2fb11bf9dc.webp)

客户端存储：

![image.png](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/1620650834542-f0a8cd6c-f60b-4040-ba04-7df375c747a7.webp)

hash一致性：

![image.png](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/1620650872790-56c092a2-fdfd-4431-81b5-889d2e5dfe37.webp)

统一存储：

![image.png](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/1620650906562-303c9a7a-fec7-4dd0-b8e3-ce5ef31233bc.webp)





扩展：

①关于通过HttpSession的setAttribute(LOGIN_USER, data);方法，会将data内容存到浏览器dCooie中吗：

通过HttpSession的setAttribute(LOGIN_USER, data)方法将会话数据存储在服务器端，而不是直接存储在浏览器的 Cookie 中。

当使用HttpSession的setAttribute方法时，它会将指定的数据（data）存储在服务器端的 HttpSession 对象中，并为该会话分配一个唯一的会话标识符（session ID）。这个会话标识符通过名为 "JSESSIONID" 的 Cookie 发送给浏览器，浏览器会在后续的请求中将这个 Cookie 一起发送给服务器。

服务器使用会话标识符来识别与特定用户关联的会话，并从服务器端的 HttpSession 对象中检索会话数据。这种方式可以确保会话数据在客户端和服务器之间传输，但实际的数据并没有直接存储在浏览器的 Cookie 中。

②关于作用域：

保存的session，只会在对应的作用域中显示和使用，子域名可以用父域名的session。只需要将session的作用域设置为付域名，即可解决子域session共享问题。





我们可以通过SpringSession的配置，将session直接存到我们的redis中。



##### 9.配置SpringSession实现子域session共享&json序列化

所有服务的sessionid都是一个，并且在域名中共享，并且我们的 session内容存在redis中。

feature: 配置SpringSession实现子域session共享&json序列化



##### 10.SpringSession核心原理

@EnableRedisHttpSession 导入 RedisHttpSessionConfiguration 配置

1、给容器中添加了一个组件 RedisOperationsSessionRepository：Redis操作session，session的增删改查封装类；

2、继承 SpringHttpSessionConfiguration 初始化了一个 SessionRepositoryFilter：session 存储过滤器；每个请求过来都必须经过 Filter 组件；创建的时候，自动从容器中获取到了 SessionRepository；

 SessionRepositoryFilter：

- 将原生的 HttpServletRequest Response 包装成 SessionRepositoryRequestWrapper ResponseWrapper；包装后的对象应用到了后面整个执行链；
- 以后获取 request.getSession(); 都会调用 wrappedRequesr.getSession(); 从SessionRepository获取；

3、装饰者模式

```java
protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
    request.setAttribute(SESSION_REPOSITORY_ATTR, this.sessionRepository);
    SessionRepositoryFilter<S>.SessionRepositoryRequestWrapper wrappedRequest = new SessionRepositoryFilter.SessionRepositoryRequestWrapper(request, response);
    SessionRepositoryFilter.SessionRepositoryResponseWrapper wrappedResponse = new SessionRepositoryFilter.SessionRepositoryResponseWrapper(wrappedRequest, response);

    try {
        filterChain.doFilter(wrappedRequest, wrappedResponse);
    } finally {
        wrappedRequest.commitSession();
    }

}
```

并且涉及到自动延期，redis中也有过期时间。



##### 11.SSO单点登录

Session + Cookie实现单点登录（对于多个项目）：

单点登录就是单独起一个认证服务,其他服务登录先请求认证服务,认证服务判断自己域名下是否有cookie保存登录信息,如果有直接 返回,如果没有就登录并保存cookie重定向到申请地址

![单点登录流程.png](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/1621688335508-22964e16-b818-4c06-b74a-7aa168e31711.webp)



#### 17、商品业务-购物车

##### 1.购物车服务初始化

feature: 购物车服务初始化

![image-20240316113015792](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240316113015792.png)

![image-20240316113052525](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240316113052525.png)

配置域名映射

![image-20240316115510100](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240316115510100.png)

网关配置

```
# 指定购物车域名的处理
- id: tts_cart_route
  uri: lb://tts-cart
  predicates:
    - Host=cart.tts.com
```



##### 2.数据模型分析和抽取

feature: 购物车vo的抽取

购物车中的信息存储：

将用户购物车的信息存储在redis中，并其数据结构如下所示，方便用户在进行操作后的修改

```
存储结构：
Map<String k1, Map<String k2, CartitemInfo>>
k1: 标识每一个用户的购物车
k2: 购物项的商品id

说明：
在redis中key：用户表示
value：hash（key:商品id value:购物车详情）
```





##### 3.ThreadLocal用户身份鉴别

feature: ThreadLocal用户身份鉴别

在拦截器中统一对用户是否登录进行处理

![image.png](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/1621737371778-7e86b003-ce7f-42b9-b546-d233797ff7d9.webp)

```java
public static ThreadLocal<UserInfoTo> toThreadLocal = new ThreadLocal<>();

// 赋值
toThreadLocal.set(userInfoTo);

// 取值
UserInfoTo userInfoTo = CartInterceptor.toThreadLocal.get();
```



##### 4.添加购物车

feature: 添加购物车



##### 5.刷新重复添加购物车问题

通过重定向的方式解决

fixbug: 刷新重复添加购物车问题



##### 6.获取合并购物项

feature: 获取合并购物项

##### 7.选中购物项

feature: 选中购物项



##### 8.改变购物车中项数量

feature: 改变购物车中项数量

##### 9.购物车内容删除

feature: 购物车内容删除



#### 18、商品业务-消息队列

##### 1.MQ应用

异步消息处理：

![image.png](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/1621739001571-9f36f928-3632-4068-8235-f1768402bf81.webp)

![image.png](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/1621739005626-099bd417-bc62-4293-9ebf-13644d05ee83.webp)

![image.png](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/1621739008547-a718ca00-e6ff-4a82-b31f-3003cceb7ce0.webp)

应用解耦&流量控制：

![image.png](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/1621739027263-dc11f8be-49d1-4c72-8c09-b429f85d3111.webp)





##### 2.mq的流程

![image-20240316213046629](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240316213046629.png)



##### 3.mq核心概念

- Message

消息，消息是不具名的，它由消息头和消息体组成。消息体是不透明的，而消息头则由一系列的可选属性组成， 这些属性包括routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可 能需要持久性存储）等。

- Publisher

消息的生产者，也是一个向交换器发布消息的客户端应用程序。

- Exchange

交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列。

Exchange有4种类型：direct(默认)，fanout,topic,和headers，不同类型的Exchange转发消息的策略有所区别

- Queue

消息队列，用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直 在队列里面，等待消费者连接到这个队列将其取走。

- Binding

绑定，用于消息队列和交换器之间的关联。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交 换器理解成一个由绑定构成的路由表。

Exchange和Queue的绑定可以是多对多的关系。

- Connection

网络连接，比如一个TCP连接。

- Channel

信道，多路复用连接中的一条独立的双向数据流通道。信道是建立在真实的TCP连接内的虚拟连接，AMQP命令都是通过信道 发出去的，不管是发布消息、订阅队列还是接收消息，这些动作都是通过信道完成。因为对于操作系统来说建立和销毁TCP都 是非常昂贵的开销，所以引入了信道的概念，以复用一条TCP连接。

- Consumer

消息的消费者，表示一个从消息队列中取得消息的客户端应用程序。

- Virtual Host

虚拟主机，表示一批交换器、消息队列和相关对象。虚拟主机是共享相同的身份认证和加 密环境的独立服务器域。每个 vhost 本质上就是一个mini版的RabbitMQ 服务器，拥 有自己的队列、交换器、绑定和权限机制。vhost是AMQP概念的基础，必须在连接时 指定，RabbitMQ 默认的vhost是/。

- Broker

表示消息队列服务器实体

![image.png](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/1621758044097-f7e93a0e-6edf-4270-8588-0bb9e596975d.webp)



##### 4.Docker 安装RabbitMQ

- 下载安装镜像

```shell
docker run -d --name rabbitmq -p 5671:5671 -p 5672:5672 -p 4369:4369 -p  25672:25672 -p 15671:15671 -p 15672:15672 rabbitmq:management
```

![image-20240316214252979](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240316214252979.png)

![image-20240316214305597](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240316214305597.png)

4369,25672(Erlang发现&集群端口)

5672,5671(AMQP端口)

15672 (web管理后台端口)

61613,61614(STOMP协议端口)

1883,8883(MQTT协议端口)



- 设置自动重启

```
docker update rabbitmq --restart=always
```

- 访问管理页面

15672 (web管理后台端口)

```
192.168.56.10:15672
```

![image-20240316214524397](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240316214524397.png)

默认账号密码：guest/guest

进入到管理页面

![image-20240316215242108](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240316215242108.png)



##### 5.Exchange类型

AMQP 中消息的路由过程和 Java 开发者熟悉的 JMS 存在一些差别，

AMQP 中增加了 **Exchange** 和**Binding** 的角色。生产者把消息发布到 Exchange 上，消息最终到达队列并被消费者接收，而 Binding 决定交换器的消息应该发送到那个队列。

![image-20240316220058971](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240316220058971.png)

（1）交换机Exchange类型

**Exchange**分发消息时根据类型的不同分发策略有区别，目前共四种类型：direct、fanout、topic、headers 。headers 匹配 AMQP 消息的 header 而不是路由键，

headers 交换器和 direct 交换器完全一致，但性能差很多，目前几乎用不到了，所以直接

看另外三种类型：

![image-20240316220332875](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240316220332875.png)

![image-20240316220632087](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240316220632087.png)





##### 6.SpringBoot整合RabbitMQ

- 引入依赖

```
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-amqp</artifactId>
</dependency>
```

RabbitAutoConfiguration自动配置生效，起提供了四个bean实例：

CachingConnectionFactory、RabbitTemplate、AmqpAdmin、RabbitMessagingTemplate

- 开启功能

```
@EnableRabbit
```

- 配置文件中配置连接信息

CachingConnectionFactory中的RabbitProperties就是配置连接的配置文，所有的属性都在这里进行配置

一些属性都有默认的配置，我么不用管

```yml
spring:
	rabbitmq:
        host: 192.168.56.10
        port: 5672
        virtual-host: /
```



##### 7.在java中使用RabbitMQ

- 创建交换机

```java
@Autowired
private AmqpAdmin amqpAdmin;

/**
 * 1、如何创建Exchange、Queue、Binding
 *      1） 使用AmqpAdmin进行创建
 * 2、如何收发消息
 */
@Test
public void createExchange(){

    /*
    * 创建一个名称为hello-java-exchange交换机(点对点)
    * public DirectExchange(String name, boolean durable, boolean autoDelete, Map<String, Object> arguments)
    * - name: 交换机名称
    * - durable: 交换器是否可持久化
    * - autoDelete: 交换机是否在没有队列绑定的情况下自动删除
    * - arguments: 传递的一些参数
    */
    DirectExchange directExchange = new DirectExchange("hello-java-exchange", true, false);
    amqpAdmin.declareExchange(directExchange);
    System.out.println("Exchang创建成功");

}
```

执行前：

![image-20240317121712769](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240317121712769.png)

执行后：

![image-20240317130541455](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240317130541455.png)



- 创建队列

```java
@Test
public void createQueue() {
    /**
     * 创建一个队列hello-java-queue
     * public Queue(String name, boolean durable, boolean exclusive, boolean autoDelete, Map<String, Object> arguments)
     * - name： 队列名称
     * - durable： 是否可持久化
     * - exclusive：是否排他（只能被连接一次，当该队列被一个连接后，其他不能再连接）
     * - autoDelete：是否自动删除
     * - arguments：参数
     */
    Queue queue = new Queue("hello-java-queue", true, false, false);
    amqpAdmin.declareQueue(queue);
    System.out.println("queue创建成功");
}
```

创建前：

![image-20240317130619462](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240317130619462.png)

创建后：

![image-20240317130722536](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240317130722536.png)



- 创建绑定关系

```java
 @Test
public void creatBinding(){
    /**
     *  public Binding(String destination, Binding.DestinationType destinationType, String exchange, String routingKey, Map<String, Object> arguments) {
     *         this.destination = destination;
     *         this.destinationType = destinationType;
     *         this.exchange = exchange;
     *         this.routingKey = routingKey;
     *         this.arguments = arguments;
     *     }
     *  - destination: 目的地
     *  - destinationType: 目的地类型（交换机、队列）
     *  - exchange: 交换机
     *  - routingKey: 路由键
     *  - arguments: 自定义采纳数
     *  将exchange指定的交换机和destination目的地进行绑定，使用routingKey作为指定路由键
     */
    Binding binding = new Binding("hello-java-queue",
            Binding.DestinationType.QUEUE,
            "hello-java-exchange",
            "hello-java", null);
    amqpAdmin.declareBinding(binding);
    System.out.println("binding创建成功");
}

```

创建前：

![image-20240317131557957](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240317131557957.png)

创建后：

![image-20240317131653689](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240317131653689.png)

- 给对应的队列发送消息

```java
@Autowired
    private RabbitTemplate rabbitTemplate;

    @Test
    public void sendessageTest(){
        String msg = "hello rabbit!";
        /**
         * public void convertAndSend(String exchange, String routingKey, Object object)
         * -exchange：交换机
         * -routingKey： 路由键
         * -object： 消息内容对象（Object类型）
         * 注意：发送消息的时候，如果消息是个对象，我们会使用序列化机制，将对象发送出去
         * 并且，对象必须实现爱你Serializable
         */
        rabbitTemplate.convertAndSend("hello-java-exchange", "hello-java", msg);
        System.out.println("消息发送成！");
    }
```

发送前：

![image-20240317132652000](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240317132652000.png)

发送后：

![image-20240317132821247](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240317132821247.png)

![image-20240317132847590](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240317132847590.png)





如果传的对象是类，其发送的内容是序列化后的结果

如果我们想要其转为json格式发送，我们需要自己配置消息转化器：

```java
@Configuration
public class MyRabbitConfig {
    @Bean
    public MessageConverter messageConverter(){
        return new Jackson2JsonMessageConverter();
    }
}

```

发送测试：

```java
@Test
public void sendessageTest(){
    String msg = "hello rabbit!";
    /**
     * public void convertAndSend(String exchange, String routingKey, Object object)
     * -exchange：交换机
     * -routingKey： 路由键
     * -object： 消息内容对象（Object类型）
     * 注意：发送消息的时候，如果消息是个对象，我们会使用序列化机制，将对象发送出去
     * 并且，对象必须实现爱你Serializable
     */
    OrderEntity orderEntity = new  OrderEntity();
    orderEntity.setCouponId(1L);
    orderEntity.setBillType(1);

    rabbitTemplate.convertAndSend("hello-java-exchange", "hello-java", orderEntity);
    System.out.println("消息发送成！");
}
```

结果：

![image-20240317133949999](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240317133949999.png)





- 接受消息

监听消息：

必须要通过@EnableRabbit开启

①使用@RabbitListener，标注在类上（监听哪些队列）

```java
@Service
public class MQTestServiceImpl implements MQTestService {

    /**
     * @RabbitListener参数：
     * - queues： 声明监听的队列
     *
     *
     *
     * 入参说明：
     * 1. Message message 原生消息内容。头+体
     * 2. T<发送消息的类型> 会帮我们自动转化放到该对象中
     * 3. Channel channel: 当前传输数据的通道
     */
    @RabbitListener(queues = {"hello-java-queue"})
    public void recieveMessage(Message message, OrderEntity content, Channel channel){
        System.out.println("接收到队列中的消息……" + message);
        System.out.println("接收到队列中的消息类型" + message.getClass());

    }

}
```

②@RabbitHandler：标注在方法上（可以用重载区分不同的消息，根据消息类型）

```java
@Service
public class MQTestServiceImpl implements MQTestService {

    /**
     * @RabbitListener参数：
     * - queues： 声明监听的队列
     *
     *
     *
     * 入参说明：
     * 1. Message message 原生消息内容。头+体
     * 2. T<发送消息的类型> 会帮我们自动转化放到该对象中
     * 3. Channel channel: 当前传输数据的通道
     */
    @RabbitListener(queues = {"hello-java-queue"})
    public void recieveMessage(Message message, OrderEntity content, Channel channel){
        System.out.println("接收到队列中的消息……" + message);
        System.out.println("接收到队列中的消息类型" + message.getClass());

    }
    
    @RabbitListener(queues = {"hello-java-queue"})
    public void recieveMessage2(Message message, OrderEntity2 content){
        System.out.println("接收到队列中的消息……" + message);
        System.out.println("接收到队列中的消息类型" + message.getClass());

    }

}
```





##### 8.消息队列的可靠投递

![image-20240317142525955](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240317142525955.png)

![image-20240317142538418](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240317142538418.png)

发送端的两个回调：confirmCallback、returnCallback

发送端的一个回调：ack机制





- 可靠抵达：confirmCallback （发送端到Broke）

服务收到消息就回调

![image-20240317143521377](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240317143521377.png)

配置文件中开启发送端确认：

```yml
spring:
    # 开启发送端确认
    publisher-confirms: true
```

在配置类中设置确认回调：

```java
@Configuration
public class MyRabbitConfig {

    @Autowired
    private RabbitTemplate rabbitTemplate;

    @Bean
    public MessageConverter messageConverter(){
        return new Jackson2JsonMessageConverter();
    }



    @PostConstruct
    public void initRabbitTemplate(){
        // 设置确认回调
        rabbitTemplate.setConfirmCallback(new RabbitTemplate.ConfirmCallback() {
            /**
             * 只要消息抵达Broker就ack=true
             * @param correlationData 当前消息的唯一关联数据（这个消息的唯一id）
             * @param ack 消息是否成功收到
             * @param cause 失败的原因
             */
            @Override
            public void confirm(CorrelationData correlationData, boolean ack, String cause) {
                System.out.println("correlationData内容:" + correlationData);
                System.out.println("ack内容:" + ack);
                System.out.println("cause内容:" + cause);
            }
        });
    }
}
```

结果：

只要服务端收到消息，ack就是ture

![image-20240317144435338](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240317144435338.png)





- returnCallback（可靠抵达，消息到达队列的回调）

![image-20240317144738714](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240317144738714.png)

配置文件中开启：

```yml
spring:
	rabbitmq:
		# 开启发送端消息抵达队列的确认
    	publisher-returns: true
    	# 只要抵达队列，以一步发送优先回调我们这个returnconfirm
        template:
          mandatory: true
```

配置类中开启

```java
@Configuration
public class MyRabbitConfig {

    @Autowired
    private RabbitTemplate rabbitTemplate;

    @Bean
    public MessageConverter messageConverter(){
        return new Jackson2JsonMessageConverter();
    }



    @PostConstruct
    public void initRabbitTemplate(){
        // 设置确认回调
        rabbitTemplate.setConfirmCallback(new RabbitTemplate.ConfirmCallback() {
            /**
             * 只要消息抵达Broker就ack=true
             * @param correlationData 当前消息的唯一关联数据（这个消息的唯一id）
             * @param ack 消息是否成功收到
             * @param cause 失败的原因
             */
            @Override
            public void confirm(CorrelationData correlationData, boolean ack, String cause) {
                System.out.println("correlationData内容:" + correlationData);
                System.out.println("ack内容:" + ack);
                System.out.println("cause内容:" + cause);
            }
        });

        // 设置消息抵达队列的消息回调
        rabbitTemplate.setReturnCallback(new RabbitTemplate.ReturnCallback() {
            /**
             * 只要消息没有投递给指定的队列，就触发这个失败回调
             * @param message 投递失败的消息详细信息
             * @param replyCode 回复的状态码
             * @param replyText 回复的文本内容
             * @param exchange 当时这个消息发送给哪个交换机
             * @param routingKey 当时这个消息是那个路由键
             */
            @Override
            public void returnedMessage(Message message, int replyCode, String replyText, String exchange, String routingKey) {
                System.out.println("message:" + message);
                System.out.println("replyCode:" + replyCode);
                System.out.println("replyText:" + replyText);
                System.out.println("exchange:" + exchange);
                System.out.println("routingKey:" + routingKey);
            }
        });
    }
}
```

在发送消息的时候，我们还可以传递一个参数，即correlationData，当前消息的唯一关联数据

用来后续定位发送失败的消息内容

```
rabbitTemplate.convertAndSend("hello-java-exchange", "hello-java", orderEntity,new CorrelationData(UUID.randomUUID().toString()));
```



- ack机制

消费贷确认中，只有保证每个消息被正确消费，此时broker才会删除队列中的这个消息

默认的ack机制：当我们收到很多消息，如10个，自动回复给服务器的ack，当此时只有一个消息处理成功了，但宕机了，发生其余的9个消息丢失(因为都被默认的ack机制确认了，确认后就会将这项消息从队列中删去)。



手动确认：

配置文件中配置：

```
# 手动ack消息
spring:
	rabbitmq:
        listener:
          simple:
            acknowledge-mode: manual
```

此时经过在应用服务器的监听方法中对这些消息处理了，但由于没有确认，仍然会存在队列中。

即手动确认，没有默认的自动ack，消息就一直是unacked状态，即是consumer宕机，消息也不会丢失，会重新变为ready，下一次有新的consumer连接进来，就发送给它。



如何签收？

```java
 @RabbitListener(queues = {"hello-java-queue"})
public void recieveMessage(Message message, OrderEntity content, Channel channel){
    System.out.println("接收到队列中的消息……" + message);
    System.out.println("接收到队列中的消息类型" + message.getClass());

    // channel内按书序自增
    long deliveryTag = message.getMessageProperties().getDeliveryTag();
    System.out.println("deliveryTag:" + deliveryTag);

    // 签收货物(非批量模式)
    try {
        channel.basicAck(deliveryTag, false);
    } catch (IOException e) {
        e.printStackTrace();
    }

}
```

如果要拒绝可以使用：

最后一个参数表示是否重新发回队列中

```
channel.basicNack(deliveryTab,false, true)
```



![image-20240317155422668](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240317155422668.png)





feature： RabbitMQ相关内容学习



##### 9.RabbitMQ延时队列

（1）场景：比如未付款订单，超过一定时间后，系统自动取消订单并释放占有物品。

（2）常用解决方案：

spring的 schedule 定时任务轮询数据库

缺点：消耗系统内存、增加了数据库的压力、存在较大的时间误差

解决：rabbitmq的消息TTL和死信Exchange结合

（3）消息的TTL：

消息的TTL就是消息的存活时间

RabbitMQ可以对队列和消息分别设置TTL。

• 对队列设置就是队列没有消费者连着的保留时间，也可以对每一个单独的消息做单独的设置。超过了这个时间，我们认为这个消息就死了，称之为死信。

• 如果队列设置了，消息也设置了，那么会取小的。所以一个消息如果被路由到不同的队列中，这个消息死亡的时间有可能不一样（不同的队列设置）。这里单讲单个消息的TTL，因为它才是实现延迟任务的关键。可以通过设置消息的expiration字段或者x- message-ttl属性来设置时间，两者是一样的效果



（4）死信Dead Letter Exchanges（DLX）

一个消息在满足如下条件下，会进死信路由，记住这里是路由而不是队列，

一个路由可以对应很多队列。（什么是死信）

• 一个消息被Consumer拒收了，并且reject方法的参数里requeue是false。也就是说不

会被再次放在队列里，被其他消费者使用。*（**basic.reject/ basic.nack**）**requeue=false*

• 上面的消息的TTL到了，消息过期了。

• 队列的长度限制满了。排在前面的消息会被丢弃或者扔到死信路由上

• Dead Letter Exchange其实就是一种普通的exchange，和创建其他

exchange没有两样。只是在某一个设置Dead Letter Exchange的队列中有

消息过期了，会自动触发消息的转发，发送到Dead Letter Exchange中去。

• 我们既可以控制消息在一段时间后变成死信，又可以控制变成死信的消息

被路由到某一个指定的交换机，结合二者，其实就可以实现一个延时队列

手动ack&异常消息统一放在一个队列处理建议的两种方式

• catch异常后，**手动发送到指定队列**，然后使用channel给rabbitmq确认消息已消费

• 给Queue绑定死信队列，使用nack（requque为false）确认消息消费失败



（4）方案：

方式一：

![image-20240319151805731](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240319151805731.png)

方式二：

![image-20240319151817057](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240319151817057.png)

（5）采用方法

![image-20240319152333688](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240319152333688.png)

![image-20240319152341669](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240319152341669.png)

（6）模拟上述

```java
package com.yjy.tts.order.config;

import org.springframework.amqp.core.Binding;
import org.springframework.amqp.core.Exchange;
import org.springframework.amqp.core.Queue;
import org.springframework.amqp.core.TopicExchange;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.HashMap;
import java.util.Map;


/**
 * 延时队列配置
 * @author banana
 * @create 2024-03-19 15:24
 */
@Configuration
public class MyMQconfig {


    // 容器中的Bingding、Queue、Exchange都会自动创建（前提：rabbitMQ没有设置）

    // 延时队列，死信队列
    @Bean
    public Queue orderDelayQueue(){

        Map<String, Object> arguments = new HashMap<>();
        arguments.put("x-dead-letter-exchange", "order-event-exchange");
        arguments.put("x-dead-letter-routing-key", "order.release.order");
        arguments.put("x-message-ttl", 60000); // 消息过期时间 1分钟
         /*
            Queue(String name,  队列名字
            boolean durable,  是否持久化
            boolean exclusive,  是否排他
            boolean autoDelete, 是否自动删除
            Map<String, Object> arguments) 属性
         */
        Queue queue = new Queue("order.delay.queue", true, false, false, arguments);

        return queue;
    }

    // 解锁队列
    @Bean
    public Queue orderReleaseOrderQueue(){
        Queue queue = new Queue("order.release.order.queue", true, false, false);

        return queue;
    }


    // 交换机（根据不同的路由键绑定不同的队列）
    @Bean
    public Exchange orderEventExchange(){
        /*
         *   String name,
         *   boolean durable,
         *   boolean autoDelete,
         *   Map<String, Object> arguments
         * */
        return new TopicExchange("order-event-exchange", true, false);
    }

    // 绑定关系
    @Bean
    public Binding orderCreateOrderBingding(){
        /*
         * String destination, 目的地（队列名或者交换机名字）
         * DestinationType destinationType, 目的地类型（Queue、Exhcange）
         * String exchange,
         * String routingKey,
         * Map<String, Object> arguments
         * */
        return new Binding("order.delay.queue",
                Binding.DestinationType.QUEUE,
                "order-event-exchange",
                "order.create.order",
                null);
    }

    @Bean
    public Binding orderReleaseOrderBindding(){
        return new Binding("order.release.order.queue",
                Binding.DestinationType.QUEUE,
                "order-event-exchange",
                "order.release.order",
                null);
    }

}

```

可视化查看队列交换机创建情况：

![image-20240319154016514](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240319154016514.png)



![image-20240319153724243](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240319153724243.png)





（7）具体实现

在库存服务中引入mq依赖等配置

交换机图示：

![image-20240319155217229](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240319155217229.png)



相关队列、交换机、绑定、序列化的配置

```
package com.yjy.tts.ware.config;

import org.springframework.amqp.core.*;
import org.springframework.amqp.rabbit.connection.CorrelationData;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.amqp.support.converter.Jackson2JsonMessageConverter;
import org.springframework.amqp.support.converter.MessageConverter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import javax.annotation.PostConstruct;
import java.util.HashMap;

/**
 * @author banana
 * @create 2024-03-17 13:33
 */
@Configuration
public class MyRabbitConfig {

    @Autowired
    private RabbitTemplate rabbitTemplate;

    @Bean
    public MessageConverter messageConverter(){
        return new Jackson2JsonMessageConverter();
    }



    @PostConstruct
    public void initRabbitTemplate() {
        // 设置确认回调
        rabbitTemplate.setConfirmCallback(new RabbitTemplate.ConfirmCallback() {
            /**
             * 只要消息抵达Broker就ack=true
             *
             * @param correlationData 当前消息的唯一关联数据（这个消息的唯一id）
             * @param ack             消息是否成功收到
             * @param cause           失败的原因
             */
            @Override
            public void confirm(CorrelationData correlationData, boolean ack, String cause) {
                System.out.println("correlationData内容:" + correlationData);
                System.out.println("ack内容:" + ack);
                System.out.println("cause内容:" + cause);
            }
        });

        // 设置消息抵达队列的消息回调
        rabbitTemplate.setReturnCallback(new RabbitTemplate.ReturnCallback() {
            /**
             * 只要消息没有投递给指定的队列，就触发这个失败回调
             *
             * @param message    投递失败的消息详细信息
             * @param replyCode  回复的状态码
             * @param replyText  回复的文本内容
             * @param exchange   当时这个消息发送给哪个交换机
             * @param routingKey 当时这个消息是那个路由键
             */
            @Override
            public void returnedMessage(Message message, int replyCode, String replyText, String exchange, String routingKey) {
                System.out.println("message:" + message);
                System.out.println("replyCode:" + replyCode);
                System.out.println("replyText:" + replyText);
                System.out.println("exchange:" + exchange);
                System.out.println("routingKey:" + routingKey);
            }
        });
    }

    /**
     * 库存服务默认的交换机
     * @return
     */
    @Bean
    public Exchange stockEventExchange () {
        //String name, boolean durable, boolean autoDelete, Map<String, Object> arguments
        TopicExchange topicExchange = new TopicExchange("stock-event-exchange", true, false);
        return topicExchange;
    }

    /**
     * 普通队列
     * @return
     */
    @Bean
    public Queue stockReleaseStockQueue() {
        //String name, boolean durable, boolean exclusive, boolean autoDelete, Map<String, Object> arguments
        Queue queue = new Queue("stock.release.stock.queue", true, false, false);
        return queue;
    }


    /**
     * 延迟队列
     * @return
     */
    @Bean
    public Queue stockDelay() {

        HashMap<String, Object> arguments = new HashMap<>();
        arguments.put("x-dead-letter-exchange", "stock-event-exchange");
        arguments.put("x-dead-letter-routing-key", "stock.release");
        // 消息过期时间 2分钟
        arguments.put("x-message-ttl", 120000);

        Queue queue = new Queue("stock.delay.queue", true, false, false,arguments);
        return queue;
    }

    /**
     * 交换机与普通队列绑定
     * @return
     */
    @Bean
    public Binding stockLocked() {
        //String destination, DestinationType destinationType, String exchange, String routingKey,
        // 			Map<String, Object> arguments
        Binding binding = new Binding("stock.release.stock.queue",
                Binding.DestinationType.QUEUE,
                "stock-event-exchange",
                "stock.release.#",
                null);

        return binding;
    }


    /**
     * 交换机与延迟队列绑定
     * @return
     */
    @Bean
    public Binding stockLockedBinding() {
        return new Binding("stock.delay.queue",
                Binding.DestinationType.QUEUE,
                "stock-event-exchange",
                "stock.locked",
                null);
    }

}

```



对于库存解锁场景说明：

- 下订单成功，订单过期没有支付被系统自动取消，被用户手动取消都要解锁库存
- 下订单成功，库存锁定成功，接下来的业务调用失败，导致订单回滚，之前锁定的库存就要自动解锁。

feature: 库存解锁





(8)定时关单

![image-20240319184501809](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240319184501809.png)

feature:定时关单



(9)消息重复、积压

![image-20240319204507986](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240319204507986.png)

![image-20240319204514302](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240319204514302.png)

![image-20240319204521388](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240319204521388.png)



#### 19、商城业务-订单服务

##### 1.页面环境搭建

feautre: 页面环境搭建

- 一些静态资源和网页模板的配置
- 域名配置

![image-20240317162733442](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240317162733442.png)

- 网关配置



##### 2.整合springsession

feature: 整合springsession



##### 3.订单流程说明

相关流程图见P263

##### 4.订单登录拦截

feautre: 订单登录拦截



##### 5.订单确认页模型抽取

feature: 订单确认页模型抽取



##### 6.订单确认页

问题一：Feign调用丢失请求头

其中Feign在进行远程调用的过程中，会出现丢失请求头的问题。

在feign接口创建请求模板的时候，会调用各种的拦截器对请求模板进行修改

因此我们只需要加上一个feign远程调用的拦截器，在header上加上一样的cookie即可。

![image-20240318002528252](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240318002528252.png)



问题二：Feign异步调用丢失请求头

![image-20240318013709629](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240318013709629.png)















##### 7.分布式事务

（1）本地事务不适用分布式的原因

本地事务在分布式系统中，只能控制住自己的回滚，控制不了其他服务的回滚。如A远程调用B，在B执行后，如果发送成功给A的时候，突然网络故障，那么此时A就不知道B是否执行完成，是否落库成功等相关内容。

而对分布式事务来说，出现的最主要原因就是网络问题和分布式机器。

（2）本地事务

事务的基本性质：

数据库事务的几个特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability），简称就是 ACID。

- 原子性：一系列的操作整体不可拆分，要么同时成功，要么同时失败；
- 一致性：数据在事务的前后，业务整体一致；
- 隔离性：事务之间互相隔离；
- 持久性：一旦事务成功，数据一定会落盘在数据库。



事务隔离级别：

- READ UNCOMMITTED（读未提交）：该隔离级别的事务会读到其它未提交事务的数据，此现象也称之为脏读。
- READ COMMITTED（读提交）：一个事务可以读取另一个已提交的事务，多次读取会造成不一样的结果，此现象称为不可重复读问题，Oracle 和 SQL Server 的默认隔离级别。

- REPEATABLE READ（可重复读）：该隔离级别是 MySQL 默认的隔离级别，在同一个事务里，select 的结果是事务开始时时间点的状态，因此，同样的 select 操作读到的结果会是一致的，但是，会有幻读现象。MySQL的 InnoDB 引擎可以通过 next-key locks 机制（参考下文"行锁的算法"一节）来避免幻读。

- SERIALIZABLE（序列化）：在该隔离级别下事务都是串行顺序执行的，MySQL 数据库的 InnoDB 引擎会给读操作隐式加一把读共享锁，从而避免了脏读、不可重读复读和幻读问题。



事务的传播级别：

1. PROPAGATION_REQUIRED： ：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。
2. PROPAGATION_SUPPORTS： ：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。
3. PROPAGATION_MANDATORY： ：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。
4. PROPAGATION_REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建新事务。
5. PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。
6. PROPAGATION_NEVER： 以非事务方式执行，如果当前存在事务，则抛出异常。
7. PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与 PROPAGATION_REQUIRED 类似的操作。



（3）SpringBoot本地事务配置

事务注解：@TransactionAutoConfiguration

在开启的方法上添加：@Transaction

事务的坑：

在同一个类里面，编写两个方法，内部调用的时候，会导致事务设置失效。原因是没有用到代理对象的缘故。

解决：

1. 导入 spring-boot-starter-aop
2. @EnableTransactionManagement(proxyTargetClass = true)
3. @EnableAspectJAutoProxy(exposeProxy=true)
4. AopContext.currentProxy() 调用方法



（4）分布式事务

什么事分布式事务：

分布式系统经常出现的异常：机器宕机、网络异常、消息丢失、消息乱序、数据错误、不可靠的 TCP、存储数据丢失...

![image.png](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/1629027377757-4265e07d-2e43-4914-a63d-8ed52ceaed23.webp)

分布式事务是企业集成中的一个技术难点，也是每一个分布式系统架构中都会涉及到的一个东西，特别是在微服务架构中，几乎可以说是无法避免。



CAP定理：

CAP 原则又称 CAP 定理，指的是在一个分布式系统中

- 一致性（Consistency）：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）
- 可用性（Availability）：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）
- 分区容错性（Partition tolerance）：大多数分布式系统都分布在多个子网络。每个子网络就叫做一个区（partition）。分区容错的意思是，区间通信可能失败。比如，一台服务器放在中国，另一台服务器放在美国，这就是两个区，它们之间可能无法通信。

CAP 原则指的是，这三个要素最多只能同时实现两点，**不可能三者兼顾**。

![img](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/1629027486412-98febddf-f4af-481c-a112-b4fb3e5b7867.png)

一般来说，分区容错无法避免，因此可以认为 CAP 的 P 总是成立。CAP 定理告诉我们，剩下的 C 和 A 无法同时做到。

分布式系统中实现一致性的 raft 算法、paxos

http://thesecretlivesofdata.com/raft/



对于多数大型互联网应用的场景，主机众多、部署分散，而且现在的集群规模越来越大，所以节点故障、网络故障是常态，而且要保证服务可用性达到 99.99999%（N 个 9），即保证P 和 A，舍弃 C。



Base理论：

BASE 理论是对 CAP 理论的延伸，思想是即使无法做到强一致性（CAP 的一致性就是强一致性），但可以采用适当的采取弱一致性，即 **最终一致性**。



BASE 是指

- 基本可用（Basically Available）

- - 基本可用是指分布式系统在出现故障的时候，允许损失部分可用性（例如响应时间、功能上的可用性），允许损失部分可用性。需要注意的是，基本可用绝不等价于系统不可用。

- - - 响应时间上的损失：正常情况下搜索引擎需要在 0.5 秒之内返回给用户相应的查询结果，但由于出现故障（比如系统部分机房发生断电或断网故障），查询结果的响应时间增加到了 1~2 秒。
    - 功能上的损失：购物网站在购物高峰（如双十一）时，为了保护系统的稳定性，部分消费者可能会被引导到一个降级页面。

- 软状态（ Soft State）

- - 软状态是指允许系统存在中间状态，而该中间状态不会影响系统整体可用性。分布式存储中一般一份数据会有多个副本，允许不同副本同步的延时就是软状态的体现。mysql replication 的异步复制也是一种体现。

- 最终一致性（ Eventual Consistency）

- - 最终一致性是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况。

- 

- 

- 强一致性、弱一致性、最终一致性：

- 客户端角度，多进程并发访问时，更新过的数据在不同进程如何获取的不同策略，决定了不同的一致性。对于关系型数据库，要求更新过的数据能被后续的访问都能看到，这是 **强一致性**。如果能容忍后续的部分或者全部访问不到，则是 **弱一致性**。如果经过一段时间后要求能访问到更新后的数据，则是 **最终一致性。**

- 





分布式事务的几种方案：

2PC  模式：

数据库支持的 2PC【2 phase commit 二阶提交】，又叫做 XA Transactions。



MySQL 从 5.5 版本开始支持，SQL Server 2005 开始支持，Oracle 7 开始支持。其中，XA 是一个两阶段提交协议，该协议分为以下两个阶段：



第一阶段：事务协调器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交。

第二阶段：事务协调器要求每个数据库提交数据。



其中，如果有任何一个数据库否决此次提交，那么所有数据库都会被要求回滚它们在此事务中的那部分信息。

![img](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/1629027853525-691cbf54-e9bb-4218-920a-011832bcfd34.png)

- XA 协议比较简单，而且一旦商业数据库实现了 XA 协议，使用分布式事务的成本也比较低。
- XA  性能不理想，特别是在交易下单链路，往往并发量很高，XA 无法满足高并发场景
- XA 目前在商业数据库支持的比较理想，在 在 mysql  数据库中支持的不太理想，mysql 的XA 实现，没有记录 prepare 阶段日志，主备切换回导致主库与备库数据不一致。
- 许多 nosql 也没有支持 XA，这让 XA 的应用场景变得非常狭隘。
- 也有 3PC，引入了超时机制（无论协调者还是参与者，在向对方发送请求后，若长时间未收到回应则做出相应处理）



性事务-TCC ：

刚性事务：遵循 ACID 原则，强一致性。

柔性事务：遵循 BASE 理论，最终一致性；

与刚性事务不同，柔性事务允许一定时间内，不同节点的数据不一致，但要求最终一致。

![img](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/1629027928516-e4e2272b-2df1-48ec-ac90-dee09d1c96ab.png)

一阶段 prepare 行为：调用 自定义 的 prepare 逻辑。

二阶段 commit 行为：调用 自定义 的 commit 逻辑。

二阶段 rollback 行为：调用 自定义 的 rollback 逻辑。

所谓 TCC 模式，是指支持把 自定义 的分支事务纳入到全局事务的管理中。

![img](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/1629027946552-ecb53951-74e1-49c2-880e-85c943845c25.png)



柔性事务-最大努力通知型方案：

按规律进行通知， 不保证数据一定能通知成功，但会提供可查询操作接口进行核对。这种方案主要用在与第三方系统通讯时，比如：调用微信或支付宝支付后的支付结果通知。这种方案也是结合 MQ 进行实现，例如：通过 MQ 发送 http 请求，设置最大通知次数。达到通知次数后即不再通知。



案例：银行通知、商户通知等（各大交易业务平台间的商户通知：多次通知、查询校对、对账文件），支付宝的支付成功异步回调。



柔性事务-可靠消息 + 最终一致性方案（异步确保型）：

实现：业务处理服务在业务事务提交之前，向实时消息服务请求发送消息，实时消息服务只记录消息数据，而不是真正的发送。业务处理服务在业务事务提交之后，向实时消息服务确认发送。只有在得到确认发送指令后，实时消息服务才会真正发送。



防止消息丢失：

1. 做好消息确认机制（ pulisher ， consumer 【手动 ack 】）
2. 每一个发送的消息都在数据库做好记录。定期将失败的消息再次发送一遍.

```
CREATE TABLE `mq_message` (
`message_id` char(32) NOT NULL,
`content` text,
`to_exchane` varchar(255) DEFAULT NULL,
`routing_key` varchar(255) DEFAULT NULL,
`class_type` varchar(255) DEFAULT NULL,
`message_status` int(1) DEFAULT '0' COMMENT '0-新建 1-已发送 2-错误抵达 3-已抵达',
`create_time` datetime DEFAULT NULL,
`update_time` datetime DEFAULT NULL,
PRIMARY KEY (`message_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
```





Seata：

https://seata.io/zh-cn/index.html







##### 8.关于SEATA(△)

（1）Seata是什么

Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案。

![image](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/145942191-7a2d469f-94c8-4cd2-8c7e-46ad75683636.png)

（1）相关术语

- TC (Transaction Coordinator) - 事务协调者

维护全局和分支事务的状态，驱动全局事务提交或回滚。

- TM (Transaction Manager) - 事务管理器

定义全局事务的范围：开始全局事务、提交或回滚全局事务。

- RM (Resource Manager) - 资源管理器

管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。



（2）使用

- 在需要的微服务业务数据库中，创建UNDO_LOG 表

SEATA AT 模式需要 `UNDO_LOG` 表。你可以通过 github 获取到指定版本的undo log SQL [脚本](https://github.com/apache/incubator-seata/tree/2.x/script/client/at/db).：

```sql
CREATE TABLE IF NOT EXISTS `undo_log`
(
    `branch_id`     BIGINT       NOT NULL COMMENT 'branch transaction id',
    `xid`           VARCHAR(128) NOT NULL COMMENT 'global transaction id',
    `context`       VARCHAR(128) NOT NULL COMMENT 'undo_log context,such as serialization',
    `rollback_info` LONGBLOB     NOT NULL COMMENT 'rollback info',
    `log_status`    INT(11)      NOT NULL COMMENT '0:normal status,1:defense status',
    `log_created`   DATETIME(6)  NOT NULL COMMENT 'create datetime',
    `log_modified`  DATETIME(6)  NOT NULL COMMENT 'modify datetime',
    UNIQUE KEY `ux_undo_log` (`xid`, `branch_id`)
    ) ENGINE = InnoDB AUTO_INCREMENT = 1 DEFAULT CHARSET = utf8mb4 COMMENT ='AT transaction mode undo table';
ALTER TABLE `undo_log` ADD INDEX `ix_log_created` (`log_created`);

```



- 安装事务协调器:seata-server

安装地址：

 https://github.com/apache/incubator-seata/releases ,下载服务器软件包，将其解压缩



- 导入seata的依赖

因为是通用的，所以在common项目中导入

```xml
<!--seata分布式事务解决依赖-->
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-seata</artifactId>
</dependency>
```

![image-20240319125248435](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240319125248435.png)



- 启动seata服务

注册配置：

```json
registry {
  # file 、nacos 、eureka、redis、zk、consul、etcd3、sofa
  type = "nacos"

  nacos {
    serverAddr = "localhost:8848"
    namespace = "public"
    cluster = "default"
  }
  eureka {
    serviceUrl = "http://localhost:1001/eureka"
    application = "default"
    weight = "1"
  }
  redis {
    serverAddr = "localhost:6379"
    db = "0"
  }
  zk {
    cluster = "default"
    serverAddr = "127.0.0.1:2181"
    session.timeout = 6000
    connect.timeout = 2000
  }
  consul {
    cluster = "default"
    serverAddr = "127.0.0.1:8500"
  }
  etcd3 {
    cluster = "default"
    serverAddr = "http://localhost:2379"
  }
  sofa {
    serverAddr = "127.0.0.1:9603"
    application = "default"
    region = "DEFAULT_ZONE"
    datacenter = "DefaultDataCenter"
    cluster = "default"
    group = "SEATA_GROUP"
    addressWaitTime = "3000"
  }
  file {
    name = "file.conf"
  }
}

config {
  # file、nacos 、apollo、zk、consul、etcd3
  type = "file"

  nacos {
    serverAddr = "localhost"
    namespace = "public"
    cluster = "default"
  }
  consul {
    serverAddr = "127.0.0.1:8500"
  }
  apollo {
    app.id = "seata-server"
    apollo.meta = "http://192.168.1.204:8801"
  }
  zk {
    serverAddr = "127.0.0.1:2181"
    session.timeout = 6000
    connect.timeout = 2000
  }
  etcd3 {
    serverAddr = "http://localhost:2379"
  }
  file {
    name = "file.conf"
  }
}

```



- 启动服务

![image-20240319130254972](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240319130254972.png)

启动后，可以在注册中心看到该服务

![image-20240319130336925](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240319130336925.png)



- 所有想要用到分布式事务的微服务使用seata DataSourceProxy代理自己的数据源

```java
@Configuration
public class MySeataConfig {

    @Autowired
    DataSourceProperties dataSourceProperties;

    @Bean
    public DataSource dataSource(DataSourceProperties dataSourceProperties){
        HikariDataSource dataSource = dataSourceProperties.initializeDataSourceBuilder().type(HikariDataSource.class).build();
        if (StringUtils.hasText(dataSourceProperties.getName())) {
            dataSource.setPoolName(dataSourceProperties.getName());
        }
        return new DataSourceProxy(dataSource);
    }
}
```



- 每个微服务都导入配置文件(1.1好像不用)

registry.conf和file.conf

![image-20240319132226161](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240319132226161.png)

修改file.conf

```
vgroup_mapping.tts-fescar-service-group = "default"
```



- 为分布式大事务入口标注@GlobalTransactional，每一个远程小事务标注@Transactional

![image-20240319132906200](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240319132906200.png)



#### 20、商城业务-支付

“蚂蚁金服开放平台”地址：

https://open.alipay.com/platform/home.html

找到电脑网站支付文档：

https://open.alipay.com/api/detail?code=I1080300001000041203



##### 1.具体操作：

- 引入服务端SDK

https://opendocs.alipay.com/common/02kkv2?pathHash=358ff034

```xml
<dependency>
  <groupId>com.alipay.sdk</groupId>
  <artifactId>alipay-sdk-java</artifactId>
  <version>4.34.0.ALL</version>
</dependency>
```

- 在沙箱中配置

  ![image-20240319233624731](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240319233624731.png)

![image-20240319233913512](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240319233913512.png)

![image-20240319233942479](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20240319233942479.png)
